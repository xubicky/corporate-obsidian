<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASTRA Studio</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <style>
        :root {
            /* Mixboard / Modern Banking Palette */
            --primary: #2563EB;
            /* Vibrant Blue */
            --primary-dark: #1E40AF;
            --primary-light: #60A5FA;
            --accent: #F59E0B;
            /* Warm Amber for highlights */

            /* Canvas & Surface */
            --bg-canvas: #F8FAFC;
            --bg-surface: #FFFFFF;
            --bg-surface-glass: rgba(255, 255, 255, 0.85);

            /* Text & UI */
            --text-main: #0F172A;
            --text-secondary: #475569;
            --text-muted: #94A3B8;
            --border-subtle: #E2E8F0;

            /* Shadows (The 'Lift') */
            --shadow-sm: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 10px 15px -3px rgba(0, 0, 0, 0.08);
            --shadow-float: 0 20px 40px -5px rgba(0, 0, 0, 0.1);

            /* Categories (Pastels) */
            --cat-macro: #EFF6FF;
            --text-macro: #1D4ED8;
            --cat-geo: #FEF2F2;
            --text-geo: #B91C1C;
            --cat-cyber: #EEF2FF;
            --text-cyber: #4338CA;
            --cat-market: #ECFDF5;
            --text-market: #047857;
            --cat-env: #FFFBEB;
            --text-env: #B45309;
            --cat-social: #FAF5FF;
            --text-social: #7E22CE;
            --cat-reg: #F3F4F6;
            --text-reg: #374151;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            /* Infinite Canvas Look - Dot Grid */
            background-color: var(--bg-canvas);
            background-image: radial-gradient(#CBD5E1 1.5px, transparent 1.5px);
            background-size: 24px 24px;
            color: var(--text-main);
            display: flex;
            padding: 24px;
            gap: 24px;
            /* Space between dock and canvas */
        }

        /* Removed old .glass-background to expose the canvas */
        .glass-background {
            display: none;
        }

        /* ========================================
           LEFT DOCK (Floating Nav)
           ======================================== */
        .nav-rail {
            width: 76px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 0;
            gap: 12px;
            z-index: 50;
            background: var(--bg-surface);
            border-radius: 40px;
            /* Pill/Capsule Shape */
            box-shadow: var(--shadow-float);
            height: fit-content;
            align-self: center;
            /* Vertically centered */
            border: 1px solid var(--border-subtle);
        }

        .nav-logo {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, #2563EB 0%, #4F46E5 100%);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 800;
            font-size: 20px;
            margin-bottom: 24px;
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .nav-item {
            width: 52px;
            height: 52px;
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            /* Bouncy spring */
            font-size: 22px;
            background: transparent;
        }

        .nav-item:hover {
            color: var(--primary);
            background: #EFF6FF;
            transform: scale(1.1);
        }

        .nav-item.active {
            color: white;
            background: var(--primary);
            box-shadow: 0 8px 16px rgba(37, 99, 235, 0.25);
        }

        .nav-spacer {
            flex: 1;
        }

        /* ========================================
           MAIN VIEWPORT (The Canvas Window)
           ======================================== */
        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 24px;
            overflow: hidden;
            /* No background - let the canvas show */
            background: transparent;
            box-shadow: none;
            border-radius: 0;
            margin: 0;
            padding: 0;
            position: relative;
            z-index: 10;
        }

        /* Top Header Bar */
        .header-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            /* No background, just floating text */
        }

        .header-title {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .header-title h1 {
            font-size: 28px;
            font-weight: 800;
            color: var(--text-main);
            letter-spacing: -0.5px;
        }

        .header-title p {
            font-size: 14px;
            color: var(--text-muted);
            font-weight: 500;
        }

        .header-status {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .status-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: white;
            border-radius: 100px;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-subtle);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: #10B981;
            border-radius: 50%;
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.7;
                transform: scale(1.1);
            }
        }

        /* Content Panels Container */
        .content-panels {
            flex: 1;
            display: flex;
            gap: 24px;
            overflow: hidden;
            /* Padding for shadows to breathe */
            padding-bottom: 20px;
        }

        /* ========================================
           CENTER PANEL - THE BOARD
           ======================================== */
        .center-panel {
            flex: 1;
            background: rgba(255, 255, 255, 0.75);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            border: 1px solid rgba(255, 255, 255, 0.8);
            border-radius: 32px;
            box-shadow: var(--shadow-md);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            animation: floatIn 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        @keyframes floatIn {
            from {
                opacity: 0;
                transform: translateY(40px) scale(0.98);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .panel-header {
            padding: 24px 32px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.04);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(255, 255, 255, 0.4);
        }

        .panel-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-main);
            letter-spacing: -0.01em;
        }

        /* Floating Search Pill */
        .search-container {
            display: flex;
            align-items: center;
            gap: 12px;
            background: white;
            border: 1px solid var(--border-subtle);
            border-radius: 100px;
            /* Pill */
            padding: 12px 20px;
            flex: 1;
            max-width: 480px;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-sm);
        }

        .search-container:focus-within {
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.15);
            transform: translateY(-2px);
        }

        .search-icon {
            color: var(--text-muted);
            font-size: 18px;
        }

        .search-input {
            border: none;
            outline: none;
            flex: 1;
            font-size: 15px;
            color: var(--text-main);
            background: transparent;
        }

        .search-input::placeholder {
            color: var(--text-light);
        }

        .search-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 100px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .search-btn:hover {
            background: var(--primary-dark);
            transform: scale(1.05);
        }

        .drivers-area {
            flex: 1;
            padding: 24px 32px;
            overflow-y: auto;
        }

        .category-label {
            font-size: 12px;
            font-weight: 800;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 16px;
            margin-top: 32px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .category-label::after {
            content: '';
            height: 1px;
            flex: 1;
            background: #E2E8F0;
        }

        .drivers-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
        }

        /* Driver Card - The Sticky Detail */
        .driver-card {
            background: white;
            border: 1px solid transparent;
            /* No border initially */
            border-radius: 20px;
            padding: 24px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
            position: relative;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.02), 0 1px 0 rgba(0, 0, 0, 0.02);
        }

        .driver-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: var(--shadow-float);
            z-index: 10;
        }

        .driver-card.selected {
            background: #EFF6FF;
            border: 2px solid var(--primary);
            box-shadow: var(--shadow-md);
        }

        .driver-tag {
            display: inline-flex;
            align-items: center;
            padding: 6px 12px;
            border-radius: 100px;
            font-size: 11px;
            font-weight: 700;
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .driver-title {
            font-size: 16px;
            font-weight: 700;
            color: var(--text-main);
            line-height: 1.4;
            margin-bottom: 10px;
        }

        .driver-desc {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        /* Driver Sources */
        .driver-sources {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(0, 0, 0, 0.06);
        }

        .sources-label {
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .sources-label::before {
            content: 'ðŸ“°';
            font-size: 11px;
        }

        .source-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .source-item {
            font-size: 11px;
            color: var(--primary);
            text-decoration: none;
            display: flex;
            align-items: start;
            gap: 6px;
            transition: all 0.2s ease;
            padding: 2px 0;
        }

        .source-item:hover {
            color: var(--accent);
            text-decoration: underline;
        }

        .source-item::before {
            content: 'â†’';
            flex-shrink: 0;
            opacity: 0.5;
        }

        .source-item-text {
            line-height: 1.4;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        /* ========================================
           RIGHT PANEL - THE BASKET
           ======================================== */
        .right-panel {
            width: 360px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            border: 1px solid rgba(255, 255, 255, 0.6);
            border-radius: 32px;
            box-shadow: var(--shadow-float);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            animation: floatIn 0.8s cubic-bezier(0.2, 0.8, 0.2, 1) 0.1s backwards;
        }

        .basket-header {
            padding: 24px 28px;
            background: transparent;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        .basket-header h3 {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-main);
            margin-bottom: 4px;
        }

        .basket-list {
            flex: 1;
            /* Fill remaining space */
            padding: 20px;
            gap: 16px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .basket-empty {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: var(--text-muted);
            opacity: 0.8;
            transition: all 0.3s ease;
        }

        .basket-empty-icon {
            font-size: 56px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .basket-empty p {
            font-size: 14px;
            line-height: 1.6;
            max-width: 220px;
            font-weight: 500;
        }

        .basket-item {
            background: white;
            border: 1px solid transparent;
            border-radius: 16px;
            padding: 16px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            animation: slideIn 0.3s ease;
            box-shadow: var(--shadow-sm);
            transition: all 0.2s ease;
        }

        .basket-item:hover {
            transform: scale(1.02);
            box-shadow: var(--shadow-md);
        }

        .basket-item-info {
            gap: 16px;
        }

        .basket-item-title {
            font-size: 14px;
            font-weight: 600;
        }

        .generate-btn {
            width: 85%;
            /* Smaller width */
            display: block;
            margin: 0 auto;
            /* Centered */
            background: linear-gradient(135deg, var(--primary) 0%, #4F46E5 100%);
            color: white;
            border: none;
            padding: 14px 24px;
            border-radius: 100px;
            /* Pill shape */
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .basket-footer {
            padding: 24px 28px 36px 28px;
            /* Increased bottom padding to 36px */
            border-top: 1px solid rgba(0, 0, 0, 0.05);
            background: rgba(255, 255, 255, 0.4);
        }

        .generate-btn:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 8px 20px rgba(37, 99, 235, 0.4);
        }

        .generate-btn:disabled {
            background: #CBD5E1;
            color: #94A3B8;
            box-shadow: none;
            cursor: not-allowed;
            transform: none;
        }

        /* ========================================
           MODAL STYLES
           ======================================== */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 23, 42, 0.6);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(8px);
        }

        .modal-content {
            background: white;
            width: 600px;
            max-width: 90%;
            border-radius: 24px;
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            animation: modalSlide 0.3s ease;
        }

        @keyframes modalSlide {
            from {
                transform: translateY(20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            padding: 24px 28px;
            border-bottom: 1px solid #E2E8F0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            font-size: 18px;
            font-weight: 600;
        }

        /* ========================================
           MODAL STYLES (Mixboard Dialogs)
           ======================================== */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 23, 42, 0.25);
            /* Lighter, cleaner overlay */
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .modal-content {
            background: rgba(255, 255, 255, 0.95);
            width: 600px;
            max-width: 90%;
            max-height: 90vh;
            /* Limit height to 90% of viewport */
            border-radius: 32px;
            /* Deep rounded corners */
            box-shadow: var(--shadow-float);
            overflow-y: auto;
            /* Make content scrollable */
            animation: modalSlide 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            border: 1px solid rgba(255, 255, 255, 0.6);
            display: flex;
            flex-direction: column;
            /* Ensure header stays at top */
        }

        @keyframes modalSlide {
            from {
                transform: translateY(40px) scale(0.9);
                opacity: 0;
            }

            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        .modal-header {
            padding: 24px 32px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            /* Keep header visible when scrolling */
            top: 0;
            background: rgba(255, 255, 255, 0.98);
            /* Ensure header has solid background */
            z-index: 10;
            backdrop-filter: blur(8px);
            flex-shrink: 0;
            /* Prevent header from shrinking */
        }

        .modal-header h2 {
            font-size: 24px;
            font-weight: 800;
            color: var(--text-main);
        }

        .modal-close {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 1px solid var(--border-subtle);
            background: white;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: #F1F5F9;
            color: var(--text-main);
            transform: rotate(90deg);
        }

        .modal-body {
            padding: 32px;
            flex: 1;
            /* Allow body to grow and scroll */
            overflow-y: auto;
            /* Make body scrollable if content is too long */
        }

        .modal-tag {
            display: inline-flex;
            padding: 8px 16px;
            border-radius: 100px;
            font-size: 12px;
            font-weight: 700;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .modal-desc {
            font-size: 15px;
            line-height: 1.6;
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* Chat Container */
        .chat-container {
            margin-top: 28px;
            border: 1px solid var(--border-subtle);
            border-radius: 20px;
            overflow: hidden;
            background: #F8FAFC;
        }

        .chat-history {
            height: 240px;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .chat-message {
            max-width: 85%;
            padding: 12px 18px;
            border-radius: 18px;
            font-size: 14px;
            line-height: 1.5;
            box-shadow: var(--shadow-sm);
        }

        .chat-message.user {
            align-self: flex-end;
            background: var(--primary);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .chat-message.ai {
            align-self: flex-start;
            background: white;
            color: var(--text-main);
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-bottom-left-radius: 4px;
        }

        .chat-input-area {
            padding: 16px;
            background: white;
            border-top: 1px solid rgba(0, 0, 0, 0.05);
            display: flex;
            gap: 12px;
        }

        .chat-input {
            flex: 1;
            border: 1px solid var(--border-subtle);
            border-radius: 100px;
            padding: 12px 20px;
            font-size: 14px;
            outline: none;
            transition: all 0.2s;
        }

        .chat-input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .chat-send {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: none;
            background: var(--primary);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .chat-send:hover {
            transform: scale(1.1) rotate(-10deg);
            background: var(--primary-dark);
        }

        .modal-footer {
            padding: 24px 32px;
            border-top: 1px solid rgba(0, 0, 0, 0.05);
            display: flex;
            justify-content: flex-end;
            background: #F8FAFC;
        }

        .modal-action-btn {
            padding: 14px 32px;
            border-radius: 100px;
            /* Pill */
            border: none;
            font-size: 15px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
        }

        /* HEADER & UTILITY CONTROLS (Mixboard Style) */
        .pill-select {
            appearance: none;
            padding: 10px 32px 10px 16px;
            font-size: 13px;
            border-radius: 100px;
            border: 1px solid var(--border-subtle);
            background: var(--bg-surface) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%2364748B' viewBox='0 0 16 16'%3E%3Cpath d='M7.247 11.14 2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z'/%3E%3C/svg%3E") no-repeat right 12px center;
            cursor: pointer;
            font-family: inherit;
            font-weight: 600;
            color: var(--text-main);
            box-shadow: var(--shadow-sm);
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            outline: none;
        }

        .pill-select:hover {
            border-color: var(--primary-light);
            box-shadow: var(--shadow-md);
            transform: translateY(-1px);
        }

        .icon-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 1px solid var(--border-subtle);
            background: var(--bg-surface);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: var(--shadow-sm);
            color: var(--text-secondary);
        }

        .icon-btn:hover {
            transform: translateY(-2px) scale(1.1);
            box-shadow: var(--shadow-md);
            color: var(--primary);
            border-color: var(--primary-light);
        }

        .icon-btn.primary {
            background: var(--primary);
            color: white;
            border: none;
        }

        .icon-btn.primary:hover {
            background: var(--primary-dark);
        }

        .header-toolbar {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        /* Loader Overlay match */
        .loader-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 4px solid #E2E8F0;
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            100% {
                transform: rotate(360deg);
            }
        }

        .loader-text {
            margin-top: 20px;
            font-size: 15px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* ========================================
           REPORT OVERLAY
           ======================================== */
        .report-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 23, 42, 0.7);
            display: none;
            justify-content: center;
            align-items: flex-start;
            z-index: 150;
            overflow-y: auto;
            padding: 40px 20px;
            backdrop-filter: blur(8px);
        }

        .report-container {
            background: white;
            width: 1200px;
            /* Increased width for side-by-side layout */
            max-width: 95%;
            height: 90vh;
            /* Fixed height for layout */
            border-radius: 24px;
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .report-content-wrapper {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .report-main {
            flex: 2;
            overflow-y: auto;
            border-right: 1px solid #E2E8F0;
            display: flex;
            flex-direction: column;
        }

        .report-sidebar {
            flex: 1;
            background: #F8FAFC;
            display: flex;
            flex-direction: column;
            min-width: 350px;
            max-width: 400px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            border-left: 1px solid #E2E8F0;
        }

        .report-sidebar.collapsed {
            min-width: 60px;
            max-width: 60px;
        }

        .report-sidebar.collapsed .report-chat-history,
        .report-sidebar.collapsed .report-chat-input-area,
        .report-sidebar.collapsed .report-chat-header span {
            display: none;
        }

        .report-sidebar.collapsed .report-chat-header {
            justify-content: center;
            padding: 20px 0;
        }

        .report-chat-header {
            padding: 20px;
            border-bottom: 1px solid #E2E8F0;
            background: white;
            font-weight: 600;
            color: var(--text-main);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            white-space: nowrap;
        }

        .sidebar-toggle-btn {
            background: transparent;
            border: none;
            cursor: pointer;
            color: var(--text-muted);
            padding: 4px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .sidebar-toggle-btn:hover {
            background: #F1F5F9;
            color: var(--primary);
        }

        .report-sidebar.collapsed .sidebar-toggle-btn {
            transform: rotate(180deg);
        }

        .report-chat-history {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .report-chat-input-area {
            padding: 20px;
            background: white;
            border-top: 1px solid #E2E8F0;
            display: flex;
            gap: 10px;
        }

        .report-header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
            color: white;
            padding: 36px;
        }

        .report-title {
            font-size: 26px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .report-subtitle {
            font-size: 14px;
            opacity: 0.9;
        }

        .report-body {
            padding: 36px;
        }

        .report-section {
            margin-bottom: 32px;
        }

        .report-section:last-child {
            margin-bottom: 0;
        }

        .section-title {
            font-size: 12px;
            font-weight: 700;
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-title::before {
            content: '';
            width: 4px;
            height: 16px;
            background: var(--primary);
            border-radius: 2px;
        }

        .section-content {
            background: #F8FAFC;
            border: 1px solid #E2E8F0;
            border-radius: 16px;
            padding: 24px;
            line-height: 1.8;
            font-size: 14px;
            color: var(--text-secondary);
        }

        .drivers-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .driver-pill {
            padding: 8px 14px;
            border-radius: 100px;
            font-size: 12px;
            font-weight: 600;
        }

        .macro-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
        }

        .macro-card {
            background: white;
            border: 1px solid #E2E8F0;
            border-radius: 14px;
            padding: 20px;
            text-align: center;
            transition: all 0.2s ease;
        }

        .macro-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08);
        }

        .macro-label {
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .macro-value {
            font-size: 26px;
            font-weight: 700;
            color: var(--text-main);
        }

        .macro-value.negative {
            color: #DC2626;
        }

        .macro-value.positive {
            color: #059669;
        }

        .macro-delta {
            font-size: 11px;
            margin-top: 6px;
            color: var(--text-muted);
        }

        .report-footer {
            padding: 24px 36px;
            background: #F8FAFC;
            border-top: 1px solid #E2E8F0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .report-disclaimer {
            font-size: 12px;
            color: var(--text-muted);
        }

        .report-actions {
            display: flex;
            gap: 12px;
        }

        .btn-secondary {
            background: white;
            border: 1px solid #E2E8F0;
            padding: 12px 24px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-secondary:hover {
            background: #F1F5F9;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.12);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.2);
        }

        /* ========================================
           HEAT MAP STYLES
           ======================================== */
        .heatmap-container {
            flex: 1;
            display: flex;
            flex-direction: row;
            /* Horizontal layout */
            gap: 24px;
            padding: 24px;
            position: relative;
            overflow: hidden;
            align-items: flex-start;
            /* Align top */
        }

        .heatmap-wrapper {
            flex: 1;
            display: flex;
            position: relative;
            min-height: 600px;
            flex-direction: row;
            /* Horizontal layout for Axes + Grid */
        }

        /* Update Legend to be a sidebar */
        .heatmap-legend {
            position: relative;
            /* Not absolute anymore */
            top: auto;
            right: auto;
            width: 240px;
            flex-shrink: 0;
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(12px);
            border-radius: 16px;
            padding: 20px;
            box-shadow: none;
            border: 1px solid var(--border-subtle);
            z-index: 10;
        }

        .heatmap-y-axis {
            width: 120px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-end;
            padding: 20px 0;
            position: relative;
        }

        .heatmap-y-label {
            /* writing-mode removed for better html2canvas support */
            font-size: 12px;
            font-weight: 700;
            color: var(--text-secondary);
            letter-spacing: 0.5px;
            position: absolute;
            left: -20px;
            top: 50%;
            transform: translateY(-50%) rotate(-90deg);
            white-space: nowrap;
            width: max-content;
        }

        .heatmap-y-markers {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 100%;
            padding-right: 8px;
            text-align: right;
            min-width: 50px;
        }

        .heatmap-y-marker {
            font-size: 11px;
            color: var(--text-muted);
            font-weight: 500;
            text-align: right;
        }

        .heatmap-grid-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .heatmap-grid {
            flex: 1;
            position: relative;
            background: linear-gradient(135deg,
                    rgba(16, 185, 129, 0.03) 0%,
                    rgba(245, 158, 11, 0.05) 50%,
                    rgba(239, 68, 68, 0.08) 100%);
            border: 2px solid var(--border-subtle);
            border-radius: 16px;
            overflow: visible;
            min-height: 500px;
            /* Add padding to prevent drivers from going behind legend */
            padding: 20px 220px 20px 20px;
        }

        /* Gradient zones overlay */
        .heatmap-grid::before {
            content: '';
            position: absolute;
            inset: 0;
            background:
                linear-gradient(to right, rgba(16, 185, 129, 0.1) 0%, transparent 40%),
                linear-gradient(to top, rgba(16, 185, 129, 0.1) 0%, transparent 40%),
                linear-gradient(to left, rgba(239, 68, 68, 0.1) 0%, transparent 40%),
                linear-gradient(to bottom, rgba(239, 68, 68, 0.1) 0%, transparent 40%);
            pointer-events: none;
            border-radius: 14px;
        }

        /* Grid lines */
        .heatmap-grid::after {
            content: '';
            position: absolute;
            inset: 0;
            background-image:
                linear-gradient(to right, rgba(0, 0, 0, 0.03) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(0, 0, 0, 0.03) 1px, transparent 1px);
            background-size: 10% 10%;
            pointer-events: none;
            border-radius: 14px;
        }

        .heatmap-x-axis {
            height: 50px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 12px;
        }

        .heatmap-x-label {
            font-size: 13px;
            font-weight: 700;
            color: var(--text-secondary);
            letter-spacing: 0.5px;
        }

        .heatmap-x-markers {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 0 10px;
            margin-bottom: 8px;
        }

        .heatmap-x-marker {
            font-size: 11px;
            color: var(--text-muted);
            font-weight: 500;
        }

        /* Heat Map Driver Card */
        .heatmap-driver {
            position: absolute;
            display: flex;
            flex-direction: column;
            width: 220px;
            padding: 12px 14px;
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(12px);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.25s ease, width 0.25s ease, opacity 0.15s ease;
            z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            overflow: visible;
            transform-origin: top left;
        }

        /* Compact view: Reset card styling to transparent */
        .heatmap-driver.compact-mode {
            background: transparent;
            backdrop-filter: none;
            border: none;
            box-shadow: none;
            padding: 0;
            width: auto;
        }

        /* Minimal view: Just the circle */
        .heatmap-driver.minimal-mode {
            background: transparent;
            backdrop-filter: none;
            border: none;
            box-shadow: none;
            padding: 0;
            width: auto;
        }

        /* Compact view: Show details on hover */
        .heatmap-driver.compact-mode:hover .compact-expand {
            display: block !important;
        }


        .heatmap-driver.compact-mode:hover .compact-pill {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
        }

        /* Minimal view: Show details on hover */
        .heatmap-driver.minimal-mode:hover .minimal-expand {
            display: block !important;
        }

        /* Velocity circle is the anchor - positioned at card's coordinates */
        .heatmap-driver-anchor {
            position: absolute;
            top: -10px;
            left: -10px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            cursor: grab;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .heatmap-driver-anchor.high {
            background: #EF4444;
            box-shadow: 0 0 12px rgba(239, 68, 68, 0.6);
        }

        .heatmap-driver-anchor.medium {
            background: #F59E0B;
            box-shadow: 0 0 12px rgba(245, 158, 11, 0.6);
        }

        .heatmap-driver-anchor.low {
            background: #10B981;
            box-shadow: 0 0 12px rgba(16, 185, 129, 0.6);
        }

        .heatmap-driver-anchor svg {
            width: 14px;
            height: 14px;
            fill: white;
        }

        /* Card body - everything except the anchor circle */
        .heatmap-driver-body {
            transition: opacity 0.2s ease, max-height 0.25s ease;
        }

        /* DRAGGING STATE: Collapse to just the circle */
        .heatmap-driver.dragging {
            width: 24px !important;
            height: 24px !important;
            padding: 0 !important;
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            z-index: 2000;
            cursor: grabbing;
        }

        .heatmap-driver.dragging .heatmap-driver-body {
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            pointer-events: none;
        }

        .heatmap-driver.dragging .heatmap-driver-anchor {
            top: 0;
            left: 0;
            transform: scale(1.3);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
            cursor: grabbing;
        }

        /* Focus Mode: Dim other cards when one is hovered to resolve overlaps visually */
        .heatmap-grid:has(.heatmap-driver:hover) .heatmap-driver:not(:hover) {
            opacity: 0.2;
            filter: blur(1px);
            z-index: 1;
            /* Push to back */
        }

        /* HOVER STATE: Bring to front with subtle highlight */
        .heatmap-driver:not(.dragging):not(.expanded):hover {
            z-index: 1000;
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.4);
            border-color: rgba(59, 130, 246, 0.4);
            /* Ensure opacity stays 1 */
            opacity: 1 !important;
            filter: none !important;
        }

        /* Override for Minimal and Compact modes to prevent width jump */
        .heatmap-driver.minimal-mode:hover,
        .heatmap-driver.compact-mode:hover {
            width: auto !important;
            box-shadow: none !important;
            border: none !important;
            background: transparent !important;
        }


        /* Expansion content - hidden by default */
        .heatmap-driver-expand {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.2s ease, margin 0.2s ease;
            margin-top: 0;
        }

        /* Expand when .expanded class is applied (from click) */
        .heatmap-driver.expanded {
            z-index: 1000;
            width: 280px;
            box-shadow: 0 16px 40px rgba(0, 0, 0, 0.5);
            border-color: rgba(59, 130, 246, 0.5);
            opacity: 1 !important;
            filter: none !important;
        }

        .heatmap-driver.expanded .heatmap-driver-expand {
            max-height: 400px;
            opacity: 1;
            margin-top: 8px;
        }


        .heatmap-driver-expand-desc {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.4;
            margin-bottom: 8px;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .heatmap-driver-expand-meta {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            font-size: 9px;
            color: rgba(255, 255, 255, 0.6);
            padding-top: 6px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .heatmap-driver-expand-meta strong {
            color: white;
            margin-left: 2px;
        }

        /* 4-WAY SMART EXPANSION AND ANCHORING */
        .heatmap-driver {
            transform-origin: center;
            /* Let translate handle positioning */
        }

        /* RIGHT EDGE: Expand Left */
        .heatmap-driver.expand-left {
            transform: translateX(-100%);
        }

        .heatmap-driver.expand-left .heatmap-driver-anchor {
            left: auto;
            right: -10px;
        }

        /* BOTTOM EDGE: Expand Up */
        .heatmap-driver.expand-up {
            transform: translateY(-100%);
        }

        .heatmap-driver.expand-up .heatmap-driver-anchor {
            top: auto;
            bottom: -10px;
        }

        /* BOTTOM-RIGHT CORNER: Expand Up-Left */
        .heatmap-driver.expand-left.expand-up {
            transform: translate(-100%, -100%);
        }

        .heatmap-driver.expand-left.expand-up .heatmap-driver-anchor {
            top: auto;
            bottom: -10px;
            left: auto;
            right: -10px;
        }

        .heatmap-driver-header {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            margin-bottom: 8px;
        }

        .heatmap-driver-title {
            font-size: 12px;
            font-weight: 700;
            color: white;
            line-height: 1.3;
            flex: 1;
        }

        .heatmap-driver-velocity {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .heatmap-driver-velocity.high {
            background: #EF4444;
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.5);
        }

        .heatmap-driver-velocity.medium {
            background: #F59E0B;
            box-shadow: 0 0 8px rgba(245, 158, 11, 0.5);
        }

        .heatmap-driver-velocity.low {
            background: #10B981;
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.5);
        }

        .heatmap-driver-velocity svg {
            width: 12px;
            height: 12px;
            fill: white;
        }

        .heatmap-driver-category {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 6px;
            font-size: 9px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .heatmap-driver-percentage {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 6px;
        }

        .heatmap-velocity-bar {
            height: 4px;
            border-radius: 2px;
            margin-top: 8px;
            background: rgba(255, 255, 255, 0.2);
            overflow: hidden;
        }

        .heatmap-velocity-bar-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .heatmap-velocity-bar-fill.high {
            background: linear-gradient(90deg, #EF4444, #F87171);
        }

        .heatmap-velocity-bar-fill.medium {
            background: linear-gradient(90deg, #F59E0B, #FBBF24);
        }

        .heatmap-velocity-bar-fill.low {
            background: linear-gradient(90deg, #10B981, #34D399);
        }

        /* Global Heatmap Tooltip */
        #globalHeatmapTooltip {
            display: none;
            position: fixed;
            z-index: 10000;
            width: 280px;
            padding: 16px;
            background: rgba(15, 23, 42, 0.98);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            /* Let mouse pass through so it doesn't flicker */
            opacity: 0;
            transition: opacity 0.15s ease;
            backdrop-filter: blur(10px);
        }

        #globalHeatmapTooltip .tooltip-title {
            font-size: 14px;
            font-weight: 700;
            color: white;
            margin-bottom: 8px;
            line-height: 1.3;
        }

        #globalHeatmapTooltip .tooltip-desc {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 12px;
            line-height: 1.5;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        #globalHeatmapTooltip .tooltip-meta {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 11px;
            color: rgba(255, 255, 255, 0.9);
        }

        /* Clickable velocity indicator */
        .heatmap-driver-velocity {
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .heatmap-driver-velocity:hover {
            transform: scale(1.2);
        }




        .heatmap-driver-tooltip-title {
            font-size: 14px;
            font-weight: 700;
            color: white;
            margin-bottom: 8px;
        }

        .heatmap-driver-tooltip-desc {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.5;
        }

        .heatmap-driver-tooltip-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 8px 16px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 11px;
        }

        .heatmap-driver-tooltip-meta span {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.6);
        }

        /* Heat Map Legend */
        /* Heat Map Legend - REPLACED BY SIDEBAR STYLES ABOVE */
        /* .heatmap-legend styles removed from here to avoid duplication */

        .heatmap-legend-title {
            font-size: 11px;
            font-weight: 700;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .heatmap-legend-section {
            margin-bottom: 14px;
        }

        .heatmap-legend-section:last-child {
            margin-bottom: 0;
        }

        .heatmap-legend-subtitle {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-muted);
            margin-bottom: 6px;
        }

        .heatmap-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            font-size: 10px;
            color: var(--text-secondary);
        }

        .heatmap-legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            flex-shrink: 0;
        }

        .heatmap-legend-velocity {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        /* Heat Map Basket Panel */
        .heatmap-basket {
            display: flex;
            flex-direction: column;
        }

        .heatmap-basket-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .heatmap-btn {
            width: 100%;
            padding: 14px 20px;
            border-radius: 100px;
            border: none;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .heatmap-btn-primary {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            box-shadow: 0 4px 14px rgba(37, 99, 235, 0.3);
        }

        .heatmap-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(37, 99, 235, 0.4);
        }

        .heatmap-btn-secondary {
            background: white;
            color: var(--text-main);
            border: 1px solid var(--border-subtle);
            box-shadow: var(--shadow-sm);
        }

        .heatmap-btn-secondary:hover {
            background: #F8FAFC;
            border-color: var(--primary-light);
        }

        /* Generate Heat Map button style */
        /* Generate Heat Map button style - Matching generate-btn but with Heat colors */
        .generate-heatmap-btn {
            width: 85%;
            display: block;
            margin: 0 auto;
            padding: 14px 24px;
            border-radius: 100px;
            border: none;
            background: linear-gradient(135deg, #F59E0B 0%, #EF4444 100%);
            color: white;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .generate-heatmap-btn:hover:not(:disabled) {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 8px 20px rgba(239, 68, 68, 0.4);
        }

        .generate-heatmap-btn:disabled {
            background: #CBD5E1;
            color: #94A3B8;
            box-shadow: none;
            cursor: not-allowed;
            transform: none;
        }

        /* Help toggle button */
        .help-toggle-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 1px solid var(--border-subtle);
            background: white;
            color: var(--text-muted);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .help-toggle-btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        /* Help panel */
        .heatmap-help-panel {
            background: #F0F7FF;
            border-bottom: 1px solid var(--border-subtle);
            padding: 14px 16px;
            animation: slideDown 0.2s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .heatmap-help-content {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .heatmap-help-content p {
            margin-bottom: 6px;
        }

        .heatmap-help-content p:last-child {
            margin-bottom: 0;
        }

        .heatmap-help-content strong {
            color: var(--text-main);
        }

        /* Heatmap Tool Buttons Animation */
        .tools-row {
            display: flex;
            align-items: center;
            gap: 4px;
            width: 100%;
            margin-bottom: 20px;
            background: white;
            border: 1px solid var(--border-subtle);
            border-radius: 100px;
            padding: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.03);
        }

        .tool-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 4px;
            background: transparent;
            border: none;
            border-radius: 100px;
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            white-space: nowrap;
            overflow: hidden;
            position: relative;
            min-width: 0;
            box-shadow: none;
        }

        .tool-btn:hover {
            flex: 2;
            background: #F1F5F9;
            color: var(--primary);
            box-shadow: none;
            transform: none;
        }

        .tool-text {
            display: flex;
            align-items: center;
        }

        .tool-extra {
            max-width: 0;
            opacity: 0;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            display: inline-block;
            white-space: nowrap;
        }

        .tool-btn:hover .tool-extra {
            max-width: 120px;
            opacity: 1;
            margin-left: 4px;
        }

        /* View Mode Selector Styles */
        .view-mode-group {
            display: flex;
            align-items: center;
            gap: 4px;
            width: 100%;
            background: white;
            border: 1px solid var(--border-subtle);
            border-radius: 100px;
            padding: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.03);
            margin-top: 8px;
        }

        .view-mode-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 4px;
            background: transparent;
            border: none;
            border-radius: 100px;
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .view-mode-btn:hover {
            background: #F1F5F9;
            color: var(--primary);
        }

        .view-mode-btn.active {
            background: var(--primary);
            color: white;
            box-shadow: 0 2px 6px rgba(37, 99, 235, 0.2);
        }

        .view-mode-btn.active:hover {
            background: var(--primary);
            color: white;
        }

        .heatmap-legend-items {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .heatmap-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            padding: 2px 4px;
            border-radius: 4px;
        }

        .heatmap-legend-item:hover {
            background: rgba(0, 0, 0, 0.03);
        }

        .heatmap-legend-item.legend-dimmed {
            opacity: 0.3;
        }

        .heatmap-legend-velocity {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
    </style>
</head>

<body>
    <!-- Full-width Glass Background -->
    <div class="glass-background"></div>

    <!-- LEFT NAVIGATION RAIL -->
    <nav class="nav-rail">
        <div class="nav-logo">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5" />
            </svg>
        </div>

        <div class="nav-item" title="Risk Drivers" onclick="showMarketplace()">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="7" height="7"></rect>
                <rect x="14" y="3" width="7" height="7"></rect>
                <rect x="14" y="14" width="7" height="7"></rect>
                <rect x="3" y="14" width="7" height="7"></rect>
            </svg>
        </div>

        <div class="nav-item" title="Heat Map" onclick="showHeatMap()">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round">
                <path d="M18 20V10M12 20V4M6 20V14"></path>
            </svg>
        </div>

        <div class="nav-item" title="Folder" onclick="showSavedScenarios()">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round">
                <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
            </svg>
        </div>


        <div class="nav-item" title="Settings" onclick="showSettingsModal()">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"></circle>
                <path
                    d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z">
                </path>
            </svg>
        </div>

        <div class="nav-spacer"></div>
    </nav>

    <!-- MAIN CONTENT AREA -->
    <main class="main-area">

        <!-- Header Bar -->
        <header class="header-bar">
            <div class="header-title">
                <h1>ASTRA Studio</h1>
                <p>Scenario and Narrative Platform 1/9</p>
            </div>
            <div class="header-status" style="display: flex; align-items: center; gap: 12px;">
                <!-- Dossier Selector Only -->
                <div class="header-toolbar">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <label
                            style="font-size: 11px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">Dossier</label>
                        <select id="dossierSelector" onchange="loadSelectedDossier()" class="pill-select">
                            <option value="current">Current (Live)</option>
                        </select>
                    </div>
                </div>
                <div class="status-badge">
                    <span class="status-dot"></span>
                    <span id="connectionStatusText">Connected to Azure OpenAI</span>
                </div>
            </div>
        </header>

        <!-- Content Panels -->
        <div class="content-panels">

            <!-- CENTER: Driver Marketplace -->
            <section class="center-panel" id="marketplacePanel">
                <div class="panel-header">
                    <span class="panel-title">Risk Driver Marketplace</span>
                    <div class="search-container">
                        <span class="search-icon">ðŸ”</span>
                        <input type="text" id="aiInput" class="search-input" placeholder="Search drivers or ask AI..."
                            onkeypress="handleEnter(event)" oninput="filterDrivers(this.value)">
                        <button class="search-btn" onclick="createCustomDriver()">Search & Add</button>
                    </div>
                </div>
                <div class="drivers-area" id="driversContainer">
                    <!-- Drivers populate here -->
                </div>
            </section>

            <!-- CENTER: Saved Scenarios View (Hidden by default) -->
            <section class="center-panel" id="savedScenariosPanel" style="display: none;">
                <div class="panel-header">
                    <span class="panel-title">Folder</span>
                </div>
                <div class="drivers-area">
                    <div class="drivers-grid" id="savedScenariosGrid">
                        <!-- Saved scenarios populate here -->
                    </div>
                </div>
            </section>

            <!-- CENTER: Heat Map View (Hidden by default) -->
            <section class="center-panel" id="heatMapPanel"
                style="display: none; height: calc(100vh - 130px); overflow-y: auto;">
                <div class="panel-header">
                    <span class="panel-title">Risk Heat Map</span>
                    <div class="heatmap-instructions" style="font-size: 12px; color: var(--text-muted);">
                        Drag drivers to adjust their likelihood and materiality
                    </div>
                </div>
                <div class="heatmap-container">
                    <div class="heatmap-wrapper">
                        <!-- Global Heatmap Tooltip -->
                        <div id="globalHeatmapTooltip">
                            <div class="tooltip-title"></div>
                            <div class="tooltip-desc"></div>
                            <div class="tooltip-meta"></div>
                        </div>

                        <!-- Modals -->
                        <!-- Y-Axis -->
                        <div class="heatmap-y-axis">
                            <div class="heatmap-y-label">Impact to RBC</div>
                            <div class="heatmap-y-markers">
                                <span class="heatmap-y-marker">High</span>
                                <span class="heatmap-y-marker"></span>
                                <span class="heatmap-y-marker">Medium</span>
                                <span class="heatmap-y-marker"></span>
                                <span class="heatmap-y-marker">Low</span>
                            </div>
                        </div>
                        <!-- Grid Area -->
                        <div class="heatmap-grid-area">
                            <div class="heatmap-grid" id="heatmapGrid">
                                <!-- Drivers will be positioned here -->
                            </div>
                            <!-- X-Axis -->
                            <div class="heatmap-x-axis">
                                <div class="heatmap-x-markers">
                                    <span class="heatmap-x-marker">Low</span>
                                    <span class="heatmap-x-marker"></span>
                                    <span class="heatmap-x-marker">Medium</span>
                                    <span class="heatmap-x-marker"></span>
                                    <span class="heatmap-x-marker">High</span>
                                </div>
                                <span class="heatmap-x-label">Likelihood of Risk Materializing with Adverse Outcome to
                                    RBC</span>
                            </div>
                            <!-- Footnote -->
                            <div
                                style="text-align: center; font-size: 10px; color: var(--text-muted); margin-top: 12px; font-style: italic; opacity: 0.7;">
                                Velocity refers to the time elapsed between the materialization of a risk event and the
                                point of RC's impact.
                            </div>
                        </div>
                    </div>
                    <!-- Legend -->
                    <div class="heatmap-legend" id="heatmapLegend">
                        <div class="heatmap-legend-title">Legend</div>
                        <div class="heatmap-legend-section">
                            <div class="heatmap-legend-subtitle">Velocity</div>
                            <div id="velocityLegendItems" class="heatmap-legend-items">
                                <!-- Dynamic Velocity Legend -->
                            </div>
                        </div>
                        <div class="heatmap-legend-section">
                            <div class="heatmap-legend-subtitle">Categories</div>
                            <div id="categoryLegendItems">
                                <!-- Will be populated dynamically -->
                            </div>
                        </div>
                        <!-- Driver Legend: Only shown in minimal view -->
                        <div class="heatmap-legend-section" id="driverLegendSection" style="display: none;">
                            <div class="heatmap-legend-subtitle">Drivers</div>
                            <div id="driverLegendItems" style="display: flex; flex-direction: column; gap: 3px;">
                                <!-- Will be populated dynamically -->
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- RIGHT: Heat Map Basket Panel (Hidden by default) -->
            <aside class="right-panel heatmap-basket" id="heatmapBasketPanel"
                style="display: none; height: calc(100vh - 130px); flex-direction: column; position: relative; padding-bottom: 160px; box-sizing: border-box;">
                <div class="basket-header">
                    <div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
                        <div>
                            <h3>Heat Map Controls</h3>
                            <p class="basket-count">Plotting: <span id="heatmapCount">0</span> drivers</p>
                        </div>
                        <button class="help-toggle-btn" onclick="toggleHeatMapHelp()" title="Help">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <circle cx="12" cy="12" r="10"></circle>
                                <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                                <line x1="12" y1="17" x2="12.01" y2="17"></line>
                            </svg>
                        </button>
                    </div>
                </div>
                <!-- Help Panel (Hidden by default) -->
                <div id="heatmapHelpPanel" class="heatmap-help-panel" style="display: none;">
                    <div class="heatmap-help-content">
                        <p><strong>ðŸ“ Positioning:</strong> AI has analyzed each driver's likelihood and materiality.
                        </p>
                        <p><strong>ðŸ”„ Adjust:</strong> Drag any driver card to change its position.</p>
                        <p><strong>ðŸ’¬ Interact:</strong> Click a driver to open its detail modal.</p>
                        <p><strong>â±ï¸ Velocity:</strong> Colored indicator shows risk timing.</p>
                    </div>
                </div>

                <!-- View Mode Selector -->
                <div class="heatmap-view-selector"
                    style="padding: 12px 16px; border-bottom: 1px solid var(--border-subtle);">
                    <label
                        style="font-size: 11px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; display: block; margin-bottom: 8px;">View
                        Mode</label>
                    <div class="view-mode-group">
                        <button onclick="setHeatMapViewMode('default')" id="viewModeDefault"
                            class="view-mode-btn active">
                            ðŸ“„ Default
                        </button>
                        <button onclick="setHeatMapViewMode('compact')" id="viewModeCompact" class="view-mode-btn">
                            ðŸ“‹ Compact
                        </button>
                        <button onclick="setHeatMapViewMode('minimal')" id="viewModeMinimal" class="view-mode-btn">
                            âš¡ Minimal
                        </button>
                    </div>

                    <!-- Driver List -->
                    <div class="basket-list" id="heatmapDriverList" style="flex: 1; overflow-y: auto; min-height: 0;">
                        <!-- Drivers will be populated here -->
                    </div>
                    <div class="basket-footer"
                        style="flex-direction: column; gap: 12px; padding: 16px; position: absolute; bottom: 0; left: 0; width: 100%; border-radius: 0 0 32px 32px;">
                        <div class="tools-row">
                            <button class="tool-btn" onclick="showMarketplace()">
                                <span>âœï¸</span>
                                <span class="tool-text">Edit<span class="tool-extra"> Risk Drivers</span></span>
                            </button>
                            <button class="tool-btn" onclick="saveHeatMap()">
                                <span>ðŸ’¾</span>
                                <span class="tool-text">Save<span class="tool-extra"> Heat Map</span></span>
                            </button>
                            <button class="tool-btn" onclick="openHeatmapExportModal()">
                                <span>ðŸ“¤</span>
                                <span class="tool-text">Export<span class="tool-extra"> Heat Map</span></span>
                            </button>
                        </div>
                        <button class="heatmap-btn heatmap-btn-primary" onclick="generateScenarioFromHeatMap()">
                            ðŸ“„ Generate Scenario Report
                        </button>
                    </div>
            </aside>


            <!-- RIGHT: Scenario Basket -->
            <aside class="right-panel" id="basketPanel" ondragover="handleDragOver(event)" ondrop="handleDrop(event)"
                ondragenter="handleDragEnter(event)" ondragleave="handleDragLeave(event)">
                <div class="basket-header">
                    <h3>Scenario Basket</h3>
                    <p class="basket-count">Selected: <span id="count">0</span> drivers</p>
                </div>
                <div class="basket-list" id="inventoryList">
                    <div id="emptyState" class="basket-empty">
                        <div class="basket-empty-icon">ðŸ›’</div>
                        <p>Your basket is empty.<br>Click drivers to add them.</p>
                    </div>
                </div>
                <div class="basket-footer">
                    <button id="generateHeatMapBtn" class="generate-heatmap-btn" disabled onclick="generateHeatMap()"
                        style="margin-bottom: 12px;">
                        ðŸ”¥ Generate Heat Map
                    </button>
                    <button id="generateBtn" class="generate-btn" disabled onclick="generateScenario()">
                        Generate Scenario Report
                    </button>
                </div>
            </aside>


        </div>
    </main>

    <!-- LOADER OVERLAY -->
    <div class="loader-overlay" id="loader">
        <div class="spinner"></div>
        <p class="loader-text" id="loaderText">Analyzing risk drivers...</p>
    </div>

    <!-- DRIVER DETAIL MODAL -->
    <div class="modal-overlay" id="driverModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Driver Details</h2>
                <button class="modal-close" onclick="closeModal()">Ã—</button>
            </div>
            <div class="modal-body">
                <span id="modalTag" class="modal-tag">Category</span>
                <p id="modalDesc" class="modal-desc">Description goes here...</p>

                <div class="chat-container">
                    <div class="chat-history" id="chatHistory">
                        <!-- Messages here -->
                    </div>
                    <div class="chat-input-area">
                        <input type="text" id="chatInput" class="chat-input"
                            placeholder="Ask AI to refine this driver..." onkeypress="handleChatEnter(event)">
                        <button class="chat-send" onclick="sendChatMessage()">âž¤</button>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-action-btn" id="deleteDriverBtn"
                    style="background: #EF4444; color: white; display: none;"
                    onclick="deleteCustomDriver(currentModalDriverId)">ðŸ—‘ï¸ Delete Driver</button>
                <button class="modal-action-btn" id="modalActionBtn" style="background: var(--primary); color: white;"
                    onclick="toggleDriverFromModal()">Add to Scenario</button>
            </div>
        </div>
    </div>

    <!-- REPORT OVERLAY -->
    <div class="report-overlay" id="reportOverlay">
        <div class="report-container">
            <div class="report-header">
                <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                    <div>
                        <div class="report-title" id="reportTitle">Scenario Analysis Report</div>
                        <div class="report-subtitle" id="reportSubtitle">Generated on December 6, 2025 | Based on 0 Risk
                            Drivers</div>
                    </div>
                    <div class="report-actions" style="display: flex; gap: 8px;">
                        <button class="btn-secondary" onclick="addMoreDriversToScenario()"
                            style="background: rgba(16, 185, 129, 0.9); color: white; border: none;">+ Add More
                            Drivers</button>
                        <button class="btn-secondary" onclick="closeReport()"
                            style="background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3);">Close</button>
                        <button class="btn-secondary" onclick="saveReport()"
                            style="background: white; color: var(--primary);">Save Scenario</button>
                        <button class="btn-secondary" onclick="exportScenarioPdf()" id="exportPdfBtn"
                            style="background: #2563EB; color: white; border: none;">ðŸ“„ Export PDF</button>
                        <button class="btn-secondary" onclick="sendToAstra()" id="sendToAstraBtn"
                            style="background: linear-gradient(135deg, #8B5CF6, #6366F1); color: white; border: none; font-weight: 600;">
                            ðŸš€ Analyze in Astra
                        </button>
                    </div>
                </div>
            </div>

            <div class="report-content-wrapper">
                <!-- Main Report Content -->
                <div class="report-main">
                    <div class="report-body">
                        <div class="report-section">
                            <div class="section-title">Selected Risk Drivers</div>
                            <div class="drivers-list" id="reportDriversList"></div>
                        </div>
                        <div class="report-section">
                            <div class="section-title">Global Economic Conditions</div>
                            <div class="section-content" id="globalConditions">Loading...</div>
                        </div>
                        <div class="report-section">
                            <div class="section-title">Canadian Economic Conditions</div>
                            <div class="section-content" id="canadianConditions">Loading...</div>
                        </div>
                        <div class="report-section">
                            <div class="section-title">Impact to RBC</div>
                            <div class="section-content" id="rbcImpact">Loading...</div>
                        </div>
                        <div class="report-section">
                            <div class="section-title">Core Macro Variable Projections</div>
                            <div class="macro-grid" id="macroProjections"></div>
                        </div>
                    </div>
                    <div class="report-footer">
                        <div class="report-disclaimer"></div>
                    </div>
                </div>

                <!-- AI Assistant Sidebar -->
                <div class="report-sidebar" id="reportSidebar">
                    <div class="report-chat-header">
                        <span id="reportSidebarTitle">âœ¨ Scenario Assistant</span>
                        <button class="sidebar-toggle-btn" onclick="toggleReportSidebar()" title="Toggle Sidebar">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="13 17 18 12 13 7"></polyline>
                                <polyline points="6 17 11 12 6 7"></polyline>
                            </svg>
                        </button>
                    </div>
                    <div class="report-chat-history" id="reportChatHistory">
                        <div class="chat-message ai">
                            This scenario has been generated based on the selected risk drivers. I can help you refine
                            it:

                            <br><br><strong>ðŸ“Š Macro Projections:</strong>
                            <ul style="margin: 8px 0; padding-left: 20px;">
                                <li>"Make the scenario more severe" - I'll adjust all variables proportionally</li>
                                <li>"Dial back the severity by 30%" - I'll moderate all projections</li>
                                <li>"Increase unemployment to 9%" - I'll update related variables to maintain economic
                                    consistency</li>
                            </ul>

                            <strong>âœï¸ Narrative Refinements:</strong>
                            <ul style="margin: 8px 0; padding-left: 20px;">
                                <li>"Make the global section more concise"</li>
                                <li>"Add more detail on housing market impacts"</li>
                                <li>"Adjust the tone to be more technical"</li>
                            </ul>

                            When I adjust macro projections, I'll explain the economic rationale for each variable
                            change.
                        </div>
                    </div>
                    <div class="report-chat-input-area">
                        <input type="text" id="reportChatInput" class="chat-input"
                            placeholder="Refine narrative or ask questions..."
                            onkeypress="handleReportChatEnter(event)">
                        <button class="chat-send" onclick="sendReportChatMessage()">âž¤</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    </div>

    <!-- HEATMAP EXPORT MODAL -->
    <div class="modal-overlay" id="heatmapExportModal" style="display: none;">
        <div class="modal-content" style="max-width: 400px; text-align: center; padding-bottom: 32px;">
            <div class="modal-header">
                <h2>ðŸ“¤ Export Heat Map</h2>
                <button class="modal-close" onclick="closeHeatmapExportModal()">Ã—</button>
            </div>
            <div class="modal-body" style="padding: 24px; display: flex; flex-direction: column; gap: 16px;">
                <p style="color: var(--text-secondary); margin-bottom: 8px;">Choose a format to download the Heat Map.
                </p>
                <button class="heatmap-btn" style="background: #2563EB; color: white; justify-content: center;"
                    onclick="exportHeatmap('jpg')">
                    ðŸ–¼ï¸ Export as JPG Image
                </button>
                <button class="heatmap-btn"
                    style="background: white; border: 1px solid #E2E8F0; color: #374151; justify-content: center;"
                    onclick="exportHeatmap('pdf')">
                    ðŸ“„ Export as PDF Document
                </button>
            </div>
        </div>
    </div>

    <!-- GENERATE DOSSIER MODAL -->
    <div class="modal-overlay" id="generateDossierModal" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2>ðŸ“… Generate Historical Dossier</h2>
                <button class="modal-close" onclick="closeGenerateDossierModal()">Ã—</button>
            </div>
            <div class="modal-body" style="padding: 24px;">
                <p style="margin-bottom: 16px; color: var(--text-muted);">
                    Generate a market intelligence dossier for a specific historical period.
                    Tavily will search for news and data as of the selected quarter.
                </p>

                <div style="display: flex; gap: 16px; margin-bottom: 20px;">
                    <div style="flex: 1;">
                        <label
                            style="display: block; font-size: 12px; font-weight: 600; margin-bottom: 6px;">Quarter</label>
                        <select id="dossierQuarter"
                            style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border); background: var(--bg); font-size: 14px;">
                            <option value="Q1">Q1 (Jan-Mar)</option>
                            <option value="Q2">Q2 (Apr-Jun)</option>
                            <option value="Q3">Q3 (Jul-Sep)</option>
                            <option value="Q4" selected>Q4 (Oct-Dec)</option>
                        </select>
                    </div>
                    <div style="flex: 1;">
                        <label
                            style="display: block; font-size: 12px; font-weight: 600; margin-bottom: 6px;">Year</label>
                        <select id="dossierYear"
                            style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border); background: var(--bg); font-size: 14px;">
                            <option value="2025" selected>2025</option>
                            <option value="2024">2024</option>
                            <option value="2023">2023</option>
                            <option value="2022">2022</option>
                            <option value="2021">2021</option>
                            <option value="2020">2020</option>
                        </select>
                    </div>
                </div>

                <div
                    style="background: #FEF3C7; border: 1px solid #F59E0B; border-radius: 8px; padding: 12px; margin-bottom: 20px;">
                    <p style="margin: 0; font-size: 12px; color: #92400E;">
                        âš ï¸ <strong>Note:</strong> Historical searches may have limited results for older dates.
                        Best results for periods within the last 2 years.
                    </p>
                </div>

                <div id="dossierGenerationStatus" style="display: none; text-align: center; padding: 20px;">
                    <div class="spinner" style="margin: 0 auto 12px;"></div>
                    <p id="dossierGenerationText" style="color: var(--text-muted);">Generating dossier...</p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-action-btn" style="background: var(--text-muted); color: white;"
                    onclick="closeGenerateDossierModal()">Cancel</button>
                <button class="modal-action-btn" id="generateDossierBtn" style="background: #059669; color: white;"
                    onclick="generateHistoricalDossier()">
                    ðŸ” Generate Dossier
                </button>
            </div>
        </div>
    </div>

    <!-- SETTINGS MODAL -->
    <div class="modal-overlay" id="settingsModal" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <span class="modal-title">âš™ï¸ Settings</span>
                <button class="modal-close" onclick="closeSettingsModal()">Ã—</button>
            </div>
            <div class="modal-body" style="padding: 24px;">
                <!-- Dossier Management Section -->
                <div style="margin-bottom: 24px;">
                    <h3
                        style="font-size: 14px; font-weight: 700; color: #111827; margin: 0 0 8px 0; text-transform: uppercase; letter-spacing: 0.5px;">
                        ðŸ“… Dossier Management</h3>
                    <p style="color: #6b7280; font-size: 13px; margin: 0 0 16px 0; line-height: 1.5;">
                        Generate, import, export, or refresh market dossiers.
                    </p>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button onclick="closeSettingsModal(); showGenerateDossierModal();"
                            style="padding: 10px 12px; background: linear-gradient(135deg, #3B82F6, #2563EB); color: white; border: none; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer;">
                            ðŸ“… New Dossier
                        </button>
                        <button onclick="closeSettingsModal(); forceRefreshDrivers();"
                            style="padding: 10px 12px; background: linear-gradient(135deg, #64748B, #475569); color: white; border: none; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer;">
                            ðŸ”„ Refresh Drivers
                        </button>
                        <button onclick="closeSettingsModal(); exportCurrentDossier();"
                            style="padding: 10px 12px; background: #f3f4f6; color: #374151; border: 1px solid #d1d5db; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer;">
                            ðŸ“¤ Export Dossier
                        </button>
                        <label
                            style="padding: 10px 12px; background: #f3f4f6; color: #374151; border: 1px solid #d1d5db; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer; text-align: center;">
                            ðŸ“¥ Import Dossier
                            <input type="file" accept=".json" onchange="closeSettingsModal(); importDossierFile(event);"
                                style="display: none;">
                        </label>
                    </div>
                    <button onclick="closeSettingsModal(); deleteSelectedDossier();"
                        style="width: 100%; margin-top: 8px; padding: 10px 12px; background: #FEE2E2; color: #991B1B; border: 1px solid #FECACA; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer;">
                        ðŸ—‘ï¸ Delete Current Dossier
                    </button>
                </div>

                <!-- Divider -->
                <div style="height: 1px; background: #e5e7eb; margin: 24px 0;"></div>

                <!-- Workspace Backup Section -->
                <div style="margin-bottom: 24px;">
                    <h3
                        style="font-size: 14px; font-weight: 700; color: #111827; margin: 0 0 8px 0; text-transform: uppercase; letter-spacing: 0.5px;">
                        ðŸ’¾ Workspace Backup</h3>
                    <p style="color: #6b7280; font-size: 13px; margin: 0 0 16px 0; line-height: 1.5;">
                        Export your entire ASTRA workspace to a single file. Includes all saved scenarios, market
                        dossier, risk drivers, and custom drivers.
                    </p>
                    <div style="display: flex; gap: 12px;">
                        <button onclick="exportWorkspace()"
                            style="flex: 1; padding: 12px 16px; background: linear-gradient(135deg, #10B981, #059669); color: white; border: none; border-radius: 10px; font-size: 13px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            ðŸ“¤ Export Workspace
                        </button>
                        <label
                            style="flex: 1; padding: 12px 16px; background: linear-gradient(135deg, #6366F1, #8B5CF6); color: white; border-radius: 10px; font-size: 13px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; text-align: center;">
                            ðŸ“¥ Import Workspace
                            <input type="file" accept=".json" onchange="importWorkspace(event)" style="display: none;">
                        </label>
                    </div>
                </div>

                <!-- Divider -->
                <div style="height: 1px; background: #e5e7eb; margin: 24px 0;"></div>

                <!-- Data Management Section -->
                <div>
                    <h3
                        style="font-size: 14px; font-weight: 700; color: #111827; margin: 0 0 8px 0; text-transform: uppercase; letter-spacing: 0.5px;">
                        ðŸ—‚ï¸ Data Management</h3>
                    <p style="color: #6b7280; font-size: 13px; margin: 0 0 16px 0; line-height: 1.5;">
                        Clear cached data to force a fresh market scan on next load.
                    </p>
                    <button onclick="clearAllCaches()"
                        style="width: 100%; padding: 12px 16px; background: linear-gradient(135deg, #EF4444, #DC2626); color: white; border: none; border-radius: 10px; font-size: 13px; font-weight: 600; cursor: pointer;">
                        ðŸ—‘ï¸ Clear All Cached Data
                    </button>
                </div>

                <!-- Divider -->
                <div style="height: 1px; background: #e5e7eb; margin: 24px 0;"></div>

                <!-- AI Configuration -->
                <div style="margin-bottom: 24px;">
                    <h3
                        style="font-size: 14px; font-weight: 700; color: #111827; margin: 0 0 8px 0; text-transform: uppercase; letter-spacing: 0.5px;">
                        ðŸ¤– AI Configuration
                    </h3>
                    <p style="color: #6b7280; font-size: 13px; margin: 0 0 16px 0; line-height: 1.5;">
                        View and inspect the prompt templates used by the AI.
                    </p>
                    <button onclick="closeSettingsModal(); openAiPromptsModal();"
                        style="width: 100%; padding: 12px 16px; background: linear-gradient(135deg, #8B5CF6, #6D28D9); color: white; border: none; border-radius: 10px; font-size: 13px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                        ðŸ‘ï¸ View AI Prompts
                    </button>
                </div>

                <!-- Divider -->
                <div style="height: 1px; background: #e5e7eb; margin: 24px 0;"></div>

                <!-- About Section -->
                <div style="text-align: center; color: #9ca3af; font-size: 11px;">
                    <p style="margin: 0;">ASTRA Scenario Platform v1.0</p>
                    <p style="margin: 4px 0 0 0;">CEST Analytics</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- 0. CONFIGURATION ---
        // API keys no longer needed in frontend - handled by Flask backend
        const AZURE_OPENAI_API_URL = '/api/chat';  // Azure OpenAI via RBC GenAI Gateway
        const CACHE_KEY = 'astra_market_dossier';
        const DRIVERS_CACHE_KEY = 'astra_risk_drivers';
        const CUSTOM_DRIVERS_KEY = 'astra_custom_drivers';
        const SAVED_SCENARIOS_KEY = 'astra_saved_scenarios';
        const DOSSIERS_LIST_KEY = 'astra_dossiers_list';
        const CACHE_EXPIRY_DAYS = 7;

        // Current active dossier tracking
        let currentDossierId = 'current';
        let dossiersList = [];

        // Category color mapping
        const CATEGORY_COLORS = {
            'Macroeconomic': { tagColor: '#DBEAFE', textColor: '#1E40AF' },
            'Geopolitical': { tagColor: '#FEE2E2', textColor: '#991B1B' },
            'Cyber / Tech': { tagColor: '#E0E7FF', textColor: '#4338CA' },
            'Financial': { tagColor: '#D1FAE5', textColor: '#065F46' },
            'Environmental': { tagColor: '#FEF3C7', textColor: '#92400E' },
            'Social': { tagColor: '#F3E8FF', textColor: '#6B21A8' },
            'Regulatory': { tagColor: '#E5E7EB', textColor: '#374151' },
            'US Policy': { tagColor: '#FEE2E2', textColor: '#991B1B' },
            'AI & Cyber': { tagColor: '#E0E7FF', textColor: '#4338CA' },
            'Trade & Geopolitics': { tagColor: '#FEE2E2', textColor: '#991B1B' },
            'Climate': { tagColor: '#FEF3C7', textColor: '#92400E' },
            'Digital Assets': { tagColor: '#E0E7FF', textColor: '#4338CA' },
            'Banking': { tagColor: '#D1FAE5', textColor: '#065F46' },
            'Demographics': { tagColor: '#F3E8FF', textColor: '#6B21A8' },
            'Customized': { tagColor: '#CFFAFE', textColor: '#0E7490' }  // Teal/Cyan - unique color
        };

        // Dynamic date context calculation - same as Python script
        function getDynamicContext(targetYear = null, targetQuarter = null) {
            const now = new Date();
            let curYear, curQuarter;

            if (targetYear && targetQuarter) {
                // Use provided historical date context
                curYear = parseInt(targetYear);
                const quarterNum = parseInt(targetQuarter.replace('Q', ''));
                curQuarter = quarterNum;
            } else {
                // Calculate current date context
                curYear = now.getFullYear();
                curQuarter = Math.ceil((now.getMonth() + 1) / 3);
            }

            const nextYear = curYear + 1;
            const curQ = `Q${curQuarter}`;

            // Previous Quarter (for earnings)
            let prevQ, prevQYear;
            if (curQuarter === 1) {
                prevQ = 'Q4';
                prevQYear = curYear - 1;
            } else {
                prevQ = `Q${curQuarter - 1}`;
                prevQYear = curYear;
            }

            return {
                CY: curYear,
                NY: nextYear,
                CQ: curQ,
                PQ: prevQ,
                PQY: prevQYear
            };
        }

        // Tavily search queries - CURRENT period (event-specific for 2024-2025)
        function getCurrentPeriodQueries(t) {
            return {
                "1_US_POLICY_RISK": [
                    `White House press briefings US Canada trade relations ${t.CY}`,
                    `US Treasury debt ceiling risk and fiscal dysfunction ${t.CY}`,
                    `CBO Budget and Economic Outlook ${t.CY} ${t.NY} projections`,
                    `USTR announcements CUSMA USMCA trade dispute settlement ${t.CY}`,
                    `Federal Reserve FOMC minutes political gridlock risks ${t.CY}`,
                    `US Treasury yield curve inversion and repo market stress ${t.CY}`
                ],
                "2_MACRO_ECONOMY": [
                    `Statistics Canada CPI inflation and stagflation signs ${t.CQ} ${t.CY}`,
                    `Bank of Canada Financial System Review household debt ${t.CY}`,
                    `IMF World Economic Outlook Canada GDP growth forecast ${t.CY} ${t.NY}`,
                    `Bloomberg Commodity Index forecast oil and wheat prices ${t.NY}`,
                    `Sovereign CDS spreads Canada vs US ${t.CY} trends`
                ],
                "3_AI_AND_CYBER": [
                    `NIST AI Risk Management Framework financial sector adoption ${t.CY}`,
                    `CISA cybersecurity alerts financial sector ransomware ${t.CY}`,
                    `Chainalysis crypto crime report ransomware revenue ${t.CY}`,
                    `OECD employment outlook AI labor displacement Canada ${t.CY}`
                ],
                "4_GEOPOLITICS_TRADE": [
                    `CSIS report foreign interference Canadian economy ${t.CY}`,
                    `Foreign Policy magazine US isolationism impact on Canada ${t.CY}`,
                    `Freightos Baltic Index global shipping rates Red Sea ${t.CY}`,
                    `US Department of Commerce semiconductor trade restrictions ${t.CY}`
                ],
                "5_CLIMATE_PHYSICAL": [
                    `Environment Canada seasonal weather hazard outlook wildfire ${t.NY}`,
                    `OSFI climate risk management guidelines B-15 updates ${t.CY}`,
                    `Swiss Re Sigma report natural catastrophe losses Canada ${t.CY}`
                ],
                "6_DIGITAL_ASSETS": [
                    `OSFI crypto asset exposure guidelines for banks ${t.CY}`,
                    `Circle stablecoin peg stability report ${t.CY}`,
                    `Rekt.news DeFi exploits summary ${t.CY}`
                ],
                "7_REGULATORY_ENVIRONMENT": [
                    `OSFI Annual Risk Outlook ${t.CY} priorities`,
                    `FINTRAC anti-money laundering real estate updates ${t.CY}`,
                    `CFPB consumer protection rules impact on Canadian banks ${t.CY}`
                ],
                "8_SOCIETAL_DEMOGRAPHICS": [
                    `Angus Reid Institute poll Canadian political polarization ${t.CY}`,
                    `Statistics Canada immigration targets vs housing supply ${t.CY}`,
                    `Pew Research Center US political stability forecast ${t.CY}`
                ],
                "9_BANKING_SIGNALS": [
                    `RBC ${t.PQ} ${t.PQY} earnings call transcript analyst questions`,
                    `TD Bank BMO provision for credit losses ${t.PQ} ${t.PQY} trends`,
                    `Teranet-National Bank House Price Index composite ${t.CY}`,
                    `VIX and MOVE index volatility correlation ${t.CY}`
                ]
            };
        }

        // Tavily search queries - HISTORICAL period (generic/evergreen queries)
        function getHistoricalPeriodQueries(t) {
            // More generic queries that work for any time period
            // Focus on fundamental economic indicators and recurring risk themes
            return {
                "1_MACRO_INDICATORS": [
                    `Canada GDP growth rate ${t.CQ} ${t.CY} Statistics Canada`,
                    `Bank of Canada interest rate decision ${t.CQ} ${t.CY}`,
                    `Canada unemployment rate ${t.CQ} ${t.CY} labor market`,
                    `Canadian inflation CPI ${t.CQ} ${t.CY}`,
                    `Canada housing market prices ${t.CQ} ${t.CY}`
                ],
                "2_CENTRAL_BANK_POLICY": [
                    `Bank of Canada monetary policy report ${t.CQ} ${t.CY}`,
                    `Federal Reserve interest rate decision ${t.CQ} ${t.CY}`,
                    `Bank of Canada Financial System Review ${t.CY}`,
                    `Canada yield curve ${t.CQ} ${t.CY} bond market`
                ],
                "3_FINANCIAL_MARKETS": [
                    `TSX stock market performance ${t.CQ} ${t.CY}`,
                    `Canadian dollar exchange rate ${t.CQ} ${t.CY}`,
                    `Canada credit spreads corporate bonds ${t.CQ} ${t.CY}`,
                    `VIX volatility index ${t.CQ} ${t.CY}`
                ],
                "4_GEOPOLITICS_TRADE": [
                    `Canada US trade relations ${t.CQ} ${t.CY}`,
                    `global supply chain disruption ${t.CQ} ${t.CY}`,
                    `oil prices impact Canada ${t.CQ} ${t.CY}`,
                    `commodity prices Canada exports ${t.CQ} ${t.CY}`
                ],
                "5_REGULATORY_BANKING": [
                    `OSFI regulatory updates Canada ${t.CQ} ${t.CY}`,
                    `Canadian bank earnings results ${t.CQ} ${t.CY}`,
                    `RBC TD BMO credit loss provisions ${t.CQ} ${t.CY}`,
                    `Canada mortgage market stress ${t.CQ} ${t.CY}`
                ],
                "6_RISK_EVENTS": [
                    `Canada financial risk concerns ${t.CQ} ${t.CY}`,
                    `Canadian economy recession risk ${t.CQ} ${t.CY}`,
                    `Canada household debt ${t.CQ} ${t.CY}`,
                    `Canadian real estate market risk ${t.CQ} ${t.CY}`
                ],
                "7_CLIMATE_DISASTERS": [
                    `Canada natural disaster ${t.CY} wildfire flood`,
                    `Canadian insurance claims catastrophe ${t.CY}`,
                    `climate risk Canada financial sector ${t.CY}`
                ],
                "8_TECHNOLOGY_CYBER": [
                    `cybersecurity threats financial sector ${t.CQ} ${t.CY}`,
                    `data breach Canada ${t.CQ} ${t.CY}`,
                    `fintech disruption Canada banking ${t.CY}`
                ],
                "9_SOCIETAL_POLITICAL": [
                    `Canada political landscape ${t.CQ} ${t.CY}`,
                    `Canadian consumer confidence ${t.CQ} ${t.CY}`,
                    `Canada immigration policy ${t.CY} economic impact`
                ]
            };
        }

        // Choose appropriate query set based on year
        function getTavilyQueries(t, isHistorical = false) {
            // Use current period queries (event-specific) only for 2025 and after
            // Use historical/generic queries for 2024 and earlier
            if (isHistorical || t.CY < 2025) {
                return getHistoricalPeriodQueries(t);
            }
            return getCurrentPeriodQueries(t);
        }

        // For backwards compatibility, maintain a default TAVILY_QUERIES object
        const TAVILY_QUERIES = getTavilyQueries(getDynamicContext(), false);

        // --- 1. INITIAL RISK DATA (will be populated by AI) ---
        let INITIAL_DRIVERS = [];
        let selectedDrivers = [];
        let savedScenarios = [];
        let currentScenarioId = null;
        let isInitializing = false;

        // --- 2. CACHE UTILITIES ---
        function isCacheValid(cacheData) {
            if (!cacheData || !cacheData.timestamp) return false;
            const cacheDate = new Date(cacheData.timestamp);
            const now = new Date();
            const diffDays = (now - cacheDate) / (1000 * 60 * 60 * 24);
            return diffDays < CACHE_EXPIRY_DAYS;
        }

        // --- BASELINE MACRO DATA FETCHING ---
        async function fetchBaselineMacroData(periodInfo) {
            if (!periodInfo || !periodInfo.quarter || !periodInfo.year) {
                console.log('âš ï¸ No period info provided for macro data');
                return null;
            }

            try {
                const response = await fetch('/stress_test_data/macro_jumpoff.csv');
                if (!response.ok) {
                    console.error('Failed to load macro_jumpoff.csv from /stress_test_data/');
                    return null;
                }

                const csvText = await response.text();
                const lines = csvText.trim().split('\n');
                const headers = lines[0].split(',');

                // Find the column for the requested quarter/year
                const targetColumn = `${periodInfo.year}/Q${periodInfo.quarter.replace('Q', '')}`;
                let columnIndex = headers.indexOf(targetColumn);
                let usedLatest = false;

                if (columnIndex === -1) {
                    // Quarter not found - use the latest available quarter
                    console.log(`âš ï¸ ${targetColumn} not found in CSV, using latest available data`);
                    columnIndex = headers.length - 1;
                    usedLatest = true;
                }

                // Variable mapping
                const variableMap = {
                    'GDP_CA': 'Canada GDP',
                    'UR_CA': 'Unemployment Rate',
                    'INF_CA': 'CPI Inflation',
                    'USDCAD': 'CAD/USD',
                    'OR_CA': 'BoC Rate',
                    'HPI_CA': 'House Price Index',
                    'TSX_CA': 'TSX Composite',
                    '10YS_BBB_CA': 'Credit Spreads'
                };

                // Variables that need QoQ growth calculation
                const qoqVariables = new Set(['GDP_CA', 'HPI_CA', 'TSX_CA']);

                // Variables that are percentages (show 1 decimal)
                const percentageVariables = new Set(['UR_CA', 'INF_CA', 'OR_CA', '10YS_BBB_CA']);

                const macroValues = {};
                const rawValues = {}; // Store raw values for QoQ calculation

                for (let i = 1; i < lines.length; i++) {
                    const cols = lines[i].split(',');
                    const mnemonic = cols[0];
                    if (variableMap[mnemonic]) {
                        const currentValue = parseFloat(cols[columnIndex]);
                        const prevValue = columnIndex > 1 ? parseFloat(cols[columnIndex - 1]) : null;

                        rawValues[mnemonic] = { current: currentValue, prev: prevValue };

                        let displayValue;
                        if (isNaN(currentValue)) {
                            displayValue = 'N/A';
                        } else if (qoqVariables.has(mnemonic) && prevValue && !isNaN(prevValue)) {
                            // Calculate QoQ growth
                            const qoqGrowth = ((currentValue - prevValue) / prevValue) * 100;
                            displayValue = `${currentValue.toFixed(1)} (QoQ: ${qoqGrowth >= 0 ? '+' : ''}${qoqGrowth.toFixed(1)}%)`;
                        } else if (percentageVariables.has(mnemonic)) {
                            // Format as percentage with 1 decimal
                            displayValue = `${currentValue.toFixed(1)}%`;
                        } else {
                            // Regular number with 1 decimal
                            displayValue = currentValue.toFixed(1);
                        }

                        macroValues[variableMap[mnemonic]] = displayValue;
                    }
                }

                // Build summary text
                const summary = Object.entries(macroValues)
                    .map(([key, val]) => `${key}: ${val}`)
                    .join('\n');

                return {
                    summary,
                    usedLatest,
                    actualQuarter: usedLatest ? headers[columnIndex] : targetColumn,
                    values: macroValues
                };

            } catch (error) {
                console.error('Error loading macro data:', error);
                return null;
            }
        }

        function getFromCache(key) {
            try {
                const data = localStorage.getItem(key);
                if (!data) return null;
                const parsed = JSON.parse(data);
                if (isCacheValid(parsed)) {
                    console.log(`âœ“ Using cached ${key} (${Math.round((new Date() - new Date(parsed.timestamp)) / (1000 * 60 * 60 * 24))} days old)`);
                    return parsed.data;
                } else {
                    console.log(`âœ— Cache expired for ${key}`);
                    localStorage.removeItem(key);
                    return null;
                }
            } catch (e) {
                console.error('Cache read error:', e);
                return null;
            }
        }

        function saveToCache(key, data) {
            try {
                const cacheEntry = {
                    timestamp: new Date().toISOString(),
                    data: data
                };
                localStorage.setItem(key, JSON.stringify(cacheEntry));
                console.log(`âœ“ Saved to cache: ${key}`);
            } catch (e) {
                console.error('Cache save error:', e);
            }
        }

        // --- 3. TAVILY API INTEGRATION ---
        async function fetchTavilySearch(query, retries = 3, retryDelay = 1000) {
            // Define trusted domains for risk intelligence
            const RISK_INTELLIGENCE_DOMAINS = [
                // --- 1. GLOBAL FINANCIAL MAJORS ---
                'bloomberg.com', 'reuters.com', 'ft.com', 'wsj.com', 'cnbc.com',
                'economist.com', 'forbes.com', 'marketwatch.com', 'barrons.com',

                // --- 2. CANADIAN CORE ---
                'bankofcanada.ca', 'statcan.gc.ca', 'osfi-bsif.gc.ca', 'canada.ca',
                'theglobeandmail.com', 'financialpost.com', 'bnnbloomberg.ca', 'cbc.ca',
                'globalnews.ca', 'advisor.ca', 'investmentexecutive.com',
                'cmhc-schl.gc.ca', 'crea.ca', 'angusreid.org', 'nanos.co',
                'ibc.ca', 'publicsafety.gc.ca',

                // --- 3. SPECIALIZED RISK INTELLIGENCE ---
                'risk.net', 'rmahq.org', 'aba.com', 'garp.org', 'bis.org', 'imf.org',
                'wired.com', 'techcrunch.com', 'csoonline.com', 'darkreading.com',
                'thehackernews.com', 'cisa.gov', 'nist.gov',
                'foreignpolicy.com', 'foreignaffairs.com', 'eurasiagroup.net', 'csis.org',
                'caixinglobal.com', 'nikkei.com', 'aljazeera.com',
                'oilprice.com', 'iea.org',
                'whitehouse.gov', 'state.gov', 'ustr.gov', 'commerce.gov', 'senate.gov',
                'environmental-finance.com', 'wri.org', 'ipcc.ch',

                // --- 4. INSTITUTIONAL THINK TANKS ---
                'brookings.edu', 'piie.com', 'cdhowe.org', 'fraserinstitute.org', 'conferenceboard.ca'
            ];

            for (let attempt = 1; attempt <= retries; attempt++) {
                try {
                    console.log(`ðŸ” Tavily search (attempt ${attempt}/${retries}): "${query}"`);
                    // Use local Flask proxy endpoint instead of direct Tavily API
                    const response = await fetch('/api/tavily/search', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            query: query,
                            search_depth: 'advanced',
                            topic: 'news',
                            max_results: 10,
                            include_answer: true,
                            include_raw_content: true,
                            include_text: true,
                            include_domains: RISK_INTELLIGENCE_DOMAINS
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error(`Tavily API HTTP ${response.status}:`, errorText);

                        // If 503 or 429, retry with exponential backoff
                        if ((response.status === 503 || response.status === 429) && attempt < retries) {
                            const waitTime = retryDelay * Math.pow(2, attempt - 1);
                            console.log(`â³ Retrying in ${waitTime}ms...`);
                            await new Promise(r => setTimeout(r, waitTime));
                            continue;
                        }

                        throw new Error(`Tavily API error: ${response.status} - ${errorText}`);
                    }

                    const data = await response.json();
                    console.log(`âœ“ Tavily returned ${data.results?.length || 0} results from ${RISK_INTELLIGENCE_DOMAINS.length} trusted domains`);
                    return data.results || [];
                } catch (error) {
                    console.error(`âŒ Tavily search failed for "${query}" (attempt ${attempt}/${retries}):`, error);

                    // If last attempt, return empty array instead of throwing
                    if (attempt === retries) {
                        console.warn(`âš ï¸ Skipping query "${query}" after ${retries} attempts`);
                        return []; // Return empty results instead of failing
                    }

                    // Wait before retrying
                    const waitTime = retryDelay * Math.pow(2, attempt - 1);
                    await new Promise(r => setTimeout(r, waitTime));
                }
            }
            return []; // Fallback
        }


        const SHARED_DOSSIER_PATH = './stress_test_data/dossier_current.json';

        async function fetchMarketDossier(progressCallback) {
            // 1. Try to fetch from the SHARED SERVER FILE first
            try {
                const response = await fetch(SHARED_DOSSIER_PATH);
                if (response.ok) {
                    const fileData = await response.json();
                    if (isCacheValid(fileData)) {
                        console.log(`âœ“ Using SHARED SERVER dossier from ${SHARED_DOSSIER_PATH}`);
                        progressCallback && progressCallback('Using shared server market intelligence...');
                        // Update local cache to match server text
                        saveToCache(CACHE_KEY, fileData.data);
                        return fileData.data;
                    } else {
                        console.log('Shared server dossier is expired.');
                    }
                }
            } catch (e) {
                // Ignore if file doesn't exist
                console.log('No shared dossier found on server.');
            }

            // 2. Check LOCAL CACHE
            const cachedDossier = getFromCache(CACHE_KEY);
            if (cachedDossier) {
                progressCallback && progressCallback('Using cached market intelligence...');
                return cachedDossier;
            }

            // 3. Fallback: RETURN NULL (Do not auto-generate)
            console.log('No cached or shared dossier found. Waiting for user action.');
            return null;
        }

        async function generateNewMarketDossier(progressCallback) {
            progressCallback && progressCallback('Scanning market intelligence via Tavily API...');
            const dossier = {};
            const categories = Object.keys(TAVILY_QUERIES);
            let completed = 0;

            for (const category of categories) {
                const queries = TAVILY_QUERIES[category];
                dossier[category] = [];

                for (const query of queries) {
                    completed++;
                    progressCallback && progressCallback(
                        `Scanning: ${category.replace(/_/g, ' ')} (${completed}/${Object.values(TAVILY_QUERIES).flat().length})`
                    );

                    const results = await fetchTavilySearch(query);
                    for (const result of results) {
                        const fullText = result.raw_content || result.content || '';
                        dossier[category].push({
                            query: query,
                            title: result.title,
                            url: result.url,
                            content: fullText.substring(0, 20000),
                            date: result.published_date || 'Unknown'
                        });
                    }

                    // Rate limiting - 500ms between requests
                    await new Promise(r => setTimeout(r, 500));
                }
            }

            // Save to cache
            saveToCache(CACHE_KEY, dossier);

            // PROMPT ADMIN TO SAVE TO SERVER
            setTimeout(() => {
                downloadDossierForServer(dossier);
            }, 1000);

            return dossier;
        }

        function downloadDossierForServer(dossier) {
            const cacheEntry = {
                timestamp: new Date().toISOString(),
                data: dossier
            };
            const blob = new Blob([JSON.stringify(cacheEntry, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'dossier_current.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            alert("New Market Dossier Generated!\n\nA 'dossier_current.json' file has been downloaded.\nPlease move this file to the 'stress_test_data' folder on the server to share it with other users.");
        }

        // --- 4. AI DRIVER GENERATION ---

        // Deduplication helper: Calculate text similarity between two strings
        function calculateSimilarity(str1, str2) {
            // Normalize strings: lowercase, remove punctuation, split into words
            const normalize = (s) => s.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/).filter(w => w.length > 2);

            const words1 = new Set(normalize(str1));
            const words2 = new Set(normalize(str2));

            if (words1.size === 0 || words2.size === 0) return 0;

            // Jaccard similarity: intersection / union
            const intersection = [...words1].filter(w => words2.has(w)).length;
            const union = new Set([...words1, ...words2]).size;

            return intersection / union;
        }

        // Remove duplicate or highly similar drivers
        function deduplicateDrivers(drivers) {
            const uniqueDrivers = [];
            const removedDrivers = [];
            const SIMILARITY_THRESHOLD = 0.5; // 50% similar words = likely duplicate

            for (const driver of drivers) {
                let isDuplicate = false;
                let duplicateOf = null;

                for (const existing of uniqueDrivers) {
                    // Check title similarity
                    const titleSimilarity = calculateSimilarity(driver.title, existing.title);

                    // Check description similarity (weighted less)
                    const descSimilarity = calculateSimilarity(driver.desc || '', existing.desc || '');

                    // Combined similarity score (title is more important)
                    const combinedSimilarity = (titleSimilarity * 0.7) + (descSimilarity * 0.3);

                    if (combinedSimilarity >= SIMILARITY_THRESHOLD) {
                        isDuplicate = true;
                        duplicateOf = existing.title;
                        break;
                    }
                }

                if (isDuplicate) {
                    removedDrivers.push({ title: driver.title, duplicateOf });
                } else {
                    uniqueDrivers.push(driver);
                }
            }

            // Log removed duplicates for debugging
            if (removedDrivers.length > 0) {
                console.log(`ðŸ”„ Deduplication removed ${removedDrivers.length} duplicate drivers:`);
                removedDrivers.forEach(r => {
                    console.log(`   - "${r.title}" (duplicate of "${r.duplicateOf}")`);
                });
            }

            return uniqueDrivers;
        }

        const PROMPT_TEMPLATES = {
            RISK_DRIVERS: `You are an expert financial risk analyst. Based on the following EXTENSIVE market intelligence dossier from {{PERIOD_QUARTER}} {{PERIOD_YEAR}}, generate exactly 55 unique risk drivers that could impact Royal Bank of Canada (RBC) and the Canadian financial system. (We request 55 to allow for deduplication to reach exactly 50.)

{{PERIOD_CONTEXT}}

BASELINE MACROECONOMIC DATA ({{MACRO_PERIOD}}):
{{MACRO_SUMMARY}}

MARKET INTELLIGENCE DOSSIER:
{{DOSSIER_SUMMARY}}

Generate 55 risk drivers distributed across these categories:
- Macroeconomic (inflation, rates, growth): 11 drivers
- Geopolitical (wars, conflicts): 12 drivers
- Cyber / Tech (AI, cybersecurity, digital disruption): 7 drivers
- Financial (credit, liquidity, market stress): 9 drivers
- Environmental (climate, natural disasters): 6 drivers
- Regulatory (policy changes, compliance): 5 drivers
- Social (demographics, political stability): 5 drivers

CRITICAL: AVOID DUPLICATION
- Each driver MUST be UNIQUE - do not repeat the same risk topic with different wording
- Before generating each driver, check if a similar risk has already been covered
- Different aspects of the same event should be consolidated into ONE comprehensive driver, not split into multiple

For each driver, provide:
1. A concise title (4-8 words) using specific terminology from the search results.
2. A detailed description (50~100 words) explicitly determining the risk. CITE SPECIFIC DATA, percentages, or entities mentioned in the dossier. Explain HOW and WHY this risk could impact RBC and the Canadian financial system.
3. A sources array (up to 3 articles) that support this driver. Include the article title and URL from the dossier.

CRITICAL REQUIREMENTS - NEGATIVE RISKS ONLY:
**ONLY include ADVERSE/NEGATIVE risk drivers.** Do NOT include positive developments (e.g., "easing inflation", "strong earnings", "improved credit quality") disguised as risks.

CRITICAL ANTI-HALLUCINATION RULES:
1. **ZERO FABRICATION**: DO NOT invent country names, company names, legislation names, people's names or events. ONLY use entities explicitly mentioned in the dossier articles.
2. **VERIFY EVERY ENTITY**: Before including any proper noun (country, company, law, person), confirm it appears verbatim in the dossier text.
3. **NO WORD CREATION**: Do not create new words or terms. Use only real English words and proper nouns from the dossier.
4. **REAL GEOGRAPHY ONLY**: Use only actual country names that exist.
5. **SOURCE VALIDATION**: Every fact, number, and entity MUST have a corresponding source article.
6. **DEEP GROUNDING**: Every driver MUST quote or paraphrase actual content from the dossier articles.
7. **SPECIFICITY**: Include specific numbers, dates, company names, or legislation names.
8. **TIMING**: Ensure risks are appropriate for {{PERIOD_QUARTER}} {{PERIOD_YEAR}}.
9. **NO SPECULATION**: If the dossier lacks information on a topic, skip that category.

Format your response as a JSON array:
[
  {
    "id": "d1",
    "cat": "Macroeconomic",
    "title": "US-Canada Tariff Escalation",
    "desc": "Ongoing trade disputes regarding softwood lumber and dairy intensified in Q4, with new 15% tariffs proposed...",
    "sources": [
      {"title": "Reuters: US announces new tariffs on Canadian lumber", "url": "https://reuters.com/..."},
      {"title": "Globe and Mail: Trade tensions escalate", "url": "https://theglobeandmail.com/..."}
    ]
  }
]

Generate exactly 55 risk drivers. Return ONLY the JSON array, no additional text.`,

            RISK_DRIVERS_ADDITIONAL: `You are an expert financial risk analyst. Generate 5 NEW and UNIQUE {{CATEGORY}} risk drivers for Royal Bank of Canada (RBC) based on the market intelligence dossier.

CRITICAL: AVOID DUPLICATES
The following {{CATEGORY}} risk drivers ALREADY EXIST - do NOT repeat or create similar versions:
{{EXISTING_TITLES}}

Brief descriptions of existing drivers:
{{EXISTING_DESCRIPTIONS}}

MARKET INTELLIGENCE DOSSIER:
{{DOSSIER_SUMMARY}}

Generate 5 NEW {{CATEGORY}} risk drivers that are:
1. COMPLETELY DIFFERENT from the existing ones listed above
2. Grounded in the dossier content with specific data/entities
3. Relevant negative risks for RBC and the Canadian financial system

For each driver, provide:
1. A concise title (4-8 words)
2. A detailed description (50~100 words) with specific data from sources
3. Sources array (up to 2 articles) with title and URL

ANTI-HALLUCINATION: Only use entities, numbers, and facts from the dossier. Do not invent.

Return a JSON array:
[
  {
    "id": "new_{{CATEGORY_SNAKE}}_1",
    "cat": "{{CATEGORY}}",
    "title": "Unique Risk Title",
    "desc": "Detailed description...",
    "sources": [{"title": "Article Title", "url": "https://..."}]
  }
]

Return ONLY the JSON array with exactly 5 drivers.`,

            HEATMAP_ASSESSMENT: `You are an expert risk analyst. For each of the following risk drivers, assess:
1. LIKELIHOOD (1-10): How likely is this risk to materialize with adverse outcomes for RBC? (1=very unlikely, 10=very likely)
2. MATERIALITY (1-10): What is the potential impact on RBC if this risk materializes? (1=minimal impact, 10=severe impact)
3. VELOCITY (1-3): the time elapsed between the materialization of a risk event and the point of RBC's impact (1=more than 3 months, 2=2 weeks to 3 months, 3=less than 2 weeks)

RISK DRIVERS TO ASSESS:
{{DRIVERS_LIST}}

Return a JSON array with assessments for each driver:
[
  {
    "id": "driver_id",
    "likelihood": 7,
    "materiality": 8,
    "velocity": 2,
    "likelihoodReasoning": "1-2 sentence justification for the likelihood score, explaining why this risk is likely/unlikely to materialize.",
    "materialityReasoning": "1-2 sentence justification for the materiality score, explaining the potential impact severity if the risk materializes.",
    "reasoning": "Brief summary (1-2 sentences) covering velocity and overall assessment for RBC."
  },
  ...
]

Be specific and realistic. Consider current market conditions and the severity described in each driver.
Provide clear, concise reasoning that explains the rationale behind EACH assessment dimension.
Return ONLY the JSON array.`,

            SCENARIO_GENERATION: `You are a Senior Chief Risk Officer for Royal Bank of Canada (RBC). Your task is to construct a concise, high-impact stress scenario narrative based on the specific risk drivers provided below.

CONTEXT:
{{BASELINE_CONTEXT}}

RISK DRIVERS TO MATERIALIZE:
{{DRIVERS_SUMMARY}}

SCENARIO STRUCTURE GUIDANCE:
- Overall Scenario Severity: {{SEVERITY}}
- Highest Priority Risks: {{HIGH_RISKS}}
- Immediate/Fast-Moving Threats: {{IMMEDIATE_THREATS}}
- Near-Term Threats: {{NEAR_TERM_THREATS}}

Generate a cohesive scenario narrative that combines these drivers into a plausible stress scenario. Your response must be a valid JSON object with the following structure:

{
  "scenarioTitle": "A compelling 3-6 word title for the scenario (e.g., 'Perfect Storm 2026' or 'Global Trade Collapse')",
  "globalConditions": {
    "summary": "2-3 paragraphs (HTML formatted with <p> tags and <strong> for emphasis) describing global economic and geopolitical conditions. Use severity guidance to calibrate tone. Do NOT mention likelihood/materiality scores.",
    "keyPoints": ["Point 1", "Point 2", "Point 3"]
  },
  "canadianConditions": {
    "summary": "2-3 paragraphs (HTML formatted) describing how these conditions impact the Canadian economy, housing market, and Bank of Canada policy.",
    "keyPoints": ["Point 1", "Point 2", "Point 3"]
  },
  "rbcImpact": {
    "summary": "2-3 paragraphs (HTML formatted) describing the direct impact on RBC's business lines including: Personal & Commercial Banking, Capital Markets, Wealth Management, and overall capital/liquidity position.",
    "keyPoints": ["Point 1", "Point 2", "Point 3"]
  },
  "macroProjections": {
    "canadaGDP": { "value": "-X.X%" },
    "unemployment": { "value": "X.X%" },
    "inflation": { "value": "X.X%" },
    "usdCad": { "value": "1.XX" },
    "bocRate": { "value": "X.X%" },
    "housePrice": { "value": "-XX%" },
    "tsx": { "value": "-XX%" },
    "creditSpreads": { "value": "XXX" }
  }
}

CRITICAL INSTRUCTIONS:
1. DO NOT mention "likelihood", "materiality", "velocity", or numerical scores (e.g., "7/10") in narrative text
2. Let severity guidance naturally inform how severe/urgent the narrative sounds
3. Use priority ordering to determine which risks to emphasize first
4. Use immediacy cues (immediate = "unfolding rapidly", near-term = "emerging", longer-term = "developing")
5. Connect risks into coherent narrative rather than listing them
6. Make scenario severity match guidance (SEVERE = deep recession -4% to -6% GDP, MODERATE = recession -2.5% to -4% GDP, MILD = slowdown -1% to -2% GDP)
7. Provide ONLY stress projection values. System will calculate deltas from baseline automatically.
8. Format summaries with proper HTML <p> tags and <strong> for emphasis

IMPORTANT: Only provide the STRESS/PROJECTION values. Do NOT include delta or direction fields. The system will automatically calculate deltas from baseline.

CRITICAL: For usdCad, use format "1.XX" representing CAD per 1 USD (e.g., 1.45 means 1 USD = 1.45 CAD). Higher values = weaker CAD.

Return ONLY the JSON object, no additional text.`
        };

        function fillPrompt(template, subs) {
            let result = template;
            for (const [key, val] of Object.entries(subs)) {
                result = result.split(`{{${key}}}`).join(val);
            }
            return result;
        }

        async function generateRiskDriversFromDossier(dossier, progressCallback, dossierId = 'current', periodInfo = null) {
            // Use dossier-specific cache key
            const dossierCacheKey = `${DRIVERS_CACHE_KEY}_${dossierId}`;

            // Check for cached drivers for THIS SPECIFIC dossier
            const cachedDrivers = getFromCache(dossierCacheKey);
            if (cachedDrivers && cachedDrivers.length >= 50) {
                progressCallback && progressCallback('Using cached risk drivers...');
                return cachedDrivers;
            }

            progressCallback && progressCallback('AI is analyzing market intelligence and generating risk drivers...');

            // Fetch baseline macro data from CSV
            const macroData = await fetchBaselineMacroData(periodInfo);

            // If using latest data (future quarter), notify user in chat
            if (macroData && macroData.usedLatest) {
                notifyScenarioAssistant(`ðŸ“Š Macro Data: ${periodInfo.quarter} ${periodInfo.year} is not available yet. Using latest available data from ${macroData.actualQuarter}.`);
            }

            // Summarize dossier for AI prompt - deep content WITH URLS
            const dossierSummary = Object.entries(dossier).map(([category, articles]) => {
                // Top 5 articles, but much deeper content (4000 chars ~ 800 words)
                const summaries = articles.slice(0, 5).map(a => `- [${a.title}](${a.url || '#'}): ${a.content?.substring(0, 4000)}...`).join('\n\n');
                return `## ${category.replace(/_/g, ' ')}\n${summaries}`;
            }).join('\n\n');            // Build period context for historical dossiers
            let periodContext = '';
            if (periodInfo && periodInfo.quarter && periodInfo.year) {
                periodContext = `
TIME PERIOD CONTEXT:
This dossier is from ${periodInfo.quarter} ${periodInfo.year}. Generate risk drivers that were RELEVANT and ACTIVE during this specific quarter.
Consider what major events, crises, or trends were occurring globally and in Canada during ${periodInfo.quarter} ${periodInfo.year}.
The drivers should reflect the actual risk environment of that time period.
`;
            }

            const prompt = fillPrompt(PROMPT_TEMPLATES.RISK_DRIVERS, {
                PERIOD_QUARTER: periodInfo?.quarter || 'current',
                PERIOD_YEAR: periodInfo?.year || 'period',
                PERIOD_CONTEXT: periodContext,
                MACRO_PERIOD: `${periodInfo?.quarter || 'Current'} ${periodInfo?.year || ''}`,
                MACRO_SUMMARY: macroData ? macroData.summary : 'Not available',
                DOSSIER_SUMMARY: dossierSummary
            });


            try {
                const response = await fetch(AZURE_OPENAI_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-5-2025-08-07-eastus-dz',
                        messages: [{ role: 'user', content: prompt }],
                        // temperature omitted - GPT-5 only supports default value of 1
                        max_completion_tokens: 32384  // Keep reasonable for 50 drivers
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`âŒ API error ${response.status}: `, errorText);
                    throw new Error(`Azure OpenAI API error: ${response.status} `);
                }

                const data = await response.json();
                console.log('âœ“ API response received:', data);

                const aiResponse = data.choices[0].message.content;
                console.log('ðŸ“ AI response content (first 500 chars):', aiResponse.substring(0, 500));

                // Parse JSON from response
                let drivers = [];
                try {
                    const jsonMatch = aiResponse.match(/\[[\s\S]*\]/);
                    if (jsonMatch) {
                        console.log('âœ“ Found JSON array in response');
                        drivers = JSON.parse(jsonMatch[0]);
                    } else {
                        console.log('âš ï¸  No JSON array pattern found, trying direct parse');
                        drivers = JSON.parse(aiResponse);
                    }
                    console.log(`âœ“ Parsed ${drivers.length} drivers from AI response`);
                } catch (parseError) {
                    console.error('âŒ JSON parse error:', parseError);
                    console.error('Raw AI response:', aiResponse);
                    throw new Error('Failed to parse AI response');
                }

                // Deduplicate drivers based on title similarity
                progressCallback && progressCallback('Removing duplicate risk drivers...');
                drivers = deduplicateDrivers(drivers);
                console.log(`âœ“ After deduplication: ${drivers.length} unique drivers`);

                // Ensure exactly 50 drivers (trim if we have more, warn if we have less)
                const TARGET_DRIVER_COUNT = 50;
                if (drivers.length > TARGET_DRIVER_COUNT) {
                    console.log(`âœ“ Trimming from ${drivers.length} to ${TARGET_DRIVER_COUNT} drivers`);
                    drivers = drivers.slice(0, TARGET_DRIVER_COUNT);
                } else if (drivers.length < TARGET_DRIVER_COUNT) {
                    console.warn(`âš ï¸ Only ${drivers.length} unique drivers available(target: ${TARGET_DRIVER_COUNT})`);
                }

                // Add colors, chat history, and preserve sources to each driver
                drivers = drivers.map((d, idx) => {
                    const colors = CATEGORY_COLORS[d.cat] || { tagColor: '#E5E7EB', textColor: '#374151' };
                    return {
                        ...d,
                        id: d.id || `ai_${idx + 1} `,
                        tagColor: colors.tagColor,
                        textColor: colors.textColor,
                        chatHistory: [],
                        sources: d.sources || [] // Preserve sources from AI response
                    };
                });

                // Cache the generated drivers for this specific dossier
                saveToCache(dossierCacheKey, drivers);
                return drivers;

            } catch (error) {
                console.error('AI driver generation failed:', error);
                throw error;
            }
        }

        // Add more drivers to a specific category
        async function addMoreDriversForCategory(category) {
            const loader = document.getElementById('loader');
            const loaderText = document.getElementById('loaderText');

            loader.style.display = 'flex';
            loaderText.innerText = `Generating more ${category} risk drivers...`;

            try {
                // Get current dossier from cache
                const dossier = getFromCache(CACHE_KEY);
                if (!dossier) {
                    throw new Error('No dossier available. Please generate or load a dossier first.');
                }

                // Get existing drivers for this category
                const existingDrivers = INITIAL_DRIVERS.filter(d => d.cat === category);
                const existingTitles = existingDrivers.map(d => d.title);
                const existingDescriptions = existingDrivers.map(d => d.desc?.substring(0, 100)).join('\n');

                // Summarize dossier for AI prompt
                const dossierSummary = Object.entries(dossier).map(([cat, articles]) => {
                    const summaries = articles.slice(0, 3).map(a => `- ${a.title}: ${a.content?.substring(0, 1500)}...`).join('\n');
                    return `## ${cat.replace(/_/g, ' ')} \n${summaries} `;
                }).join('\n\n');

                const prompt = fillPrompt(PROMPT_TEMPLATES.RISK_DRIVERS_ADDITIONAL, {
                    CATEGORY: category,
                    EXISTING_TITLES: existingTitles.map((t, i) => `${i + 1}."${t}"`).join('\n'),
                    EXISTING_DESCRIPTIONS: existingDescriptions,
                    DOSSIER_SUMMARY: dossierSummary,
                    CATEGORY_SNAKE: category.toLowerCase().replace(/\s+/g, '_')
                });


                loaderText.innerText = `AI is analyzing dossier for new ${category} risks...`;

                const response = await fetch(AZURE_OPENAI_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-5-2025-08-07-eastus-dz',
                        messages: [{ role: 'user', content: prompt }],
                        max_tokens: 8000
                    })
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const data = await response.json();
                const aiResponse = data.choices[0].message.content;

                // Parse JSON from response
                let newDrivers = [];
                const jsonMatch = aiResponse.match(/\[[\s\S]*\]/);
                if (jsonMatch) {
                    newDrivers = JSON.parse(jsonMatch[0]);
                } else {
                    newDrivers = JSON.parse(aiResponse);
                }

                loaderText.innerText = 'Checking for duplicates...';

                // Deduplicate against ALL existing drivers (not just this category)
                const allExistingDrivers = INITIAL_DRIVERS;
                newDrivers = newDrivers.filter(newDriver => {
                    for (const existing of allExistingDrivers) {
                        const similarity = calculateSimilarity(newDriver.title, existing.title);
                        if (similarity >= 0.4) { // Slightly stricter threshold for new additions
                            console.log(`ðŸ”„ Filtered duplicate: "${newDriver.title}" similar to "${existing.title}"`);
                            return false;
                        }
                    }
                    return true;
                });

                if (newDrivers.length === 0) {
                    loader.style.display = 'none';
                    alert(`All generated drivers were too similar to existing ones. Try again or the category may be saturated.`);
                    return;
                }

                // Add colors and metadata to new drivers
                const colors = CATEGORY_COLORS[category] || { tagColor: '#E5E7EB', textColor: '#374151' };
                const timestamp = Date.now();
                newDrivers = newDrivers.map((d, idx) => ({
                    ...d,
                    id: `add_${category.toLowerCase().replace(/\s+/g, '_')}_${timestamp}_${idx}`,
                    cat: category,
                    tagColor: colors.tagColor,
                    textColor: colors.textColor,
                    chatHistory: [],
                    sources: d.sources || []
                }));

                // Add to INITIAL_DRIVERS
                INITIAL_DRIVERS.push(...newDrivers);

                // Update cache
                const dossierCacheKey = `${DRIVERS_CACHE_KEY}_${currentDossierId}`;
                saveToCache(dossierCacheKey, INITIAL_DRIVERS);

                loader.style.display = 'none';

                // Re-render marketplace
                renderMarketplace();

                // Show success message
                const successMsg = `âœ… Added ${newDrivers.length} new ${category} risk driver${newDrivers.length > 1 ? 's' : ''}!`;
                console.log(successMsg);

                // Optional: Show a toast or brief notification
                alert(successMsg);

            } catch (error) {
                console.error('Error adding more drivers:', error);
                loader.style.display = 'none';
                alert(`Failed to generate more drivers: ${error.message}`);
            }
        }

        // --- 5. INITIALIZATION ---
        async function initializeApp() {
            if (isInitializing) return;
            isInitializing = true;

            // Load saved dossiers list for the dropdown
            loadDossiersList();

            const loader = document.getElementById('loader');
            const loaderText = document.getElementById('loaderText');
            loader.style.display = 'flex'; // Ensure loader is visible during initial checks
            loaderText.innerText = 'Checking for cached market intelligence...';

            try {
                // Check if we have valid cached drivers
                const cachedDrivers = getFromCache(`${DRIVERS_CACHE_KEY}_current`);
                if (cachedDrivers && cachedDrivers.length >= 50) {
                    INITIAL_DRIVERS = cachedDrivers;
                    console.log(`âœ“ Loaded ${INITIAL_DRIVERS.length} risk drivers from cache`);
                    updateConnectionStatus(true, 'Cached');
                    loader.style.display = 'none';
                    showMarketplace();
                } else {
                    // Try to fetch shared dossier ONLY (passive check)
                    loaderText.innerText = 'Checking for shared market intelligence file...';
                    const dossier = await fetchMarketDossier((msg) => loaderText.innerText = msg);

                    if (dossier) {
                        // Found shared file or cache! Proceed normally.
                        loaderText.innerText = 'Generating AI-powered risk drivers...';
                        INITIAL_DRIVERS = await generateRiskDriversFromDossier(dossier, (msg) => {
                            loaderText.innerText = msg;
                        }, 'current');

                        console.log(`âœ“ Generated ${INITIAL_DRIVERS.length} risk drivers`);
                        updateConnectionStatus(true, 'Live');
                        loader.style.display = 'none';
                        showMarketplace();
                    } else {
                        // NO DATA FOUND. STOP. Show "Start Screen".
                        loader.style.display = 'none';
                        showStartScreen();
                    }
                }

                // Load and merge custom drivers from localStorage
                loadCustomDrivers();

                // Load saved scenarios from localStorage
                loadSavedScenarios();

            } catch (error) {
                console.error('Initialization error:', error);
                loaderText.innerText = `Error: ${error.message}. Loading fallback drivers...`;
                await new Promise(r => setTimeout(r, 2000));

                // Fallback to default drivers
                INITIAL_DRIVERS = getDefaultDrivers();
                updateConnectionStatus(false, 'Offline');
                loader.style.display = 'none';
                showMarketplace();

                // Still load custom drivers and saved scenarios
                loadCustomDrivers();
                loadSavedScenarios();

            } finally {
                isInitializing = false;
            }
        }

        function updateConnectionStatus(connected, mode) {
            const statusDot = document.querySelector('.status-dot');
            const statusText = document.getElementById('connectionStatusText');

            if (statusDot && statusText) {
                if (connected) {
                    statusDot.style.background = '#10B981';
                    statusText.innerText = `${mode} - Connected to Tavily API`;
                } else {
                    statusDot.style.background = '#F59E0B';
                    statusText.innerText = `${mode} - Using Fallback Data`;
                }
            }
        }

        function getDefaultDrivers() {
            // Fallback drivers if API fails
            return [
                { id: 'm1', cat: 'Macroeconomic', title: 'US-Canada Tariff Escalation', desc: 'Trump administration increases tariffs from 25% to 35% on Canadian imports, disrupting trade relations.', tagColor: '#DBEAFE', textColor: '#1E40AF', chatHistory: [] },
                { id: 'm2', cat: 'Macroeconomic', title: 'Canada Inflation Above Target', desc: 'CPI inflation at 2.4%, overshooting Bank of Canada\'s 2% threshold amid persistent price pressures.', tagColor: '#DBEAFE', textColor: '#1E40AF', chatHistory: [] },
                { id: 'm3', cat: 'Macroeconomic', title: 'Household Debt Vulnerability', desc: 'Debt-to-income ratio at 173%, leaving households exposed to rate volatility despite recent declines.', tagColor: '#DBEAFE', textColor: '#1E40AF', chatHistory: [] },
                { id: 'm4', cat: 'Macroeconomic', title: 'CBO Growth Downgrade', desc: 'Congressional Budget Office projects only 1.4% US growth in 2025, signaling economic slowdown.', tagColor: '#DBEAFE', textColor: '#1E40AF', chatHistory: [] },
                { id: 'm5', cat: 'Macroeconomic', title: 'US Debt Ceiling Uncertainty', desc: 'Treasury extraordinary measures strain after $5T ceiling raise, risking future fiscal crises.', tagColor: '#DBEAFE', textColor: '#1E40AF', chatHistory: [] },
                { id: 'g1', cat: 'Geopolitical', title: 'USMCA 2026 Review Risk', desc: 'Upcoming USMCA joint review in July 2026 creates trade policy uncertainty for Canada.', tagColor: '#FEE2E2', textColor: '#991B1B', chatHistory: [] },
                { id: 'g2', cat: 'Geopolitical', title: 'Foreign Interference Threat', desc: 'CSIS reports increasing foreign interference targeting Canadian democratic and economic institutions.', tagColor: '#FEE2E2', textColor: '#991B1B', chatHistory: [] },
                { id: 'g3', cat: 'Geopolitical', title: 'US Semiconductor Restrictions', desc: 'Commerce Department Section 232 investigations threaten semiconductor supply chains and AI development.', tagColor: '#FEE2E2', textColor: '#991B1B', chatHistory: [] },
                { id: 'g4', cat: 'Geopolitical', title: 'US Isolationism Wave', desc: 'America-first policies force Canada to recalibrate foreign policy and economic partnerships.', tagColor: '#FEE2E2', textColor: '#991B1B', chatHistory: [] },
                { id: 'g5', cat: 'Geopolitical', title: 'Shipping Route Disruption', desc: 'Freightos Baltic Index shows Red Sea diversions continue affecting global supply chains.', tagColor: '#FEE2E2', textColor: '#991B1B', chatHistory: [] },
                { id: 'c1', cat: 'Cyber / Tech', title: 'Ransomware Financial Sector', desc: 'CISA reports Medusa and Akira ransomware groups targeting financial institutions in 2025.', tagColor: '#E0E7FF', textColor: '#4338CA', chatHistory: [] },
                { id: 'c2', cat: 'Cyber / Tech', title: 'AI Risk Framework Adoption', desc: 'NIST AI RMF 2025 updates require banks to operationalize AI governance rapidly.', tagColor: '#E0E7FF', textColor: '#4338CA', chatHistory: [] },
                { id: 'c3', cat: 'Cyber / Tech', title: 'Record Crypto Theft', desc: 'Chainalysis reports $2.17B stolen in crypto hacks by mid-2025, including $1.5B Bybit heist.', tagColor: '#E0E7FF', textColor: '#4338CA', chatHistory: [] },
                { id: 'c4', cat: 'Cyber / Tech', title: 'DeFi Protocol Exploits', desc: 'October 2025 saw $38.6M lost across 9 DeFi exploits targeting DEXes and yield aggregators.', tagColor: '#E0E7FF', textColor: '#4338CA', chatHistory: [] },
                { id: 'c5', cat: 'Cyber / Tech', title: 'AI Labor Displacement', desc: 'OECD warns AI adoption may accelerate labor market shifts despite record employment.', tagColor: '#E0E7FF', textColor: '#4338CA', chatHistory: [] },
                { id: 'f1', cat: 'Financial', title: 'Housing Price Correction', desc: 'Toronto house prices down 7.9% YTD, Vancouver down 4.5% as Teranet Index shows continued weakness.', tagColor: '#D1FAE5', textColor: '#065F46', chatHistory: [] },
                { id: 'f2', cat: 'Financial', title: 'Credit Loss Provisions Rising', desc: 'TD and BMO Q3 2025 show elevated PCL trends, signaling credit quality deterioration.', tagColor: '#D1FAE5', textColor: '#065F46', chatHistory: [] },
                { id: 'f3', cat: 'Financial', title: 'OSFI Crypto Guidelines', desc: 'OSFI October 2025 allows greater crypto exposure but imposes strict capital treatment rules.', tagColor: '#D1FAE5', textColor: '#065F46', chatHistory: [] },
                { id: 'f4', cat: 'Financial', title: 'Negative Swap Spreads', desc: 'Bank of Canada notes negative swap spreads signal market stress and demand for government bonds.', tagColor: '#D1FAE5', textColor: '#065F46', chatHistory: [] },
                { id: 'f5', cat: 'Financial', title: 'RBC Q3 Record Earnings', desc: 'RBC reports $5.4B Q3 earnings but faces questions on capital allocation amid uncertainty.', tagColor: '#D1FAE5', textColor: '#065F46', chatHistory: [] },
                { id: 'e1', cat: 'Environmental', title: 'Record NatCat Losses', desc: 'Swiss Re reports $137B global insured losses in 2024, Canada\'s worst-ever catastrophe year at $9B.', tagColor: '#FEF3C7', textColor: '#92400E', chatHistory: [] },
                { id: 'e2', cat: 'Environmental', title: 'Wildfire Season 2026', desc: 'La NiÃ±a pattern suggests continued elevated fire risk for Canada through January 2026.', tagColor: '#FEF3C7', textColor: '#92400E', chatHistory: [] },
                { id: 'e3', cat: 'Environmental', title: 'OSFI B-15 Climate Rules', desc: 'Updated B-15 guidelines align with CSSB standards, requiring enhanced climate risk disclosure.', tagColor: '#FEF3C7', textColor: '#92400E', chatHistory: [] },
                { id: 'e4', cat: 'Environmental', title: 'Peak Loss Year Risk', desc: 'Swiss Re estimates 10% probability of $300B global insured losses in 2025.', tagColor: '#FEF3C7', textColor: '#92400E', chatHistory: [] },
                { id: 'e5', cat: 'Environmental', title: 'California Wildfire Contagion', desc: 'LA wildfires contribute $40B insured losses, impacting reinsurance market globally.', tagColor: '#FEF3C7', textColor: '#92400E', chatHistory: [] },
                { id: 's1', cat: 'Social', title: 'Housing Supply Gap', desc: 'PBO estimates 658,000 unit housing gap in Canada by 2030 despite reduced immigration targets.', tagColor: '#F3E8FF', textColor: '#6B21A8', chatHistory: [] },
                { id: 's2', cat: 'Social', title: 'US Political Instability', desc: 'Pew Research shows public trust at 17%, Democrats frustration with party up sharply.', tagColor: '#F3E8FF', textColor: '#6B21A8', chatHistory: [] },
                { id: 's3', cat: 'Social', title: 'Immigration Policy Reversal', desc: 'Canada reduces immigration targets after expanding to 500,000, affecting housing demand.', tagColor: '#F3E8FF', textColor: '#6B21A8', chatHistory: [] },
                { id: 's4', cat: 'Social', title: 'Liberal Electoral Shift', desc: 'Angus Reid shows Liberals at 46% support, potential policy shifts under Carney government.', tagColor: '#F3E8FF', textColor: '#6B21A8', chatHistory: [] },
                { id: 's5', cat: 'Social', title: 'Political Polarization', desc: 'Growing partisan divides in both US and Canada increase policy uncertainty.', tagColor: '#F3E8FF', textColor: '#6B21A8', chatHistory: [] },
                { id: 'r1', cat: 'Regulatory', title: 'OSFI Integrity Risk Priority', desc: 'OSFI Annual Risk Outlook 2025-26 elevates integrity and security risk as top priority.', tagColor: '#E5E7EB', textColor: '#374151', chatHistory: [] },
                { id: 'r2', cat: 'Regulatory', title: 'FINTRAC Real Estate Penalties', desc: 'FINTRAC imposes five AMPs on real estate brokerages, signaling enforcement acceleration.', tagColor: '#E5E7EB', textColor: '#374151', chatHistory: [] },
                { id: 'r3', cat: 'Regulatory', title: 'NSF Fee Restrictions', desc: 'March 2026 Bank Act amendments limit NSF fees for personal deposit accounts.', tagColor: '#E5E7EB', textColor: '#374151', chatHistory: [] },
                { id: 'r4', cat: 'Regulatory', title: 'Wholesale Credit Stress', desc: 'OSFI flags elevated wholesale credit risks from macroeconomic uncertainties.', tagColor: '#E5E7EB', textColor: '#374151', chatHistory: [] },
                { id: 'r5', cat: 'Regulatory', title: 'Funding Liquidity Concerns', desc: 'OSFI identifies funding and liquidity risks amid market volatility and rate uncertainty.', tagColor: '#E5E7EB', textColor: '#374151', chatHistory: [] }
            ];
        }

        // Force refresh function (for testing/manual refresh)
        async function forceRefreshDrivers() {
            localStorage.removeItem(CACHE_KEY);
            localStorage.removeItem(DRIVERS_CACHE_KEY);
            // Don't remove custom drivers - only refresh AI-generated ones
            const customDrivers = INITIAL_DRIVERS.filter(d => d.id.startsWith('cust_'));
            INITIAL_DRIVERS = [];
            isInitializing = false;
            await initializeApp();
        }

        // --- DOSSIER MANAGEMENT ---
        function loadDossiersList() {
            try {
                const stored = localStorage.getItem(DOSSIERS_LIST_KEY);
                if (stored) {
                    dossiersList = JSON.parse(stored);
                    updateDossierSelector();
                }
            } catch (e) {
                console.error('Failed to load dossiers list:', e);
                dossiersList = [];
            }
        }

        function saveDossiersList() {
            try {
                localStorage.setItem(DOSSIERS_LIST_KEY, JSON.stringify(dossiersList));
            } catch (e) {
                console.error('Failed to save dossiers list:', e);
            }
        }

        function updateDossierSelector() {
            const selector = document.getElementById('dossierSelector');
            if (!selector) return;

            // Keep current option, add historical dossiers
            selector.innerHTML = '<option value="current">Current (Live)</option>';

            dossiersList.forEach(d => {
                const option = document.createElement('option');
                option.value = d.id;
                option.textContent = `${d.quarter} ${d.year}`;
                if (d.id === currentDossierId) option.selected = true;
                selector.appendChild(option);
            });
        }

        function showGenerateDossierModal() {
            document.getElementById('generateDossierModal').style.display = 'flex';
            document.getElementById('dossierGenerationStatus').style.display = 'none';
            document.getElementById('generateDossierBtn').disabled = false;
        }

        function closeGenerateDossierModal() {
            document.getElementById('generateDossierModal').style.display = 'none';
        }

        async function generateHistoricalDossier() {
            const quarter = document.getElementById('dossierQuarter').value;
            const year = document.getElementById('dossierYear').value;
            const dossierId = `${quarter}_${year}`;

            // Check if dossier already exists
            if (dossiersList.some(d => d.id === dossierId)) {
                if (!confirm(`A dossier for ${quarter} ${year} already exists. Generate a new one and replace it?`)) {
                    return;
                }
            }

            // Show loading state
            document.getElementById('dossierGenerationStatus').style.display = 'block';
            document.getElementById('generateDossierBtn').disabled = true;
            const statusText = document.getElementById('dossierGenerationText');

            try {
                // Generate date range for the quarter
                const dateRange = getQuarterDateRange(quarter, year);

                statusText.innerText = `Searching Tavily for ${quarter} ${year} data...`;

                // Fetch historical dossier with date context
                const dossier = await fetchHistoricalDossier(quarter, year, dateRange, (msg) => {
                    statusText.innerText = msg;
                });

                // Generate drivers from the historical dossier
                statusText.innerText = 'Generating risk drivers from historical data...';
                const periodInfo = { quarter: quarter, year: year };
                const drivers = await generateRiskDriversFromDossier(dossier, (msg) => {
                    statusText.innerText = msg;
                }, dossierId, periodInfo);

                // Store the dossier
                const dossierData = {
                    id: dossierId,
                    quarter: quarter,
                    year: year,
                    dateRange: dateRange,
                    createdAt: new Date().toISOString(),
                    dossier: dossier,
                    drivers: drivers
                };

                // Save to localStorage
                localStorage.setItem(`astra_dossier_${dossierId}`, JSON.stringify(dossierData));

                // Update dossiers list
                const existingIdx = dossiersList.findIndex(d => d.id === dossierId);
                if (existingIdx > -1) {
                    dossiersList[existingIdx] = { id: dossierId, quarter, year, createdAt: dossierData.createdAt };
                } else {
                    dossiersList.push({ id: dossierId, quarter, year, createdAt: dossierData.createdAt });
                }
                saveDossiersList();
                updateDossierSelector();

                // Switch to the new dossier
                document.getElementById('dossierSelector').value = dossierId;
                await loadSelectedDossier();

                closeGenerateDossierModal();
                alert(`âœ“ Dossier for ${quarter} ${year} generated successfully!`);

            } catch (error) {
                console.error('Dossier generation error:', error);
                statusText.innerText = `Error: ${error.message}`;
                await new Promise(r => setTimeout(r, 2000));
            } finally {
                document.getElementById('dossierGenerationStatus').style.display = 'none';
                document.getElementById('generateDossierBtn').disabled = false;
            }
        }

        function getQuarterDateRange(quarter, year) {
            const ranges = {
                'Q1': { start: `${year}-01-01`, end: `${year}-03-31` },
                'Q2': { start: `${year}-04-01`, end: `${year}-06-30` },
                'Q3': { start: `${year}-07-01`, end: `${year}-09-30` },
                'Q4': { start: `${year}-10-01`, end: `${year}-12-31` }
            };
            return ranges[quarter];
        }

        async function fetchHistoricalDossier(quarter, year, dateRange, progressCallback) {
            const dossier = {};

            // Generate date-specific queries using the dynamic context function
            // Use historical query set for periods before 2024
            const historicalContext = getDynamicContext(year, quarter);
            const isHistorical = parseInt(year) < 2025;
            const historicalQueries = getTavilyQueries(historicalContext, isHistorical);

            console.log(`ðŸ“… Generating ${isHistorical ? 'HISTORICAL' : 'CURRENT'} queries for ${quarter} ${year}`);

            const categories = Object.keys(historicalQueries);
            let queryCount = 0;
            const totalQueries = Object.values(historicalQueries).reduce((sum, arr) => sum + arr.length, 0);

            // Track seen URLs to prevent duplicates across all queries
            const seenUrls = new Set();
            let duplicatesSkipped = 0;

            progressCallback(`Generating ${totalQueries} queries for ${quarter} ${year}...`);

            for (const category of categories) {
                dossier[category] = [];
                const queries = historicalQueries[category];

                for (const query of queries) {
                    queryCount++;
                    progressCallback(`[${queryCount}/${totalQueries}] Searching: ${category.replace(/_/g, ' ')}...`);

                    try {
                        const results = await fetchTavilySearchWithDate(query, dateRange);

                        // Add only unique articles (not seen before)
                        for (const r of results) {
                            if (!seenUrls.has(r.url)) {
                                seenUrls.add(r.url);
                                dossier[category].push({
                                    query: query,
                                    title: r.title,
                                    url: r.url,
                                    content: r.content,
                                    date: r.published_date || `${quarter} ${year}`
                                });
                            } else {
                                duplicatesSkipped++;
                            }
                        }
                    } catch (error) {
                        console.error(`Search failed for ${query}:`, error);
                    }

                    // Rate limiting - same as Python script
                    await new Promise(r => setTimeout(r, 300));
                }
            }

            console.log(`ðŸ“Š Dossier complete. Skipped ${duplicatesSkipped} duplicate articles.`);
            return dossier;
        }

        async function fetchTavilySearchWithDate(query, dateRange) {
            try {
                const targetYear = dateRange ? parseInt(dateRange.start.split('-')[0]) : null;

                // Trusted Canadian financial and news sources for better historical data
                const trustedDomains = [
                    'bankofcanada.ca',
                    'statcan.gc.ca',
                    'reuters.com',
                    'bloomberg.com',
                    'cbc.ca',
                    'globalnews.ca',
                    'financialpost.com',
                    'theglobeandmail.com',
                    'bnnbloomberg.ca',
                    'rbc.com'
                ];

                // Build request with Tavily's date filtering
                const requestBody = {
                    api_key: TAVILY_API_KEY,
                    query: query,
                    search_depth: 'advanced',
                    topic: 'news',  // Use news topic for better date filtering and published_date metadata
                    max_results: 20,  // Request more since we'll filter strictly
                    include_answer: false,
                    include_raw_content: false,
                    include_domains: trustedDomains  // Focus on trusted sources
                };

                // Add date filtering for historical queries
                if (dateRange && dateRange.start && dateRange.end) {
                    requestBody.start_date = dateRange.start;  // YYYY-MM-DD format
                    requestBody.end_date = dateRange.end;      // YYYY-MM-DD format
                    console.log(`ðŸ“… Tavily request: topic=news, date=${dateRange.start} to ${dateRange.end}, domains=${trustedDomains.length} trusted`);
                }

                const response = await fetch('https://api.tavily.com/search', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Tavily error response:', errorText);
                    throw new Error(`Tavily error: ${response.status}`);
                }

                const data = await response.json();
                let results = data.results || [];

                console.log(`ðŸ“Š Tavily returned ${results.length} raw results`);

                // STRICT POST-RETRIEVAL DATE VALIDATION
                // Tavily's date filtering may not work for historical queries, so we validate strictly
                if (targetYear && results.length > 0) {
                    const validatedResults = results.filter(r => {
                        // STRICT: Reject articles without published_date
                        // Articles without dates are likely modern content that Tavily returned incorrectly
                        if (!r.published_date) {
                            console.log(`  âŒ No date (rejected): ${r.title?.substring(0, 40)}...`);
                            return false;
                        }

                        const pubDate = new Date(r.published_date);
                        const pubYear = pubDate.getFullYear();

                        // STRICT: Only accept if published in the TARGET YEAR
                        // No Â±1 year flexibility - if we asked for 2023, we want 2023 articles
                        if (pubYear === targetYear) {
                            console.log(`  âœ“ Valid (${pubYear}): ${r.title?.substring(0, 40)}...`);
                            return true;
                        }

                        // Allow Q4 content published in early Q1 of next year (common for economic reports)
                        if (pubYear === targetYear + 1) {
                            const pubMonth = pubDate.getMonth() + 1; // 0-indexed
                            if (pubMonth <= 3) { // Jan, Feb, Mar
                                console.log(`  âœ“ Valid (early ${pubYear}, likely Q4 report): ${r.title?.substring(0, 40)}...`);
                                return true;
                            }
                        }

                        console.log(`  âŒ Wrong year (${pubYear}): ${r.title?.substring(0, 40)}...`);
                        return false;
                    });

                    console.log(`ðŸ“Š After strict date validation: ${validatedResults.length}/${results.length} passed`);

                    // If too few results passed, log a warning
                    if (validatedResults.length < 2) {
                        console.warn(`âš ï¸ Very few results (${validatedResults.length}) for: ${query}`);
                    }

                    results = validatedResults;
                }

                // Log final results
                results.slice(0, 5).forEach((r, i) => {
                    console.log(`  [${i + 1}] ${r.published_date || 'no date'}: ${r.title?.substring(0, 50)}...`);
                });

                return results.slice(0, 5);
            } catch (error) {
                console.error('Tavily search error:', error);
                return [];
            }
        }

        async function loadSelectedDossier() {
            const selector = document.getElementById('dossierSelector');
            const selectedId = selector.value;

            if (selectedId === 'current') {
                // Load current/live dossier
                currentDossierId = 'current';
                localStorage.removeItem(DRIVERS_CACHE_KEY); // Force regeneration
                INITIAL_DRIVERS = [];
                selectedDrivers = []; // Clear selection when switching dossiers
                await initializeApp();
                return;
            }

            // Load historical dossier
            const stored = localStorage.getItem(`astra_dossier_${selectedId}`);
            if (!stored) {
                alert('Dossier not found. It may have been deleted.');
                selector.value = 'current';
                return;
            }

            try {
                const dossierData = JSON.parse(stored);
                currentDossierId = selectedId;
                INITIAL_DRIVERS = dossierData.drivers || [];

                // Update status to show historical mode
                document.getElementById('connectionStatusText').innerText =
                    `Historical: ${dossierData.quarter} ${dossierData.year}`;

                const statusDot = document.querySelector('.status-dot');
                if (statusDot) statusDot.style.background = '#F59E0B'; // Orange for historical

                // Clear selected drivers when switching dossiers
                selectedDrivers = [];

                // Load custom drivers
                loadCustomDrivers();
                renderMarketplace();
                updateInventory(); // Update basket to show empty

                console.log(`âœ“ Loaded ${INITIAL_DRIVERS.length} drivers from ${dossierData.quarter} ${dossierData.year} dossier`);
            } catch (e) {
                console.error('Failed to load dossier:', e);
                alert('Failed to load dossier.');
            }
        }

        function deleteSelectedDossier() {
            const selector = document.getElementById('dossierSelector');
            const selectedId = selector.value;

            // Prevent deleting the current/live dossier
            if (selectedId === 'current') {
                alert('Cannot delete the live dossier. Select a historical dossier to delete.');
                return;
            }

            // Find dossier info for display
            const dossierInfo = dossiersList.find(d => d.id === selectedId);
            const displayName = dossierInfo ? `${dossierInfo.quarter} ${dossierInfo.year}` : selectedId;

            // Confirm deletion
            if (!confirm(`Are you sure you want to delete the "${displayName}" dossier? This action cannot be undone.`)) {
                return;
            }

            // Remove from localStorage
            localStorage.removeItem(`astra_dossier_${selectedId}`);

            // Remove from dossiers list
            dossiersList = dossiersList.filter(d => d.id !== selectedId);
            saveDossiersList();
            updateDossierSelector();

            // Determine which dossier to switch to
            if (dossiersList.length > 0) {
                // Switch to another available historical dossier
                const nextDossier = dossiersList[0];
                selector.value = nextDossier.id;
                loadSelectedDossier();
                console.log(`ðŸ—‘ï¸ Deleted dossier: ${displayName}. Switched to ${nextDossier.quarter} ${nextDossier.year}`);
                alert(`Dossier "${displayName}" has been deleted. Switched to ${nextDossier.quarter} ${nextDossier.year}.`);
            } else {
                // No other dossiers available, stay on current view
                // Don't call loadSelectedDossier() to avoid triggering Tavily fetch
                selector.value = 'current';
                currentDossierId = 'current';

                // Check if we have cached drivers
                const cachedDrivers = getFromCache(DRIVERS_CACHE_KEY);
                if (cachedDrivers && cachedDrivers.length > 0) {
                    INITIAL_DRIVERS = cachedDrivers;
                    loadCustomDrivers();
                    renderMarketplace();
                    updateConnectionStatus(true, false, false);
                    console.log(`ðŸ—‘ï¸ Deleted dossier: ${displayName}. Using cached live data.`);
                    alert(`Dossier "${displayName}" has been deleted. Using cached live data.`);
                } else {
                    // No cache, will need to fetch
                    console.log(`ðŸ—‘ï¸ Deleted dossier: ${displayName}. No cached data, will fetch new data.`);
                    alert(`Dossier "${displayName}" has been deleted. No other dossiers available.`);
                    loadSelectedDossier();
                }
            }
        }

        function exportCurrentDossier() {
            const dossierData = {
                exportedAt: new Date().toISOString(),
                dossierId: currentDossierId,
                drivers: INITIAL_DRIVERS.filter(d => !d.id.startsWith('cust_')), // Exclude custom drivers
                customDrivers: INITIAL_DRIVERS.filter(d => d.id.startsWith('cust_'))
            };

            // If we have a historical dossier, include raw dossier data
            if (currentDossierId !== 'current') {
                const stored = localStorage.getItem(`astra_dossier_${currentDossierId}`);
                if (stored) {
                    const fullDossier = JSON.parse(stored);
                    dossierData.quarter = fullDossier.quarter;
                    dossierData.year = fullDossier.year;
                    dossierData.rawDossier = fullDossier.dossier;
                }
            }

            const blob = new Blob([JSON.stringify(dossierData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `astra_dossier_${currentDossierId}_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function importDossierFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const data = JSON.parse(e.target.result);

                    // DETECT FILE TYPE:
                    // Type A: Raw market dossier from Tavily (has 'data' and 'timestamp')
                    // Type B: Exported scenario file (has 'drivers' array)
                    // Type C: Workspace backup (has 'exportType: astra_workspace_backup')

                    // --- TYPE C: Workspace Backup ---
                    if (data.exportType === 'astra_workspace_backup' && data.data) {
                        console.log('âœ“ Detected workspace backup file. Restoring...');

                        // Reuse the importWorkspace logic inline
                        const workspaceData = data.data;
                        let restoredItems = [];

                        // Restore saved scenarios
                        if (workspaceData.savedScenarios && workspaceData.savedScenarios.length > 0) {
                            savedScenarios = workspaceData.savedScenarios;
                            saveScenariosToStorage();
                            restoredItems.push(`${workspaceData.savedScenarios.length} scenarios`);
                        }

                        // Restore market dossier
                        if (workspaceData.marketDossier) {
                            saveToCache(CACHE_KEY, workspaceData.marketDossier.data || workspaceData.marketDossier);
                            restoredItems.push('market dossier');
                        }

                        // Restore risk drivers
                        if (workspaceData.riskDrivers) {
                            const driversToRestore = workspaceData.riskDrivers.data || workspaceData.riskDrivers;
                            saveToCache(`${DRIVERS_CACHE_KEY}_current`, driversToRestore);
                            INITIAL_DRIVERS = driversToRestore;
                            restoredItems.push(`${driversToRestore.length} risk drivers`);
                        }

                        // Restore custom drivers
                        if (workspaceData.customDrivers && workspaceData.customDrivers.length > 0) {
                            localStorage.setItem(CUSTOM_DRIVERS_KEY, JSON.stringify(workspaceData.customDrivers));
                            restoredItems.push(`${workspaceData.customDrivers.length} custom drivers`);
                        }

                        // Restore dossiers list
                        if (workspaceData.dossiersList) {
                            localStorage.setItem('astra_dossiers_list', JSON.stringify(workspaceData.dossiersList));
                        }

                        // Restore historical dossiers
                        if (workspaceData.historicalDossiers) {
                            Object.entries(workspaceData.historicalDossiers).forEach(([id, dossierData]) => {
                                localStorage.setItem(`astra_dossier_${id}`, JSON.stringify(dossierData));
                            });
                        }

                        // Hide start screen and show marketplace
                        const startScreen = document.getElementById('startScreen');
                        if (startScreen) startScreen.style.display = 'none';

                        loadCustomDrivers();
                        loadSavedScenarios();
                        loadDossiersList();
                        updateDossierSelector();
                        showMarketplace();
                        updateConnectionStatus(true, 'Restored');

                        alert(`âœ“ Workspace restored successfully!\n\nRestored:\nâ€¢ ${restoredItems.join('\nâ€¢ ')}`);
                        return;
                    }

                    // --- TYPE A: Raw Market Dossier (dossier_current.json) ---
                    if (data.data && data.timestamp) {
                        console.log('âœ“ Detected raw market dossier file. Processing...');

                        // Validate cache freshness
                        if (!isCacheValid(data)) {
                            const proceed = confirm('This dossier file is older than ' + CACHE_EXPIRY_DAYS + ' days. Load anyway?');
                            if (!proceed) return;
                        }

                        // Save raw dossier to cache
                        saveToCache(CACHE_KEY, data.data);

                        // Hide start screen, show loader
                        const startScreen = document.getElementById('startScreen');
                        if (startScreen) startScreen.style.display = 'none';
                        const loader = document.getElementById('loader');
                        const loaderText = document.getElementById('loaderText');
                        loader.style.display = 'flex';
                        loaderText.innerText = 'Generating risk drivers from loaded dossier...';

                        // Generate AI drivers from this dossier
                        INITIAL_DRIVERS = await generateRiskDriversFromDossier(data.data, (msg) => {
                            loaderText.innerText = msg;
                        }, 'current');

                        console.log(`âœ“ Generated ${INITIAL_DRIVERS.length} risk drivers from imported dossier`);
                        updateConnectionStatus(true, 'Loaded');
                        loader.style.display = 'none';
                        showMarketplace();
                        loadCustomDrivers();
                        loadSavedScenarios();

                        alert(`âœ“ Market dossier loaded successfully! Generated ${INITIAL_DRIVERS.length} risk drivers.`);
                        return;
                    }

                    // --- TYPE B: Exported Scenario File (from export button) ---
                    if (data.drivers && Array.isArray(data.drivers)) {
                        console.log('âœ“ Detected exported scenario file. Processing...');

                        // Directly load the drivers
                        INITIAL_DRIVERS = data.drivers;

                        // Save to cache for persistence
                        saveToCache(`${DRIVERS_CACHE_KEY}_current`, INITIAL_DRIVERS);

                        // Load custom drivers if present
                        if (data.customDrivers && data.customDrivers.length > 0) {
                            localStorage.setItem(CUSTOM_DRIVERS_KEY, JSON.stringify(data.customDrivers));
                        }

                        // Hide start screen and show marketplace
                        const startScreen = document.getElementById('startScreen');
                        if (startScreen) startScreen.style.display = 'none';

                        loadCustomDrivers();
                        loadSavedScenarios();
                        showMarketplace();
                        updateConnectionStatus(true, 'Loaded');

                        alert(`âœ“ Scenario loaded successfully! (${data.drivers.length} risk drivers)`);
                        return;
                    }

                    // Unknown format
                    throw new Error('Unrecognized file format. Expected:\nâ€¢ Raw dossier (with "data" and "timestamp")\nâ€¢ Exported scenario (with "drivers" array)\nâ€¢ Workspace backup (with "exportType")');

                } catch (error) {
                    console.error('Import error:', error);
                    alert('Failed to import file: ' + error.message);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset file input
        }

        // --- CUSTOM DRIVERS PERSISTENCE ---
        function loadCustomDrivers() {
            try {
                const stored = localStorage.getItem(CUSTOM_DRIVERS_KEY);
                if (stored) {
                    const customDrivers = JSON.parse(stored);
                    // Normalize custom drivers to have "Customized" category
                    const normalizedDrivers = customDrivers.map(d => ({
                        ...d,
                        cat: 'Customized', // Force to Customized category
                        tagColor: '#CFFAFE', // Teal/Cyan
                        textColor: '#0E7490'
                    }));
                    // Filter out any drivers that already exist (by ID)
                    const existingIds = new Set(INITIAL_DRIVERS.map(d => d.id));
                    const newCustomDrivers = normalizedDrivers.filter(d => !existingIds.has(d.id));
                    INITIAL_DRIVERS = [...INITIAL_DRIVERS, ...newCustomDrivers];
                    console.log(`âœ“ Loaded ${newCustomDrivers.length} custom drivers from storage`);
                    renderMarketplace();
                }
            } catch (e) {
                console.error('Failed to load custom drivers:', e);
            }
        }

        function saveCustomDrivers() {
            try {
                // Save only drivers with IDs starting with 'cust_'
                const customDrivers = INITIAL_DRIVERS.filter(d => d.id.startsWith('cust_'));
                localStorage.setItem(CUSTOM_DRIVERS_KEY, JSON.stringify(customDrivers));
                console.log(`âœ“ Saved ${customDrivers.length} custom drivers to storage`);
            } catch (e) {
                console.error('Failed to save custom drivers:', e);
            }
        }

        function deleteCustomDriver(driverId) {
            if (!driverId.startsWith('cust_')) {
                alert('Only custom drivers can be deleted.');
                return;
            }

            if (!confirm('Delete this custom driver? This cannot be undone.')) {
                return;
            }

            // Remove from INITIAL_DRIVERS
            const index = INITIAL_DRIVERS.findIndex(d => d.id === driverId);
            if (index > -1) {
                INITIAL_DRIVERS.splice(index, 1);
            }

            // Remove from selected drivers if present
            const selectedIdx = selectedDrivers.findIndex(d => d.id === driverId);
            if (selectedIdx > -1) {
                selectedDrivers.splice(selectedIdx, 1);
            }

            // Save updated custom drivers
            saveCustomDrivers();

            // Close modal if open
            closeModal();

            // Re-render
            renderMarketplace();
            updateInventory();
        }

        // --- SAVED SCENARIOS PERSISTENCE ---
        function loadSavedScenarios() {
            try {
                const stored = localStorage.getItem(SAVED_SCENARIOS_KEY);
                console.log('Loading scenarios from localStorage:', stored);
                if (stored) {
                    savedScenarios = JSON.parse(stored);
                    console.log('Parsed savedScenarios:', savedScenarios);
                }
            } catch (e) {
                console.error('Failed to load saved scenarios:', e);
                savedScenarios = [];
            }
        }

        function saveScenariosToStorage() {
            try {
                localStorage.setItem(SAVED_SCENARIOS_KEY, JSON.stringify(savedScenarios));
            } catch (e) {
                console.error('Failed to save scenarios:', e);
            }
        }

        // --- SETTINGS MODAL ---
        function showSettingsModal() {
            document.getElementById('settingsModal').style.display = 'flex';
        }

        function closeSettingsModal() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        // --- UNIFIED WORKSPACE BACKUP/RESTORE ---
        function exportWorkspace() {
            // Gather all data from localStorage
            const workspaceData = {
                exportType: 'astra_workspace_backup',
                exportedAt: new Date().toISOString(),
                version: '1.0',
                data: {
                    // Saved scenarios
                    savedScenarios: savedScenarios,

                    // Market dossier (raw Tavily data)
                    marketDossier: JSON.parse(localStorage.getItem(CACHE_KEY) || 'null'),

                    // Generated risk drivers
                    riskDrivers: JSON.parse(localStorage.getItem(`${DRIVERS_CACHE_KEY}_current`) || 'null'),

                    // Custom drivers
                    customDrivers: JSON.parse(localStorage.getItem(CUSTOM_DRIVERS_KEY) || '[]'),

                    // Historical dossiers list
                    dossiersList: JSON.parse(localStorage.getItem('astra_dossiers_list') || '[]')
                }
            };

            // Also include any historical dossiers
            const historicalDossiers = {};
            const dossiersList = JSON.parse(localStorage.getItem('astra_dossiers_list') || '[]');
            dossiersList.forEach(d => {
                const dossierData = localStorage.getItem(`astra_dossier_${d.id}`);
                if (dossierData) {
                    historicalDossiers[d.id] = JSON.parse(dossierData);
                }
            });
            workspaceData.data.historicalDossiers = historicalDossiers;

            const blob = new Blob([JSON.stringify(workspaceData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `astra_workspace_backup_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            closeSettingsModal();
            const dossierCount = Object.keys(historicalDossiers).length;
            const customDriverCount = JSON.parse(localStorage.getItem(CUSTOM_DRIVERS_KEY) || '[]').length;
            alert(`âœ“ Workspace exported successfully!\n\nThis backup includes:\nâ€¢ ${savedScenarios.length} folder items\nâ€¢ Market dossier data\nâ€¢ ${INITIAL_DRIVERS.length} risk drivers\nâ€¢ ${customDriverCount} custom drivers\nâ€¢ ${dossierCount} historical dossiers\n\nUse this file to restore your workspace on another browser or device.`);
        }

        function importWorkspace(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const workspaceData = JSON.parse(e.target.result);

                    // Validate backup format
                    if (workspaceData.exportType !== 'astra_workspace_backup' || !workspaceData.data) {
                        throw new Error('Invalid workspace backup file. Please select a valid ASTRA workspace backup.');
                    }

                    const data = workspaceData.data;
                    let restoredItems = [];
                    let skippedItems = [];

                    // Helper function to safely store items
                    function safeSetItem(key, value) {
                        try {
                            localStorage.setItem(key, JSON.stringify(value));
                            return true;
                        } catch (e) {
                            if (e.name === 'QuotaExceededError' || e.message.includes('quota')) {
                                console.warn(`Storage quota exceeded for ${key}, skipping...`);
                                return false;
                            }
                            throw e;
                        }
                    }

                    // Restore saved scenarios (priority - usually small)
                    if (data.savedScenarios && data.savedScenarios.length > 0) {
                        savedScenarios = data.savedScenarios;
                        if (safeSetItem(SAVED_SCENARIOS_KEY, savedScenarios)) {
                            restoredItems.push(`${data.savedScenarios.length} folder items`);
                        } else {
                            skippedItems.push('folder items (too large)');
                        }
                    }

                    // Restore risk drivers (priority - needed for app to work)
                    if (data.riskDrivers) {
                        const driversToRestore = data.riskDrivers.data || data.riskDrivers;
                        if (safeSetItem(`${DRIVERS_CACHE_KEY}_current`, { data: driversToRestore, timestamp: Date.now() })) {
                            INITIAL_DRIVERS = driversToRestore;
                            restoredItems.push(`${driversToRestore.length} risk drivers`);
                        } else {
                            skippedItems.push('risk drivers (too large)');
                        }
                    }

                    // Restore custom drivers
                    if (data.customDrivers && data.customDrivers.length > 0) {
                        if (safeSetItem(CUSTOM_DRIVERS_KEY, data.customDrivers)) {
                            loadCustomDrivers();
                            restoredItems.push(`${data.customDrivers.length} custom drivers`);
                        } else {
                            skippedItems.push('custom drivers');
                        }
                    }

                    // Restore market dossier (can be large - lower priority)
                    if (data.marketDossier) {
                        if (safeSetItem(CACHE_KEY, { data: data.marketDossier.data || data.marketDossier, timestamp: Date.now() })) {
                            restoredItems.push('market dossier');
                        } else {
                            skippedItems.push('market dossier (too large)');
                        }
                    }

                    // Restore dossiers list (small)
                    if (data.dossiersList) {
                        safeSetItem('astra_dossiers_list', data.dossiersList);
                    }

                    // Restore historical dossiers (can be very large - skip if quota exceeded)
                    if (data.historicalDossiers) {
                        let restoredDossiers = 0;
                        let skippedDossiers = 0;
                        for (const [id, dossierData] of Object.entries(data.historicalDossiers)) {
                            if (safeSetItem(`astra_dossier_${id}`, dossierData)) {
                                restoredDossiers++;
                            } else {
                                skippedDossiers++;
                            }
                        }
                        if (restoredDossiers > 0) restoredItems.push(`${restoredDossiers} historical dossiers`);
                        if (skippedDossiers > 0) skippedItems.push(`${skippedDossiers} historical dossiers (storage full)`);
                    }

                    // Refresh UI
                    renderMarketplace();
                    renderSavedScenarios();
                    loadDossiersList();
                    updateDossierSelector();

                    closeSettingsModal();

                    let message = `âœ“ Workspace restored!\n\nRestored:\nâ€¢ ${restoredItems.join('\nâ€¢ ')}`;
                    if (skippedItems.length > 0) {
                        message += `\n\nâš ï¸ Skipped (storage full):\nâ€¢ ${skippedItems.join('\nâ€¢ ')}\n\nTip: Use Settings â†’ Clear All Cached Data to free up space.`;
                    }
                    alert(message);

                } catch (error) {
                    console.error('Workspace import error:', error);
                    alert('Failed to import workspace: ' + error.message);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset file input
        }

        function clearAllCaches() {
            if (!confirm('This will clear ALL cached data including:\n\nâ€¢ Market dossier\nâ€¢ Generated risk drivers\nâ€¢ Custom drivers\nâ€¢ Historical dossiers\n\nSaved scenarios will be preserved.\n\nAre you sure?')) {
                return;
            }

            // Clear caches but preserve scenarios
            localStorage.removeItem(CACHE_KEY);
            localStorage.removeItem(`${DRIVERS_CACHE_KEY}_current`);
            localStorage.removeItem(CUSTOM_DRIVERS_KEY);

            // Clear historical dossiers
            const dossiersList = JSON.parse(localStorage.getItem('astra_dossiers_list') || '[]');
            dossiersList.forEach(d => {
                localStorage.removeItem(`astra_dossier_${d.id}`);
            });
            localStorage.removeItem('astra_dossiers_list');

            closeSettingsModal();
            alert('âœ“ All cached data cleared.\n\nRefresh the page to start fresh.');
            location.reload();
        }

        async function startNewSession() {
            // Hide start screen, show loader
            const startScreen = document.getElementById('startScreen');
            if (startScreen) startScreen.style.display = 'none';

            const loader = document.getElementById('loader');
            const loaderText = document.getElementById('loaderText');
            loader.style.display = 'flex';
            loaderText.innerText = 'Initializing new market scan...';

            try {
                // FORCE NEW GENERATION
                const dossier = await generateNewMarketDossier((msg) => {
                    loaderText.innerText = msg;
                });

                loaderText.innerText = 'Generating AI risk drivers...';
                INITIAL_DRIVERS = await generateRiskDriversFromDossier(dossier, (msg) => {
                    loaderText.innerText = msg;
                }, 'current');

                console.log(`âœ“ Generated ${INITIAL_DRIVERS.length} risk drivers`);
                updateConnectionStatus(true, 'Live');
                loader.style.display = 'none';
                showMarketplace();

                // Reload custom drivers & scenarios
                loadCustomDrivers();
                loadSavedScenarios();

            } catch (error) {
                console.error("Session start error:", error);
                alert("Failed to generate session: " + error.message);
                loader.style.display = 'none';
                showStartScreen();
            }
        }

        function showStartScreen() {
            // Create start screen overlay if it doesn't exist
            let startScreen = document.getElementById('startScreen');
            if (!startScreen) {
                startScreen = document.createElement('div');
                startScreen.id = 'startScreen';
                startScreen.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(255,255,255,0.95); z-index:9999; display:flex; flex-direction:column; align-items:center; justify-content:center;';
                startScreen.innerHTML = `
                    <div style="text-align:center; max-width:520px; padding:40px; background:white; border-radius:16px; box-shadow:0 10px 25px rgba(0,0,0,0.1); border:1px solid #e5e7eb;">
                        <div style="font-size:48px; margin-bottom:16px;">ðŸŒŒ</div>
                        <h1 style="margin:0 0 12px 0; color:#111827; font-size:24px;">Welcome to ASTRA</h1>
                        <p style="color:#6b7280; margin-bottom:24px; line-height:1.5;">
                            Choose how to initialize your session:
                        </p>

                        <div style="display:flex; flex-direction:column; gap:12px;">
                            <label class="btn-primary" style="background:#4F46E5; cursor:pointer; display:flex; align-items:center; justify-content:center; padding:14px 20px;">
                                ðŸ“‚ Load Dossier File
                                <input type="file" onchange="importDossierFile(event);" style="display:none;" accept=".json">
                            </label>
                            <p style="margin:0; font-size:11px; color:#9CA3AF;">Loads risk drivers only.</p>

                            <label style="margin-top:8px; background:#f3f4f6; cursor:pointer; display:flex; align-items:center; justify-content:center; padding:14px 20px; border:1px solid #d1d5db; border-radius:12px; font-weight:600; color:#374151;">
                                ðŸ’¾ Load Full Workspace
                                <input type="file" onchange="loadWorkspaceWithClear(event);" style="display:none;" accept=".json">
                            </label>
                            <p style="margin:0; font-size:11px; color:#9CA3AF;">Restores scenarios & drivers.</p>

                            <button onclick="startNewSession()" class="btn-primary" style="margin-top:16px; background:#10B981;">
                                ðŸ” Start New Scan
                            </button>
                            <p style="margin:0; font-size:11px; color:#9CA3AF;">* Incurs Tavily API costs.</p>
                        </div>
                    </div>
                `;
                document.body.appendChild(startScreen);
            }
            startScreen.style.display = 'flex';
        }

        function loadWorkspaceWithClear(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Clear ALL existing ASTRA data first to make room
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('astra_')) {
                    keysToRemove.push(key);
                }
            }
            keysToRemove.forEach(key => localStorage.removeItem(key));
            console.log(`Cleared ${keysToRemove.length} existing ASTRA entries from localStorage`);

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const workspaceData = JSON.parse(e.target.result);

                    if (workspaceData.exportType !== 'astra_workspace_backup' || !workspaceData.data) {
                        throw new Error('Invalid file. Please select an ASTRA workspace backup.');
                    }

                    document.getElementById('startScreen').style.display = 'none';
                    document.getElementById('loader').style.display = 'flex';
                    document.getElementById('loaderText').innerText = 'Restoring workspace...';

                    const data = workspaceData.data;
                    let restoredItems = [];

                    // Restore scenarios
                    if (data.savedScenarios && data.savedScenarios.length > 0) {
                        savedScenarios = data.savedScenarios;
                        localStorage.setItem(SAVED_SCENARIOS_KEY, JSON.stringify(savedScenarios));
                        restoredItems.push(`${data.savedScenarios.length} scenarios`);
                    }

                    // Restore drivers
                    if (data.riskDrivers) {
                        const drivers = data.riskDrivers.data || data.riskDrivers;
                        INITIAL_DRIVERS = drivers;
                        localStorage.setItem(`${DRIVERS_CACHE_KEY}_current`, JSON.stringify({ data: drivers, timestamp: Date.now() }));
                        restoredItems.push(`${drivers.length} risk drivers`);
                    }

                    // Restore custom drivers
                    if (data.customDrivers && data.customDrivers.length > 0) {
                        localStorage.setItem(CUSTOM_DRIVERS_KEY, JSON.stringify(data.customDrivers));
                        restoredItems.push(`${data.customDrivers.length} custom drivers`);
                    }

                    // Restore dossiers list
                    if (data.dossiersList && data.dossiersList.length > 0) {
                        localStorage.setItem('astra_dossiers_list', JSON.stringify(data.dossiersList));
                    }

                    // Restore historical dossiers
                    if (data.historicalDossiers) {
                        let restoredDossiers = 0;
                        for (const [id, dossierData] of Object.entries(data.historicalDossiers)) {
                            try {
                                localStorage.setItem(`astra_dossier_${id}`, JSON.stringify(dossierData));
                                restoredDossiers++;
                            } catch (e) {
                                console.warn(`Failed to restore dossier ${id}:`, e);
                            }
                        }
                        if (restoredDossiers > 0) {
                            restoredItems.push(`${restoredDossiers} historical dossiers`);
                        }
                    }

                    // Show marketplace
                    document.getElementById('loader').style.display = 'none';
                    loadCustomDrivers();
                    loadSavedScenarios();
                    loadDossiersList();
                    updateDossierSelector();
                    showMarketplace();
                    updateConnectionStatus(true, 'Restored');

                    alert(`âœ“ Workspace restored!\n\nâ€¢ ${restoredItems.join('\nâ€¢ ')}`);

                } catch (error) {
                    console.error('Workspace import error:', error);
                    document.getElementById('loader').style.display = 'none';
                    alert('Failed to load: ' + error.message);
                    showStartScreen();
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function deleteScenario(scenarioId) {
            if (!confirm('Delete this saved scenario? This cannot be undone.')) {
                return;
            }

            const index = savedScenarios.findIndex(s => s.id === scenarioId);
            if (index > -1) {
                savedScenarios.splice(index, 1);
                saveScenariosToStorage();
                renderSavedScenarios();
            }
        }

        document.addEventListener('DOMContentLoaded', initializeApp);

        function filterDrivers(query) {
            renderMarketplace(query);
        }

        function renderMarketplace(filterText = '') {
            const container = document.getElementById('driversContainer');

            // Filter drivers based on text
            const filteredDrivers = INITIAL_DRIVERS.filter(d => {
                const searchStr = (d.title + ' ' + d.desc + ' ' + d.cat).toLowerCase();
                return searchStr.includes(filterText.toLowerCase());
            });

            if (filteredDrivers.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: var(--text-muted);">
                        <div style="font-size: 32px; margin-bottom: 16px;">ðŸ”</div>
                        <p>No drivers found matching "${filterText}"</p>
                        <button onclick="createCustomDriver()" style="margin-top: 16px; color: var(--primary); background: none; border: none; font-weight: 600; cursor: pointer;">
                            Ask AI to generate it?
                        </button>
                    </div>
                `;
                return;
            }

            // Separate custom drivers from regular drivers
            const regularDrivers = filteredDrivers.filter(d => !d.id.startsWith('cust_'));
            const customDrivers = filteredDrivers.filter(d => d.id.startsWith('cust_'));

            // Get unique categories for regular drivers only
            const regularCategories = [...new Set(regularDrivers.map(d => d.cat))];

            // Render regular categories with "Add More" button
            let html = regularCategories.map(cat => `
                <div class="category-header" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                    <div class="category-label" style="margin-bottom: 0;">${cat}</div>
                    <button class="add-more-btn" onclick="event.stopPropagation(); addMoreDriversForCategory('${cat}')" 
                        title="Add more ${cat} risk drivers"
                        style="
                            background: linear-gradient(135deg, rgba(37, 99, 235, 0.1), rgba(79, 70, 229, 0.1));
                            border: 1px solid rgba(37, 99, 235, 0.3);
                            color: var(--primary);
                            padding: 4px 10px;
                            border-radius: 100px;
                            font-size: 11px;
                            font-weight: 600;
                            cursor: pointer;
                            transition: all 0.2s ease;
                            display: flex;
                            align-items: center;
                            gap: 4px;
                        "
                        onmouseover="this.style.background='linear-gradient(135deg, var(--primary), #4F46E5)'; this.style.color='white'; this.style.transform='scale(1.05)';"
                        onmouseout="this.style.background='linear-gradient(135deg, rgba(37, 99, 235, 0.1), rgba(79, 70, 229, 0.1))'; this.style.color='var(--primary)'; this.style.transform='scale(1)';">
                        <span>+</span> Add More
                    </button>
                </div>
                <div class="drivers-grid">
                    ${regularDrivers.filter(d => d.cat === cat).map(d => {
                const sourcesHtml = (d.sources && d.sources.length > 0) ? `
                            <div class="driver-sources">
                                <div class="sources-label">Sources</div>
                                <div class="source-list">
                                    ${d.sources.slice(0, 3).map(src => `
                                        <a href="${src.url || '#'}" class="source-item" target="_blank" rel="noopener" onclick="event.stopPropagation()">
                                            <span class="source-item-text">${src.title || 'Source'}</span>
                                        </a>
                                    `).join('')}
                                </div>
                            </div>
                        ` : '';
                return `
                        <div id="card_${d.id}" class="driver-card ${selectedDrivers.some(s => s.id === d.id) ? 'selected' : ''}" 
                            draggable="true"
                            ondragstart="handleDragStart(event, '${d.id}')"
                            ondragend="handleDragEnd(event)"
                            onclick="openDriverDetails('${d.id}')">
                            <span class="driver-tag" style="background:${d.tagColor}; color:${d.textColor}">${cat}</span>
                            <div class="driver-title">${d.title}</div>
                            <div class="driver-desc">${d.desc}</div>
                            ${sourcesHtml}
                        </div>
                        `;
            }).join('')}
                </div>
            `).join('');            // Render Customized section at the end if there are custom drivers
            if (customDrivers.length > 0) {
                html += `
                    <div class="category-label">Customized</div>
                    <div class="drivers-grid">
                        ${customDrivers.map(d => {
                    const sourcesHtml = (d.sources && d.sources.length > 0) ? `
                                <div class="driver-sources">
                                    <div class="sources-label">Sources</div>
                                    <div class="source-list">
                                        ${d.sources.slice(0, 3).map(src => `
                                            <a href="${src.url || '#'}" class="source-item" target="_blank" rel="noopener" onclick="event.stopPropagation()">
                                                <span class="source-item-text">${src.title || 'Source'}</span>
                                            </a>
                                        `).join('')}
                                    </div>
                                </div>
                            ` : '';
                    return `
                            <div id="card_${d.id}" class="driver-card ${selectedDrivers.some(s => s.id === d.id) ? 'selected' : ''}" 
                                draggable="true"
                                ondragstart="handleDragStart(event, '${d.id}')"
                                ondragend="handleDragEnd(event)"
                                onclick="openDriverDetails('${d.id}')">
                                <span class="driver-tag" style="background:${d.tagColor}; color:${d.textColor}">Customized</span>
                                <div class="driver-title">${d.title}</div>
                                <div class="driver-desc">${d.desc}</div>
                                ${sourcesHtml}
                            </div>
                            `;
                }).join('')}
                    </div>
                `;
            } container.innerHTML = html;
        }

        // --- 3. MODAL LOGIC ---
        let currentModalDriverId = null;

        function openDriverDetails(id) {
            currentModalDriverId = id;
            const driver = INITIAL_DRIVERS.find(d => d.id === id);
            if (!driver) return;

            document.getElementById('modalTitle').innerText = driver.title;

            // Build description with heat map assessment if available
            const hmData = heatMapData[id];
            let descContent = driver.desc;

            if (hmData && (hmData.likelihoodReasoning || hmData.materialityReasoning || hmData.reasoning)) {
                // Add heat map assessment section with separate justifications
                const likelihoodLevel = getLevelLabel(hmData.likelihood);
                const materialityLevel = getLevelLabel(hmData.materiality);
                const velocityLabel = hmData.velocity === 3 ? 'High' : hmData.velocity === 2 ? 'Medium' : 'Low';

                descContent += `\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nðŸ“Š HEAT MAP ASSESSMENT:\n`;
                descContent += `\nðŸ“ˆ Likelihood: ${likelihoodLevel} (${hmData.likelihood}/10)`;
                if (hmData.likelihoodReasoning) {
                    descContent += `\n   â†’ ${hmData.likelihoodReasoning}`;
                }
                descContent += `\n\nðŸ’¥ Materiality: ${materialityLevel} (${hmData.materiality}/10)`;
                if (hmData.materialityReasoning) {
                    descContent += `\n   â†’ ${hmData.materialityReasoning}`;
                }
                descContent += `\n\nâš¡ Velocity: ${velocityLabel}`;
                if (hmData.reasoning) {
                    descContent += `\n   â†’ ${hmData.reasoning}`;
                }
            }

            document.getElementById('modalDesc').innerText = descContent;
            const tag = document.getElementById('modalTag');
            tag.innerText = driver.cat;
            tag.style.background = driver.tagColor;
            tag.style.color = driver.textColor;

            renderChat(driver);

            const btn = document.getElementById('modalActionBtn');
            const isSelected = selectedDrivers.some(d => d.id === id);
            btn.innerText = isSelected ? "Remove from Scenario" : "Add to Scenario";
            btn.style.background = isSelected ? "#DC2626" : "var(--primary)";

            // Show delete button only for custom drivers
            const deleteBtn = document.getElementById('deleteDriverBtn');
            deleteBtn.style.display = id.startsWith('cust_') ? 'inline-block' : 'none';

            document.getElementById('driverModal').style.display = 'flex';
        }

        function closeModal() {
            document.getElementById('driverModal').style.display = 'none';
            currentModalDriverId = null;
        }

        function toggleDriverFromModal() {
            if (!currentModalDriverId) return;
            toggleDriver(currentModalDriverId);
            closeModal();
        }

        function generateContextualSuggestions(driver) {
            const suggestions = [];
            const text = (driver.title + " " + driver.desc).toLowerCase();

            // 1. Severity/Metric suggestions
            if (text.includes('inflation') || text.includes('cpi') || text.includes('price')) {
                suggestions.push('Adjust peak CPI inflation assumption (e.g., +200 bps shock)');
                suggestions.push('Model second-round effects on wage growth');
            }
            if (text.includes('gdp') || text.includes('recession') || text.includes('growth')) {
                suggestions.push('Specify depth of GDP contraction (e.g., -2.5%)');
                suggestions.push('Define recovery curve shape (V-shaped vs U-shaped)');
            }
            if (text.includes('unemployment') || text.includes('labor') || text.includes('jobs')) {
                suggestions.push('Define peak unemployment rate stress level');
            }
            if (text.includes('housing') || text.includes('real estate') || text.includes('mortgage')) {
                suggestions.push('Set magnitude of house price correction (e.g., -15%)');
                suggestions.push('Impact on uninsured mortgage portfolio LTVs');
            }
            if (text.includes('rate') || text.includes('yield') || text.includes('monetary')) {
                suggestions.push('Model parallel shift in yield curve (+100 bps)');
                suggestions.push('Test impact of "Higher for Longer" rate scenario');
            }

            // 2. Policy/Regulatory/Geopolitics
            if (driver.cat === 'Regulatory' || text.includes('osfi') || text.includes('capital')) {
                suggestions.push('Quantify impact on CET1 capital ratios');
                suggestions.push('Detail specific capital buffer (DSB) increases');
            }
            if (driver.cat === 'Geopolitical' || text.includes('trade') || text.includes('tariff')) {
                suggestions.push('Simulate specific tariff levels on key sectors');
                suggestions.push('Model disruption to cross-border supply chains');
            }

            // 3. Portfolio/Risk Type
            if (text.includes('credit') || text.includes('default') || text.includes('pcl')) {
                suggestions.push('Focus on Commercial Real Estate (CRE) loss rates');
                suggestions.push('Stress provision for credit losses (PCL) ratios');
            }
            if (text.includes('cyber') || text.includes('tech') || text.includes('ransomware')) {
                suggestions.push('Estimate operational loss magnitude');
                suggestions.push('Model reputational impact duration');
            }

            // Fallback generic suggestion if list is short
            if (suggestions.length < 2) {
                suggestions.push('Elaborate on transmission channels to earnings');
                suggestions.push('Quantify financial impact severity (Low/Medium/High)');
            }

            // Fallback generic suggestion if list is short
            if (suggestions.length < 3) {
                suggestions.push('Elaborate on transmission channels to RBC earnings');
            }

            return suggestions.slice(0, 3); // Return top 3
        }

        function renderChat(driver) {
            const chatHistory = document.getElementById('chatHistory');
            chatHistory.innerHTML = '';

            if (driver.chatHistory.length === 0) {
                // Use professional, banking-appropriate greeting
                const suggestions = generateContextualSuggestions(driver); // Use the new function

                chatHistory.innerHTML = `
                    <div class="chat-message ai">
                        <p style="margin: 0 0 8px 0;"><strong>Driver Refinement: "${driver.title}"</strong></p>
                        <p style="margin: 0 0 8px 0;">Risk parameters for this <em>${driver.cat}</em> driver are loaded. Please provide calibration instructions.</p>
                        <p style="margin: 8px 0 4px 0; font-size: 12px; color: #6b7280; text-transform: uppercase; font-weight: 700; letter-spacing: 0.5px;">SUGGESTED ACTIONS:</p>
                        <ul style="margin: 0 0 0 16px; padding: 0; font-size: 13px; color: #374151;">
                            ${suggestions.map(s => `<li style="margin-bottom: 4px;">${s}</li>`).join('')}
                        </ul>
                    </div>
                `;
            } else {
                driver.chatHistory.forEach(msg => {
                    const div = document.createElement('div');
                    div.className = `chat-message ${msg.role}`;

                    if (msg.role === 'ai') {
                        // Check if this is the OLD legacy greeting in history, and replace it on fly
                        if (msg.text.includes("AI Risk Analyst")) {
                            const suggestions = generateContextualSuggestions(driver);
                            div.innerHTML = `
                                <p style="margin: 0 0 8px 0;"><strong>Driver Refinement: "${driver.title}"</strong></p>
                                <p style="margin: 0 0 8px 0;">Risk parameters for this <em>${driver.cat}</em> driver are loaded. Please provide calibration instructions.</p>
                                <p style="margin: 8px 0 4px 0; font-size: 12px; color: #6b7280; text-transform: uppercase; font-weight: 700; letter-spacing: 0.5px;">SUGGESTED ACTIONS:</p>
                                <ul style="margin: 0 0 0 16px; padding: 0; font-size: 13px; color: #374151;">
                                    ${suggestions.map(s => `<li style="margin-bottom: 4px;">${s}</li>`).join('')}
                                </ul>
                            `;
                        } else {
                            div.innerHTML = msg.text.replace(/\n/g, '<br>');
                        }
                    } else {
                        div.innerText = msg.text;
                    }
                    chatHistory.appendChild(div);
                });
            }
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }

        function getContextualSuggestions(driver) {
            const baseSuggestions = [
                'Make it more severe or moderate',
                'Add specific quantitative impacts'
            ];

            const categorySuggestions = {
                'Macroeconomic': [
                    'Focus on GDP, inflation, or employment impacts',
                    'Add Bank of Canada policy response scenarios',
                    'Model transmission to consumer credit quality'
                ],
                'Geopolitical': [
                    'Specify trade flow disruptions and tariff impacts',
                    'Add supply chain contagion effects',
                    'Model currency and commodity price shocks'
                ],
                'Cyber / Tech': [
                    'Quantify potential operational downtime',
                    'Add reputational and regulatory fine estimates',
                    'Model customer attrition from service disruption'
                ],
                'Financial': [
                    'Add credit spread widening assumptions',
                    'Model mark-to-market losses on securities',
                    'Specify provisions for credit losses (PCL) increase'
                ],
                'Environmental': [
                    'Add insurance and reinsurance cost impacts',
                    'Model stranded asset valuations',
                    'Specify geographic concentration risks'
                ],
                'Social': [
                    'Model consumer behavior and spending shifts',
                    'Add housing demand and price assumptions',
                    'Quantify labor market disruption'
                ],
                'Regulatory': [
                    'Add compliance cost and timeline estimates',
                    'Model capital requirement changes',
                    'Specify affected business lines and products'
                ]
            };

            const catSuggestions = categorySuggestions[driver.cat] || [
                'Adjust the severity level',
                'Focus on specific RBC business lines',
                'Add Canadian market context'
            ];

            return [...baseSuggestions, ...catSuggestions.slice(0, 3)];
        }

        function handleChatEnter(e) {
            if (e.key === 'Enter') sendChatMessage();
        }

        async function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const val = input.value.trim();
            if (!val || !currentModalDriverId) return;

            const driver = INITIAL_DRIVERS.find(d => d.id === currentModalDriverId);
            if (!driver) return;

            // Add user message to history
            driver.chatHistory.push({ role: 'user', text: val });
            renderChat(driver);
            input.value = '';
            input.disabled = true;

            // Show typing indicator
            const chatHistoryEl = document.getElementById('chatHistory');
            const typingDiv = document.createElement('div');
            typingDiv.className = 'chat-message ai';
            typingDiv.style.fontStyle = 'italic';
            typingDiv.id = 'typingIndicator';
            typingDiv.innerText = 'Analyzing and refining...';
            chatHistoryEl.appendChild(typingDiv);
            chatHistoryEl.scrollTop = chatHistoryEl.scrollHeight;

            try {
                // Build conversation history for context
                const conversationHistory = driver.chatHistory.map(msg => ({
                    role: msg.role === 'user' ? 'user' : 'assistant',
                    content: msg.text
                }));

                // Get heat map data if available
                const hmData = heatMapData[driver.id];
                const hasHeatMapData = hmData && (hmData.likelihoodReasoning || hmData.materialityReasoning || hmData.reasoning);

                let heatMapContext = '';
                if (hasHeatMapData) {
                    heatMapContext = `

HEAT MAP ASSESSMENT:
- Likelihood: ${hmData.likelihood}/10${hmData.likelihoodReasoning ? ` (${hmData.likelihoodReasoning})` : ''}
- Materiality (Impact to RBC): ${hmData.materiality}/10${hmData.materialityReasoning ? ` (${hmData.materialityReasoning})` : ''}
- Velocity: ${hmData.velocity} (1=slow, 2=medium, 3=fast)${hmData.reasoning ? ` (${hmData.reasoning})` : ''}`;
                }

                // Create AI prompt with dual mode: Q&A vs Editing
                const systemPrompt = `You are an expert financial risk analyst helping users understand and refine risk drivers for stress testing scenarios at Royal Bank of Canada (RBC).

CURRENT RISK DRIVER:
- Title: "${driver.title}"
- Category: "${driver.cat}"
- Description: "${driver.desc}"${heatMapContext}

YOUR ROLE - TWO MODES:

**MODE 1: Q&A (DEFAULT)**
If the user asks questions like "what does this mean?", "why is this important?", "how does this affect RBC?", etc.:
- Provide helpful explanations and answers
- Do NOT modify the driver
- Do NOT include any JSON in your response
- Just have a natural conversation

**MODE 2: EDITING**
If the user explicitly asks to CHANGE, UPDATE, MODIFY, or ADJUST something:
- For description/title changes: Update and return JSON with new values
- For heat map assessment changes (likelihood/materiality/velocity): Update the scores
- Provide brief explanation of changes

EDITING FORMAT:
When making changes, respond with:
1. Brief explanation (2-3 sentences)
2. JSON block with updates:

\`\`\`json
{
  "title": "New title (only if changed)",
  "desc": "New description (only if changed)",
  "likelihood": 7,  // 1-10, only if heat map exists and user requests change
  "materiality": 8,  // 1-10, only if heat map exists and user requests change
  "velocity": 2,     // 1-3, only if heat map exists and user requests change
  "likelihoodReasoning": "Brief justification for the likelihood score",
  "materialityReasoning": "Brief justification for the materiality score",
  "reasoning": "Brief explanation for velocity and overall assessment"
}
\`\`\`

Only include fields that are being changed. Omit fields that stay the same.

CONFIRMATION:
If the user's intent is unclear (could be Q&A or editing), ask them to clarify before making changes.

KEY PHRASES THAT INDICATE EDITING:
- "change the", "update the", "modify the", "adjust the", "make it more/less"
- "increase/decrease likelihood", "set materiality to", "change velocity"
- "rewrite", "revise", "fix"

KEY PHRASES THAT INDICATE Q&A:
- "what", "why", "how", "explain", "tell me about", "what does this mean"
- "why is this risky", "how does this impact", "what are the implications"`;

                const response = await fetch(AZURE_OPENAI_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-5-2025-08-07-eastus-dz',
                        messages: [
                            { role: 'system', content: systemPrompt },
                            ...conversationHistory
                        ],
                        // temperature omitted - GPT-5 only supports default value of 1
                        max_tokens: 20000
                    })
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const data = await response.json();
                const aiResponse = data.choices[0].message.content;

                // Remove typing indicator
                const typingIndicator = document.getElementById('typingIndicator');
                if (typingIndicator) typingIndicator.remove();

                // Parse AI response to extract updates (if any)
                let updates = null;
                let explanationText = aiResponse;

                // Try to extract JSON from the response
                const jsonMatch = aiResponse.match(/```json\s*([\s\S]*?)\s*```/);
                if (jsonMatch) {
                    try {
                        updates = JSON.parse(jsonMatch[1]);
                        // Get explanation text (everything before the JSON block)
                        explanationText = aiResponse.substring(0, aiResponse.indexOf('```json')).trim();
                    } catch (e) {
                        console.error('Failed to parse update JSON:', e);
                    }
                }

                let needsRerender = false;
                let needsHeatMapUpdate = false;

                // Apply updates if we got valid JSON
                if (updates) {
                    // Update driver description/title
                    if (updates.title) {
                        driver.title = updates.title;
                        document.getElementById('modalTitle').innerText = driver.title;
                        needsRerender = true;
                    }
                    if (updates.desc) {
                        driver.desc = updates.desc;
                        // Will update modal desc below after heat map check
                        needsRerender = true;
                    }

                    // Update heat map assessment if provided
                    const currentHmData = heatMapData[driver.id];
                    if (currentHmData && (updates.likelihood || updates.materiality || updates.velocity || updates.reasoning || updates.likelihoodReasoning || updates.materialityReasoning)) {
                        if (updates.likelihood) {
                            currentHmData.likelihood = Math.max(1, Math.min(10, updates.likelihood));
                            needsHeatMapUpdate = true;
                        }
                        if (updates.materiality) {
                            currentHmData.materiality = Math.max(1, Math.min(10, updates.materiality));
                            needsHeatMapUpdate = true;
                        }
                        if (updates.velocity) {
                            currentHmData.velocity = Math.max(1, Math.min(3, updates.velocity));
                            needsHeatMapUpdate = true;
                        }
                        if (updates.likelihoodReasoning) {
                            currentHmData.likelihoodReasoning = updates.likelihoodReasoning;
                        }
                        if (updates.materialityReasoning) {
                            currentHmData.materialityReasoning = updates.materialityReasoning;
                        }
                        if (updates.reasoning) {
                            currentHmData.reasoning = updates.reasoning;
                        }

                        console.log('âœ“ Heat map assessment updated:', currentHmData);
                    }

                    // Update modal description with latest heat map data
                    if (updates.desc || needsHeatMapUpdate) {
                        const updatedHmData = heatMapData[driver.id];
                        let descContent = driver.desc;

                        if (updatedHmData && (updatedHmData.likelihoodReasoning || updatedHmData.materialityReasoning || updatedHmData.reasoning)) {
                            const likelihoodLevel = getLevelLabel(updatedHmData.likelihood);
                            const materialityLevel = getLevelLabel(updatedHmData.materiality);
                            const velocityLabel = updatedHmData.velocity === 3 ? 'High' : updatedHmData.velocity === 2 ? 'Medium' : 'Low';

                            descContent += `\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nðŸ“Š HEAT MAP ASSESSMENT:\n`;
                            descContent += `\nðŸ“ˆ Likelihood: ${likelihoodLevel} (${updatedHmData.likelihood}/10)`;
                            if (updatedHmData.likelihoodReasoning) {
                                descContent += `\n   â†’ ${updatedHmData.likelihoodReasoning}`;
                            }
                            descContent += `\n\nðŸ’¥ Materiality: ${materialityLevel} (${updatedHmData.materiality}/10)`;
                            if (updatedHmData.materialityReasoning) {
                                descContent += `\n   â†’ ${updatedHmData.materialityReasoning}`;
                            }
                            descContent += `\n\nâš¡ Velocity: ${velocityLabel}`;
                            if (updatedHmData.reasoning) {
                                descContent += `\n   â†’ ${updatedHmData.reasoning}`;
                            }
                        }

                        document.getElementById('modalDesc').innerText = descContent;
                    }

                    if (needsRerender) {
                        // Save updated driver to cache
                        saveToCache(`${DRIVERS_CACHE_KEY}_current`, INITIAL_DRIVERS);
                        console.log('âœ“ Driver updates saved to cache');
                    }
                }

                // Add AI response to chat history (explanation only, no JSON)
                const displayText = explanationText || (updates ? "Updates applied. Check the changes above." : aiResponse);
                driver.chatHistory.push({ role: 'ai', text: displayText });

                // Re-render components as needed
                renderChat(driver);
                if (needsRerender) {
                    renderMarketplace();
                    updateInventory();
                }
                if (needsHeatMapUpdate) {
                    renderHeatMap(); // Update heat map visual positions
                    renderHeatMapDriverList(); // Update driver list
                }

            } catch (error) {
                console.error('AI refinement error:', error);

                // Remove typing indicator
                const typingIndicator = document.getElementById('typingIndicator');
                if (typingIndicator) typingIndicator.remove();

                // Add error message to chat
                driver.chatHistory.push({
                    role: 'ai',
                    text: `Sorry, I encountered an error while processing your request: ${error.message}. Please try again.`
                });
                renderChat(driver);
            }

            input.disabled = false;
            input.focus();
        }

        // --- 4. DRIVER SELECTION ---
        function toggleDriver(id) {
            const card = document.getElementById(`card_${id}`);
            const driver = INITIAL_DRIVERS.find(d => d.id === id);
            if (!driver) return;

            const idx = selectedDrivers.findIndex(d => d.id === id);
            if (idx > -1) {
                selectedDrivers.splice(idx, 1);
                if (card) card.classList.remove('selected');
            } else {
                selectedDrivers.push(driver);
                if (card) card.classList.add('selected');
            }
            updateInventory();
        }

        function updateInventory() {
            const list = document.getElementById('inventoryList');
            const countEl = document.getElementById('count');
            const btn = document.getElementById('generateBtn');
            const heatMapBtn = document.getElementById('generateHeatMapBtn');

            countEl.innerText = selectedDrivers.length;
            btn.disabled = selectedDrivers.length === 0;
            if (heatMapBtn) {
                heatMapBtn.disabled = selectedDrivers.length === 0;
            }

            if (selectedDrivers.length === 0) {
                list.innerHTML = `
                    <div class="basket-empty">
                        <div class="basket-empty-icon">ðŸ›’</div>
                        <p>Your basket is empty.<br>Click drivers to add them.</p>
                    </div>
                `;
            } else {
                list.innerHTML = selectedDrivers.map(d => `
                    <div class="basket-item" onclick="openDriverDetails('${d.id}')">
                        <div class="basket-item-info">
                            <div class="basket-item-dot" style="background: ${d.textColor}"></div>
                            <span class="basket-item-title">${d.title}</span>
                        </div>
                        <span class="basket-remove" onclick="event.stopPropagation(); toggleDriver('${d.id}')">âœ•</span>
                    </div>
                `).join('');
            }
        }


        // --- 5. CUSTOM DRIVER CREATION ---
        function handleEnter(e) {
            if (e.key === 'Enter') createCustomDriver();
        }

        async function createCustomDriver() {
            const input = document.getElementById('aiInput');
            const query = input.value.trim();
            if (!query) return;

            const originalPlaceholder = input.placeholder;
            input.value = "";
            input.disabled = true;

            // Check if this is a hypothetical scenario (keywords: "hypothetical", "what if", "scenario:")
            const isHypothetical = /\b(hypothetical|what if|scenario:|imagine|suppose)\b/i.test(query);

            try {
                // Step 1: Search Tavily API for relevant information (skip for hypothetical scenarios)
                let tavilyResults = [];
                let usingTavily = false;

                if (!isHypothetical) {
                    input.placeholder = "ðŸ” Searching market intelligence...";
                    try {
                        tavilyResults = await fetchTavilySearch(query);
                        usingTavily = true;
                    } catch (tavilyError) {
                        console.warn('Tavily API failed, proceeding without market intelligence:', tavilyError);
                    }
                } else {
                    console.log('ðŸ“ Hypothetical scenario detected - skipping Tavily search');
                    input.placeholder = "ðŸ¤– Creating hypothetical scenario...";
                }

                // Step 2: Prepare context for AI
                input.placeholder = "ðŸ¤– AI is analyzing your request...";
                let sourcesSummary = '';

                if (tavilyResults && tavilyResults.length > 0) {
                    sourcesSummary = tavilyResults.slice(0, 5).map((r, idx) =>
                        `${idx + 1}. "${r.title}": ${r.content?.substring(0, 300) || 'No content available'}...`
                    ).join('\n\n');
                }

                // Step 3: Use AI to generate a structured risk driver
                console.log('ðŸ¤– Calling Azure OpenAI to generate risk driver...');

                const prompt = usingTavily && tavilyResults.length > 0
                    ? `You are an expert financial risk analyst at Royal Bank of Canada (RBC) specializing in FORWARD-LOOKING risk assessment for stress testing.

USER SEARCH QUERY: "${query}"

TAVILY SEARCH RESULTS (for context only):
${sourcesSummary}

CRITICAL INSTRUCTIONS - FORWARD-LOOKING RISK DRIVER:
1. Use the search results as CONTEXT about current/recent developments
2. DO NOT simply summarize what has already happened
3. Focus on what COULD HAPPEN NEXT - potential escalation, contagion, or deterioration
4. Project 6-12 months forward: "If current trends continue/worsen, what are the risks?"
5. Describe TRANSMISSION CHANNELS: How does this evolve into an RBC/Canadian banking risk?
6. Quantify POTENTIAL impacts using conditional language ("could lead to...", "may result in...")

EXAMPLES OF FORWARD-LOOKING FRAMING:
âŒ BAD (backward-looking): "Inflation reached 3.5% in Q4 2025"
âœ… GOOD (forward-looking): "Persistent inflation above 3.5% could force aggressive BoC tightening, triggering mortgage defaults"

âŒ BAD: "Trade tensions between US and China escalated"
âœ… GOOD: "Escalating US-China trade war could disrupt Canadian exports, weaken CAD, and stress commodity-dependent loan portfolios"

Generate a FORWARD-LOOKING risk driver. Return a JSON object:

{
  "category": "Macroeconomic" | "Geopolitical" | "Cyber / Tech" | "Financial" | "Environmental" | "Social" | "Regulatory",
  "title": "Concise 4-8 word title focused on the FUTURE risk (e.g., 'Stagflation Triggers Wave of Mortgage Defaults')",
  "description": "50-100 word FORWARD-LOOKING description. Use conditional/future language ('could', 'may', 'if...then', 'would lead to'). Describe the following: escalation scenarios, contagion risks, transmission to RBC. Quantify potential impacts where possible.",
  "keyFindings": ["Forward-looking risk pathway 1", "Potential escalation scenario 2", "Transmission channel to RBC 3"],
  "suggestedRefinements": ["Refine severity assumptions", "Adjust time horizon"]
}

Return ONLY the JSON object.`
                    : `You are an expert financial risk analyst at Royal Bank of Canada (RBC) specializing in FORWARD-LOOKING risk assessment for stress testing.

USER REQUEST: "${query}"

${isHypothetical ? `This is a HYPOTHETICAL scenario for stress testing purposes. You do NOT need news sources or real events. Create a plausible, detailed FORWARD-LOOKING risk driver.

CRITICAL INSTRUCTIONS FOR HYPOTHETICAL SCENARIOS:
1. DO NOT search for or reference real news articles
2. DO NOT claim this event has happened or cite sources
3. Focus on what COULD HAPPEN if this scenario were to occur or escalate
4. Project forward: describe the evolution and contagion pathways
5. Describe TRANSMISSION CHANNELS to RBC and Canadian financial system (specific business lines, portfolios, funding sources)
6. Quantify POTENTIAL impacts using conditional language (e.g., "could widen credit spreads by +150-250 bps", "may trigger $X billion in provisions")
7. Make it realistic and actionable for stress testing` : `NOTE: Market intelligence is unavailable. Create a FORWARD-LOOKING risk driver based on financial risk expertise.

CRITICAL: Focus on FUTURE scenarios, not past events. Use conditional language to describe what COULD happen.`}

EXAMPLES OF FORWARD-LOOKING FRAMING:
âœ… "If [scenario] escalates, could lead to..."
âœ… "Contagion risk: may spread to [sector/geography]..."
âœ… "Potential impacts: credit spreads +X bps, provisions up $Y billion..."

Generate a FORWARD-LOOKING risk driver. Return a JSON object:

{
  "category": "Macroeconomic" | "Geopolitical" | "Cyber / Tech" | "Financial" | "Environmental" | "Social" | "Regulatory",
  "title": "Concise 4-8 word title focused on the FUTURE risk",
  "description": "50-100 word FORWARD-LOOKING description. Use conditional/future language ('could', 'may', 'if...then'). Describe NEXT 6-12 months: escalation pathways, contagion risks, transmission to RBC. ${isHypothetical ? 'Explain HOW scenario evolves and impacts specific RBC business lines. DO NOT claim this has happened.' : 'Be specific and actionable.'}",
  "keyFindings": ["${isHypothetical ? 'Escalation pathway 1 if scenario unfolds' : 'Forward-looking risk 1'}", "${isHypothetical ? 'Contagion risk 2' : 'Potential development 2'}", "${isHypothetical ? 'RBC transmission channel 3' : 'Future impact 3'}"],
  "suggestedRefinements": ["Adjust severity/time horizon", "Refine transmission assumptions"]
}

Return ONLY the JSON object.`;

                const response = await fetch(AZURE_OPENAI_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-5-2025-08-07-eastus-dz',
                        messages: [{ role: 'user', content: prompt }],
                        // temperature omitted - GPT-5 only supports default value of 1
                        max_tokens: 20000
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`Azure OpenAI API HTTP ${response.status}:`, errorText);
                    throw new Error(`Azure OpenAI API error: ${response.status}`);
                }

                const data = await response.json();
                console.log('âœ“ Azure OpenAI response received');
                const aiResponse = data.choices[0].message.content;

                // Parse AI response
                let driverData;
                try {
                    const jsonMatch = aiResponse.match(/```json\s*([\s\S]*?)\s*```/) ||
                        aiResponse.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        driverData = JSON.parse(jsonMatch[1] || jsonMatch[0]);
                    } else {
                        throw new Error('No JSON in response');
                    }
                } catch (e) {
                    console.error('Parse error:', e);
                    throw new Error('Failed to parse AI response');
                }

                // Step 4: Create the driver object
                const newId = 'cust_' + Date.now();
                // Custom drivers always go under "Customized" category
                const customCategory = 'Customized';
                const colors = { tagColor: '#CFFAFE', textColor: '#0E7490' }; // Teal/Cyan - unique color

                // Build initial chat message with context
                const keyFindingsHtml = driverData.keyFindings?.map(f => `â€¢ ${f}`).join('<br>') || '';
                const refinementsHtml = driverData.suggestedRefinements?.map(r => `â€¢ ${r}`).join('<br>') || '';

                const initialChatMessage = usingTavily && tavilyResults.length > 0
                    ? `I've created a <strong>FORWARD-LOOKING</strong> risk driver based on ${tavilyResults.length} sources about "${query}".

<strong>Projected Risk Pathways (Next 6-12 months):</strong><br>${keyFindingsHtml}

<strong>You can refine this driver by asking me to:</strong><br>${refinementsHtml}

Or tell me to adjust severity, time horizon, or transmission assumptions (e.g., "make it more severe", "focus on 3-month horizon", "quantify credit spread impact").`
                    : isHypothetical
                        ? `I've created a <strong>HYPOTHETICAL FORWARD-LOOKING</strong> risk driver: "${query}".

âš ï¸ <strong>Note:</strong> This is a scenario-based driver for stress testing (no real-world sources required).

<strong>Potential Escalation Pathways:</strong><br>${keyFindingsHtml}

<strong>You can refine this scenario by asking me to:</strong><br>${refinementsHtml}

Or tell me to adjust severity, time horizon, or quantify specific impacts (e.g., "increase to 18-month scenario", "add credit spread widening +200 bps").`
                        : `I've created a <strong>FORWARD-LOOKING</strong> risk driver based on your request: "${query}".

<strong>âš ï¸ Note:</strong> This driver was created without live market intelligence (Tavily unavailable).

<strong>Projected Risk Developments:</strong><br>${keyFindingsHtml}

<strong>You can refine this driver by asking me to:</strong><br>${refinementsHtml}

Or tell me to adjust severity, time horizon, or transmission channels.`;

                const newDriver = {
                    id: newId,
                    cat: customCategory,
                    title: driverData.title || query.split(' ').slice(0, 5).join(' '),
                    desc: driverData.description || `Risk driver based on "${query}".`,
                    tagColor: colors.tagColor,
                    textColor: colors.textColor,
                    chatHistory: [
                        { role: 'ai', text: initialChatMessage }
                    ],
                    tavilyContext: tavilyResults && tavilyResults.length > 0 ? tavilyResults : [] // Store for potential future refinement
                };

                INITIAL_DRIVERS.push(newDriver);
                saveCustomDrivers(); // Persist custom drivers to localStorage
                renderMarketplace();

                const successMessage = usingTavily && tavilyResults.length > 0
                    ? "âœ“ Driver created with market intelligence!"
                    : isHypothetical
                        ? "âœ“ Hypothetical scenario created!"
                        : "âœ“ Driver created (without Tavily data)";

                input.placeholder = successMessage;
                setTimeout(() => { input.placeholder = originalPlaceholder; }, 3000);

                openDriverDetails(newId);

            } catch (error) {
                console.error('Custom driver creation error:', error);
                input.placeholder = `Error: ${error.message}. Try again.`;
                setTimeout(() => { input.placeholder = originalPlaceholder; }, 3000);
            } finally {
                input.disabled = false;
            }
        }

        // --- 6. SCENARIO GENERATION (AI-Powered) ---
        async function generateScenario() {
            const loader = document.getElementById('loader');
            const loaderText = document.getElementById('loaderText');

            if (selectedDrivers.length === 0) {
                alert('Please select at least one risk driver.');
                return;
            }

            loader.style.display = 'flex';
            loaderText.innerText = 'Fetching baseline macro data...';

            try {
                // Determine current period info for baseline data
                const currentPeriodInfo = {
                    quarter: `Q${Math.ceil((new Date().getMonth() + 1) / 3)}`,
                    year: new Date().getFullYear()
                };

                // Fetch baseline macro data from CSV
                const baselineMacroData = await fetchBaselineMacroData(currentPeriodInfo);

                // Build baseline context for AI prompt and extract numeric values
                let baselineContext = '';
                let baselineNumericValues = {};

                if (baselineMacroData && baselineMacroData.values) {
                    const vals = baselineMacroData.values;

                    // Extract numeric values from formatted strings
                    const extractNumeric = (val) => {
                        if (!val) return null;
                        const match = val.match(/^([+-]?\d+\.?\d*)/);
                        return match ? parseFloat(match[1]) : null;
                    };

                    const extractQoQ = (val) => {
                        const match = val?.match(/QoQ:\s*([+-]?\d+\.\d+%)/);
                        return match ? match[1] : val;
                    };

                    const extractQoQNumeric = (val) => {
                        const match = val?.match(/QoQ:\s*([+-]?\d+\.\d+)/);
                        return match ? parseFloat(match[1]) : null;
                    };

                    // Store numeric baseline values for later delta calculation
                    baselineNumericValues = {
                        gdp: extractQoQNumeric(vals['Canada GDP']),
                        unemployment: extractNumeric(vals['Unemployment Rate']),
                        inflation: extractNumeric(vals['CPI Inflation']),
                        cadUsd: extractNumeric(vals['CAD/USD']),
                        bocRate: extractNumeric(vals['BoC Rate']),
                        hpi: extractQoQNumeric(vals['House Price Index']),
                        tsx: extractQoQNumeric(vals['TSX Composite']),
                        creditSpreads: extractNumeric(vals['Credit Spreads'])
                    };

                    console.log('ðŸ“Š Extracted baseline numeric values:', baselineNumericValues);

                    baselineContext = `
BASELINE MACROECONOMIC DATA (${currentPeriodInfo.quarter} ${currentPeriodInfo.year}):
- Canada GDP Growth (QoQ): ${extractQoQ(vals['Canada GDP']) || 'N/A'}
- Unemployment Rate: ${vals['Unemployment Rate'] || 'N/A'}
- CPI Inflation: ${vals['CPI Inflation'] || 'N/A'}
- USD/CAD Exchange Rate: ${vals['CAD/USD'] || 'N/A'} (CAD per 1 USD - higher = weaker CAD)
- Bank of Canada Policy Rate: ${vals['BoC Rate'] || 'N/A'}
- House Price Index (QoQ): ${extractQoQ(vals['House Price Index']) || 'N/A'}
- TSX Composite (QoQ): ${extractQoQ(vals['TSX Composite']) || 'N/A'}
- Credit Spreads (10Y BBB): ${vals['Credit Spreads'] || 'N/A'}

These are reference values for context only. Generate stress projections as absolute values; the system will calculate deltas automatically.

CRITICAL: For USD/CAD, use the format "1.XX" (CAD per 1 USD). For example, 1.45 means 1 USD = 1.45 CAD. Higher values = weaker CAD, lower values = stronger CAD.
`;
                }

                // Store for post-processing
                window.currentBaselineValues = baselineNumericValues;

                loaderText.innerText = 'Preparing scenario analysis...';

                // Build driver summary for the AI
                const driversSummary = selectedDrivers.map((d, idx) =>
                    `${idx + 1}. [${d.cat}] ${d.title}: ${d.desc}`
                ).join('\n');

                const prompt = `You are an expert financial risk analyst at Royal Bank of Canada (RBC). Generate a comprehensive stress testing scenario report based on the following risk drivers that have been selected and refined by the risk team.

${baselineContext}

SELECTED RISK DRIVERS:
${driversSummary}

Generate a cohesive scenario narrative that combines these drivers into a plausible stress scenario. Your response must be a valid JSON object with the following structure:

{
  "scenarioTitle": "A compelling 3-6 word title for the scenario (e.g., 'Perfect Storm 2026' or 'Global Trade Collapse')",
  "globalConditions": {
    "summary": "3-4 paragraphs (HTML formatted with <p> tags and <strong> for emphasis) describing global economic and geopolitical conditions that set the stage for this scenario. Reference specific drivers where relevant.",
    "keyPoints": ["Point 1", "Point 2", "Point 3"]
  },
  "canadianConditions": {
    "summary": "3-4 paragraphs (HTML formatted) describing how these global conditions specifically impact the Canadian economy, housing market, energy sector, and Bank of Canada policy.",
    "keyPoints": ["Point 1", "Point 2", "Point 3"]
  },
  "rbcImpact": {
    "summary": "3-4 paragraphs (HTML formatted) describing the direct impact on RBC's business lines including: Personal & Commercial Banking (mortgages, credit cards), Capital Markets (trading, underwriting), Wealth Management (AUM), and overall capital/liquidity position.",
    "keyPoints": ["Point 1", "Point 2", "Point 3"]
  },
  "macroProjections": {
    "canadaGDP": { "value": "-X.X%" },
    "unemployment": { "value": "X.X%" },
    "inflation": { "value": "X.X%" },
    "usdCad": { "value": "1.XX" },
    "bocRate": { "value": "X.X%" },
    "housePrice": { "value": "-XX%" },
    "tsx": { "value": "-XX%" },
    "creditSpreads": { "value": "XXX" }
  }
  
IMPORTANT: Only provide the STRESS/PROJECTION values. Do NOT include delta or direction fields. The system will automatically calculate deltas from baseline.

CRITICAL: For usdCad, use format "1.XX" representing CAD per 1 USD (e.g., 1.45 means 1 USD = 1.45 CAD). Higher values = weaker CAD.
}

CRITICAL GUIDELINES FOR MACRO PROJECTIONS:
1. **Economic Coherence**: Ensure all variables move in economically consistent ways:
   - GDP contraction â†’ Unemployment rises, TSX falls, House prices fall, Credit spreads widen
   - CAD typically weakens in recession (lower commodity demand, risk-off)
   - BoC cuts rates aggressively in recession to stimulate economy
   - Inflation: Falls in demand-driven recession, but can rise in stagflation (supply shocks + weak growth)
   
2. **Severity Calibration** (use these as guides):
   - **Mild recession**: GDP -1% to -2%, Unemp 6.5-7.5%, HPI -5 to -10%, TSX -10 to -15%
   - **Moderate recession**: GDP -2.5% to -4%, Unemp 7.5-9%, HPI -12 to -20%, TSX -18 to -25%
   - **Severe recession**: GDP -4.5% to -6%+, Unemp 9-11%+, HPI -22 to -30%+, TSX -28 to -35%+
   - **Stagflation**: GDP -2 to -3%, Unemp 7-9%, Inflation 4-6%+, HPI -10 to -18%
   
3. **Variable Relationships** (maintain these correlations):
   - GDP vs Unemployment: Roughly -2:1 ratio (e.g., -3% GDP â†’ +1.5% unemployment increase)
   - GDP vs TSX: TSX typically falls 5-7x GDP contraction (e.g., -3% GDP â†’ -18% TSX)
   - GDP vs House Prices: HPI falls 4-6x GDP contraction (e.g., -3% GDP â†’ -15% HPI)
   - BoC Rate: Cut 25-50 bps per 1% GDP contraction expected
   - Credit Spreads: Widen 50-100 bps in moderate stress, 150-300 bps in severe stress
   


IMPORTANT GUIDELINES:
- Make the macro projections realistic and internally consistent with the scenario severity
- For a moderate scenario: GDP -1.5% to -3%, unemployment 6-8%
- For a severe scenario: GDP -3% to -6%, unemployment 8-10%
- For a very severe scenario: GDP -7% or worse, unemployment 10%+
- Ensure the narrative logically connects the selected drivers
- Reference actual Canadian/RBC context (Big 6 banks, OSFI regulations, BoC policy)

CRITICAL ANTI-HALLUCINATION RULES FOR SCENARIO NARRATIVE:
1. **NO INVENTED POLICY ACTIONS**: Do NOT fabricate central bank actions (e.g., "successive interest rate hikes by the Bank of Canada"). Only reference policy actions explicitly mentioned in the selected risk drivers or baseline data.
2. **DRIVER-BASED ONLY**: Every claim in the narrative must trace back to one of the selected risk drivers. Do not add generic industry commentary or fabricated events.
3. **NO SPECULATION BEYOND DRIVERS**: Only project what logically follows from the selected drivers. Do not invent additional crises, bank failures, or events not implied by the drivers.
4. **BASELINE ACCURACY**: Use the provided baseline macro data accurately. Do not invent baseline values or trends.
5. **REAL ENTITIES ONLY**: Reference only real institutions (RBC, Bank of Canada, OSFI, Big 6 banks). Do not invent fictional banks, regulations, or policies.

Return ONLY the JSON object, no additional text or markdown formatting.`;

                loaderText.innerText = 'AI is generating scenario narrative...';

                const response = await fetch(AZURE_OPENAI_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-5-2025-08-07-eastus-dz',
                        messages: [{ role: 'user', content: prompt }],
                        // temperature omitted - GPT-5 only supports default value of 1
                        max_tokens: 20000
                    })
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                loaderText.innerText = 'Processing scenario data...';

                const data = await response.json();
                const aiResponse = data.choices[0].message.content;

                // Parse the JSON response
                let scenario;
                try {
                    // Try to extract JSON if wrapped in markdown
                    const jsonMatch = aiResponse.match(/```json\s*([\s\S]*?)\s*```/) ||
                        aiResponse.match(/```\s*([\s\S]*?)\s*```/);
                    if (jsonMatch) {
                        scenario = JSON.parse(jsonMatch[1]);
                    } else {
                        scenario = JSON.parse(aiResponse);
                    }
                } catch (parseError) {
                    console.error('Failed to parse scenario JSON:', parseError);
                    console.log('Raw response:', aiResponse);
                    throw new Error('Failed to parse AI response');
                }

                // POST-PROCESS: Calculate macro deltas and directions from baseline values
                console.log('ðŸ“Š Checking post-processing conditions...');
                console.log('   - scenario.macroProjections exists?', !!scenario.macroProjections);
                console.log('   - baselineNumericValues exists?', !!baselineNumericValues);
                console.log('   - baselineNumericValues content:', baselineNumericValues);

                if (scenario.macroProjections && baselineNumericValues && Object.keys(baselineNumericValues).length > 0) {
                    const macro = scenario.macroProjections;

                    console.log('ðŸ“Š Post-processing macro projections with baselines:', baselineNumericValues);
                    console.log('ðŸ“Š AI-generated macro projections:', macro);

                    // Helper to extract numeric value from string (handles "X.X%" or "X.X" formats)
                    const extractNumber = (val) => {
                        if (typeof val === 'number') return val;
                        if (typeof val === 'string') {
                            const cleaned = val.replace(/[^\d.-]/g, '');
                            return parseFloat(cleaned);
                        }
                        return NaN;
                    };

                    // Canada GDP - calculate delta from baseline
                    if (macro.canadaGDP && macro.canadaGDP.value) {
                        const gdpValue = extractNumber(macro.canadaGDP.value);
                        console.log('GDP value:', macro.canadaGDP.value, 'â†’', gdpValue);
                        if (!isNaN(gdpValue)) {
                            const absDelta = Math.abs(gdpValue).toFixed(1);
                            macro.canadaGDP.delta = `â†“ ${absDelta}% from current`;
                            macro.canadaGDP.direction = 'negative';
                        }
                    }

                    // Unemployment - calculate delta from actual baseline
                    if (macro.unemployment && macro.unemployment.value && baselineNumericValues.unemployment) {
                        const stressValue = extractNumber(macro.unemployment.value);
                        const baselineValue = baselineNumericValues.unemployment;
                        console.log('Unemployment:', macro.unemployment.value, 'â†’', stressValue, 'vs baseline', baselineValue);
                        if (!isNaN(stressValue)) {
                            const delta = stressValue - baselineValue;
                            const arrow = delta > 0 ? 'â†‘' : 'â†“';
                            macro.unemployment.delta = `${arrow} to ${stressValue.toFixed(1)}% from ${baselineValue.toFixed(1)}%`;
                            macro.unemployment.direction = delta > 0 ? 'negative' : 'positive';
                        }
                    }

                    // CPI Inflation - calculate delta from actual baseline
                    if (macro.inflation && macro.inflation.value && baselineNumericValues.inflation) {
                        const stressValue = extractNumber(macro.inflation.value);
                        const baselineValue = baselineNumericValues.inflation;
                        console.log('Inflation:', macro.inflation.value, 'â†’', stressValue, 'vs baseline', baselineValue);
                        if (!isNaN(stressValue)) {
                            const delta = stressValue - baselineValue;
                            const arrow = delta > 0 ? 'â†‘' : 'â†“';
                            macro.inflation.delta = `${arrow} to ${stressValue.toFixed(1)}% from ${baselineValue.toFixed(1)}%`;
                            // High inflation is bad (negative), low inflation is good (positive) in stress context
                            macro.inflation.direction = delta > 0 ? 'negative' : 'positive';
                        }
                    }

                    // USD/CAD - calculate delta from actual baseline (support both usdCad and cadUsd keys)
                    const usdCadData = macro.usdCad || macro.cadUsd;
                    if (usdCadData && usdCadData.value && baselineNumericValues.cadUsd) {
                        const stressValue = extractNumber(usdCadData.value);
                        const baselineValue = baselineNumericValues.cadUsd;
                        console.log('USD/CAD:', usdCadData.value, 'â†’', stressValue, 'vs baseline', baselineValue);
                        if (!isNaN(stressValue)) {
                            const delta = stressValue - baselineValue;
                            const arrow = delta > 0 ? 'â†‘' : 'â†“';
                            usdCadData.delta = `${arrow} to ${stressValue.toFixed(2)} from ${baselineValue.toFixed(2)}`;
                            // Weaker CAD (higher USD/CAD) is generally negative
                            usdCadData.direction = delta > 0 ? 'negative' : 'positive';
                        }
                        // Ensure both keys point to same object for compatibility
                        if (macro.usdCad) macro.cadUsd = macro.usdCad;
                        if (macro.cadUsd && !macro.usdCad) macro.usdCad = macro.cadUsd;
                    }

                    // BoC Rate - calculate delta from actual baseline
                    if (macro.bocRate && macro.bocRate.value && baselineNumericValues.bocRate) {
                        const stressValue = extractNumber(macro.bocRate.value);
                        const baselineValue = baselineNumericValues.bocRate;
                        console.log('BoC Rate:', macro.bocRate.value, 'â†’', stressValue, 'vs baseline', baselineValue);
                        if (!isNaN(stressValue)) {
                            const deltaBps = Math.round((stressValue - baselineValue) * 100);
                            const arrow = deltaBps < 0 ? 'â†“' : 'â†‘';
                            macro.bocRate.delta = `${arrow} ${Math.abs(deltaBps)} bps to ${stressValue.toFixed(2)}% from ${baselineValue.toFixed(1)}%`;
                            // Rate cuts are typically positive in stress scenarios (stimulus)
                            macro.bocRate.direction = deltaBps < 0 ? 'positive' : 'negative';
                        }
                    }

                    // House Price Index - calculate delta
                    if (macro.housePrice && macro.housePrice.value) {
                        const hpiValue = extractNumber(macro.housePrice.value);
                        console.log('HPI:', macro.housePrice.value, 'â†’', hpiValue);
                        if (!isNaN(hpiValue)) {
                            macro.housePrice.delta = `â†“ ${Math.abs(hpiValue).toFixed(1)}% from current`;
                            macro.housePrice.direction = 'negative';
                        }
                    }

                    // TSX Composite - calculate delta
                    if (macro.tsx && macro.tsx.value) {
                        const tsxValue = extractNumber(macro.tsx.value);
                        console.log('TSX:', macro.tsx.value, 'â†’', tsxValue);
                        if (!isNaN(tsxValue)) {
                            macro.tsx.delta = `â†“ ${Math.abs(tsxValue).toFixed(1)}% from current`;
                            macro.tsx.direction = 'negative';
                        }
                    }

                    // Credit Spreads - calculate delta from actual baseline
                    if (macro.creditSpreads && macro.creditSpreads.value && baselineNumericValues.creditSpreads) {
                        const stressValue = extractNumber(macro.creditSpreads.value);
                        const baselineValue = baselineNumericValues.creditSpreads;
                        console.log('Credit Spreads:', macro.creditSpreads.value, 'â†’', stressValue, 'vs baseline', baselineValue);
                        if (!isNaN(stressValue)) {
                            const stressBps = Math.round(stressValue * 100);
                            const baselineBps = Math.round(baselineValue * 100);
                            const deltaBps = stressBps - baselineBps;
                            macro.creditSpreads.value = `+${stressBps} bps`;
                            macro.creditSpreads.delta = `â†‘ ${deltaBps} bps to +${stressBps} from ${baselineBps} bps`;
                            macro.creditSpreads.direction = 'negative';
                        }
                    }

                    console.log('ðŸ“Š Final processed macro projections:', macro);
                }

                loaderText.innerText = 'Rendering scenario report...';
                await new Promise(r => setTimeout(r, 500));

                // Store the generated scenario for later use
                window.currentGeneratedScenario = scenario;

                // Render the report
                renderAIReport(scenario);

            } catch (error) {
                console.error('Scenario generation error:', error);
                loaderText.innerText = `Error: ${error.message}. Falling back to default...`;
                await new Promise(r => setTimeout(r, 2000));

                // Fallback to static report
                generateFallbackReport();
            } finally {
                loader.style.display = 'none';
            }
        }

        function renderAIReport(scenario) {
            const driverCount = selectedDrivers.length;
            const now = new Date();
            const dateStr = now.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });

            // Set title and subtitle
            document.getElementById('reportTitle').innerText = scenario.scenarioTitle || 'Stress Test Scenario';
            document.getElementById('reportSubtitle').innerText = `Generated on ${dateStr} | Based on ${driverCount} Risk Drivers`;

            // Render selected drivers
            document.getElementById('reportDriversList').innerHTML = selectedDrivers.map(d => `
                <span class="driver-pill" style="background: ${d.tagColor}; color: ${d.textColor};">${d.title}</span>
            `).join('');

            // Render global conditions
            document.getElementById('globalConditions').innerHTML = scenario.globalConditions?.summary ||
                '<p>Global conditions analysis unavailable.</p>';

            // Render Canadian conditions
            document.getElementById('canadianConditions').innerHTML = scenario.canadianConditions?.summary ||
                '<p>Canadian conditions analysis unavailable.</p>';

            // Render RBC impact
            document.getElementById('rbcImpact').innerHTML = scenario.rbcImpact?.summary ||
                '<p>RBC impact analysis unavailable.</p>';

            // Render macro projections
            const macro = scenario.macroProjections || {};
            document.getElementById('macroProjections').innerHTML = `
                <div class="macro-card">
                    <div class="macro-label">Canada GDP</div>
                    <div class="macro-value ${macro.canadaGDP?.direction || 'negative'}">${macro.canadaGDP?.value || 'N/A'}</div>
                    <div class="macro-delta">${macro.canadaGDP?.delta || ''}</div>
                </div>
                <div class="macro-card">
                    <div class="macro-label">Unemployment</div>
                    <div class="macro-value ${macro.unemployment?.direction || 'negative'}">${macro.unemployment?.value || 'N/A'}</div>
                    <div class="macro-delta">${macro.unemployment?.delta || ''}</div>
                </div>
                <div class="macro-card">
                    <div class="macro-label">CPI Inflation</div>
                    <div class="macro-value ${macro.inflation?.direction || 'negative'}">${macro.inflation?.value || 'N/A'}</div>
                    <div class="macro-delta">${macro.inflation?.delta || ''}</div>
                </div>
                <div class="macro-card">
                    <div class="macro-label">USD/CAD</div>
                    <div class="macro-value ${(macro.usdCad || macro.cadUsd)?.direction || 'negative'}">${(macro.usdCad || macro.cadUsd)?.value || 'N/A'}</div>
                    <div class="macro-delta">${(macro.usdCad || macro.cadUsd)?.delta || ''}</div>
                </div>
                <div class="macro-card">
                    <div class="macro-label">BoC Rate</div>
                    <div class="macro-value ${macro.bocRate?.direction === 'positive' ? '' : 'negative'}">${macro.bocRate?.value || 'N/A'}</div>
                    <div class="macro-delta" style="${macro.bocRate?.direction === 'positive' ? 'color: #059669;' : ''}">${macro.bocRate?.delta || ''}</div>
                </div>
                <div class="macro-card">
                    <div class="macro-label">House Price Index</div>
                    <div class="macro-value ${macro.housePrice?.direction || 'negative'}">${macro.housePrice?.value || 'N/A'}</div>
                    <div class="macro-delta">${macro.housePrice?.delta || ''}</div>
                </div>
                <div class="macro-card">
                    <div class="macro-label">TSX Composite</div>
                    <div class="macro-value ${macro.tsx?.direction || 'negative'}">${macro.tsx?.value || 'N/A'}</div>
                    <div class="macro-delta">${macro.tsx?.delta || ''}</div>
                </div>
                <div class="macro-card">
                    <div class="macro-label">Credit Spreads</div>
                    <div class="macro-value ${macro.creditSpreads?.direction || 'negative'}">${macro.creditSpreads?.value || 'N/A'}</div>
                    <div class="macro-delta">${macro.creditSpreads?.delta || ''}</div>
                </div>
            `;

            // Generate context-aware initial chat message for the report
            // Clear conversation history for new scenario generation
            reportChatHistory = [];
            currentScenarioId = null; // Reset scenario ID for new scenario

            const contextualReportSuggestions = getReportContextualSuggestions(selectedDrivers, scenario, macro);

            const initialMessage = `
                <div class="chat-message ai">
                    <p style="margin: 0 0 8px 0;">ðŸ“Š Scenario <strong>"${scenario.scenarioTitle}"</strong> has been generated based on ${driverCount} selected risk drivers.</p>
                    <p style="margin: 0 0 8px 0; font-size: 12px; color: #6b7280;">Key projections: GDP ${macro.canadaGDP?.value || 'N/A'}, Unemployment ${macro.unemployment?.value || 'N/A'}, House Prices ${macro.housePrice?.value || 'N/A'}</p>
                    <p style="margin: 8px 0;">Based on the driver selection, consider:</p>
                    <ul style="margin: 8px 0 0 16px; padding: 0;">
                        ${contextualReportSuggestions.map(s => `<li>${s}</li>`).join('')}
                    </ul>
                </div>
            `;

            document.getElementById('reportChatHistory').innerHTML = initialMessage;

            document.getElementById('reportOverlay').style.display = 'flex';
        }

        function getReportContextualSuggestions(drivers, scenario, macro) {
            const suggestions = [];

            // Analyze driver categories
            const categories = drivers.map(d => d.cat);
            const uniqueCategories = [...new Set(categories)];

            // Base suggestions
            suggestions.push('Adjust overall scenario severity (moderate â†’ severe â†’ very severe)');

            // Category-specific suggestions
            if (categories.includes('Macroeconomic') || categories.includes('Financial')) {
                const gdpValue = parseFloat(macro.canadaGDP?.value) || -2;
                if (gdpValue > -2) {
                    suggestions.push('Increase GDP decline to model a deeper recession');
                } else {
                    suggestions.push('Add second-round effects on consumer spending');
                }
            }

            if (categories.includes('Geopolitical') || categories.includes('Trade & Geopolitics')) {
                suggestions.push('Elaborate on trade disruption impacts to Canadian exports');
            }

            if (categories.includes('Environmental') || categories.includes('Climate')) {
                suggestions.push('Add regional breakdowns for climate-related losses (BC, Alberta, Ontario)');
            }

            if (categories.includes('Cyber / Tech') || categories.includes('AI & Cyber')) {
                suggestions.push('Model operational risk and potential regulatory response');
            }

            if (categories.includes('Regulatory')) {
                suggestions.push('Detail OSFI supervisory response and capital actions');
            }

            // Housing-specific if relevant
            const hasHousingDrivers = drivers.some(d =>
                d.title.toLowerCase().includes('housing') ||
                d.title.toLowerCase().includes('mortgage') ||
                d.desc.toLowerCase().includes('housing') ||
                d.desc.toLowerCase().includes('mortgage')
            );
            if (hasHousingDrivers) {
                suggestions.push('Break down mortgage impacts by product type (fixed vs. variable)');
            }

            // Tone suggestion
            suggestions.push('Make the narrative more formal for executive presentation');

            // Return top 5 most relevant
            return suggestions.slice(0, 5);
        }

        function generateFallbackReport() {
            const driverCount = selectedDrivers.length;
            const now = new Date();
            const dateStr = now.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });

            document.getElementById('reportTitle').innerText = 'Stress Test Scenario Analysis';
            document.getElementById('reportSubtitle').innerText = `Generated on ${dateStr} | Based on ${driverCount} Risk Drivers`;

            document.getElementById('reportDriversList').innerHTML = selectedDrivers.map(d => `
                <span class="driver-pill" style="background: ${d.tagColor}; color: ${d.textColor};">${d.title}</span>
            `).join('');

            document.getElementById('globalConditions').innerHTML = `
                <p><strong>Trade Disruptions:</strong> Global trade patterns are experiencing significant stress from the selected risk drivers, contributing to supply chain disruptions and inflationary pressures.</p>
                <p style="margin-top: 12px;"><strong>Monetary Policy Divergence:</strong> Central banks face challenging policy decisions as they balance growth concerns against inflation risks.</p>
                <p style="margin-top: 12px;"><strong>Geopolitical Tensions:</strong> Heightened geopolitical uncertainty is affecting investor confidence and capital flows globally.</p>
            `;

            document.getElementById('canadianConditions').innerHTML = `
                <p><strong>Housing Market Stress:</strong> Canadian housing markets face headwinds from the selected risk factors, with potential price corrections in major metropolitan areas.</p>
                <p style="margin-top: 12px;"><strong>Economic Growth:</strong> GDP growth faces downside risks from external shocks and domestic vulnerabilities.</p>
                <p style="margin-top: 12px;"><strong>BoC Policy:</strong> The Bank of Canada must navigate between supporting growth and maintaining price stability.</p>
            `;

            document.getElementById('rbcImpact').innerHTML = `
                <p><strong>Credit Quality:</strong> The selected risk drivers would likely impact credit quality across retail and commercial portfolios.</p>
                <p style="margin-top: 12px;"><strong>Capital Position:</strong> Capital ratios may face pressure requiring proactive management actions.</p>
                <p style="margin-top: 12px;"><strong>Revenue Impact:</strong> Trading and fee-based revenues may experience volatility under stress conditions.</p>
            `;

            document.getElementById('macroProjections').innerHTML = `
                <div class="macro-card">
                    <div class="macro-label">Canada GDP</div>
                    <div class="macro-value negative">-2.0%</div>
                    <div class="macro-delta">â†“ from +1.2% baseline</div>
                </div>
                <div class="macro-card">
                    <div class="macro-label">Unemployment</div>
                    <div class="macro-value negative">8.5%</div>
                    <div class="macro-delta">â†‘ from 5.8% baseline</div>
                </div>
                <div class="macro-card">
                    <div class="macro-label">CPI Inflation</div>
                    <div class="macro-value negative">4.5%</div>
                    <div class="macro-delta">â†‘ from 2.4% baseline</div>
                </div>
                <div class="macro-card">
                    <div class="macro-label">CAD/USD</div>
                    <div class="macro-value negative">0.70</div>
                    <div class="macro-delta">â†“ from 0.74 baseline</div>
                </div>
                <div class="macro-card">
                    <div class="macro-label">BoC Rate</div>
                    <div class="macro-value">3.50%</div>
                    <div class="macro-delta" style="color: #059669;">â†“ from 5.0% (cuts)</div>
                </div>
                <div class="macro-card">
                    <div class="macro-label">House Price Index</div>
                    <div class="macro-value negative">-20%</div>
                    <div class="macro-delta">Peak-to-trough</div>
                </div>
                <div class="macro-card">
                    <div class="macro-label">TSX Composite</div>
                    <div class="macro-value negative">-25%</div>
                    <div class="macro-delta">From current levels</div>
                </div>
                <div class="macro-card">
                    <div class="macro-label">Credit Spreads</div>
                    <div class="macro-value negative">+150 bps</div>
                    <div class="macro-delta">IG corporate widening</div>
                </div>
            `;

            document.getElementById('reportChatHistory').innerHTML = `
                <div class="chat-message ai">
                    A baseline scenario has been generated based on ${driverCount} selected risk drivers. AI service was unavailable; this is a template report. Use the input below to request refinements to specific sections.
                </div>
            `;

            document.getElementById('reportOverlay').style.display = 'flex';
        }

        function closeReport() {
            document.getElementById('reportOverlay').style.display = 'none';

            // Clear selected drivers when closing (same as save)
            selectedDrivers = [];
            currentScenarioId = null;
            renderMarketplace(); // Re-render to show unselected state
            updateInventory(); // Update basket to show empty
        }

        function addMoreDriversToScenario() {
            // Keep the current scenario's drivers in selectedDrivers (they're already there from openSavedReport)
            // Close the report overlay
            document.getElementById('reportOverlay').style.display = 'none';

            // Navigate to marketplace with the drivers still in the basket
            showMarketplace();

            // Update the inventory/basket to show current drivers
            updateInventory();

            // Show a helpful message
            const driverCount = selectedDrivers.length;
            console.log(`âœ“ Editing scenario with ${driverCount} drivers. Select more drivers and regenerate.`);
        }

        // --- SCENARIO ASSISTANT NOTIFICATIONS ---
        function notifyScenarioAssistant(message) {
            const chatHistoryEl = document.getElementById('reportChatHistory');
            if (!chatHistoryEl) return;

            const notificationDiv = document.createElement('div');
            notificationDiv.className = 'chat-message ai';
            notificationDiv.style.background = '#FEF3C7';
            notificationDiv.style.color = '#92400E';
            notificationDiv.style.borderLeft = '4px solid #F59E0B';
            notificationDiv.innerText = message;
            chatHistoryEl.appendChild(notificationDiv);
            chatHistoryEl.scrollTop = chatHistoryEl.scrollHeight;
        }

        // --- 7. REPORT INTERACTION & SAVING ---
        let reportChatHistory = []; // Track report chat for context

        function handleReportChatEnter(e) {
            if (e.key === 'Enter') sendReportChatMessage();
        }

        async function sendReportChatMessage() {
            const input = document.getElementById('reportChatInput');
            const val = input.value.trim();
            if (!val) return;

            // Add User Message to UI
            const chatHistoryEl = document.getElementById('reportChatHistory');
            const userDiv = document.createElement('div');
            userDiv.className = 'chat-message user';
            userDiv.innerText = val;
            chatHistoryEl.appendChild(userDiv);
            chatHistoryEl.scrollTop = chatHistoryEl.scrollHeight;

            // Track in conversation history
            reportChatHistory.push({ role: 'user', content: val });

            input.value = '';
            input.disabled = true;

            // Show typing indicator
            const typingDiv = document.createElement('div');
            typingDiv.className = 'chat-message ai';
            typingDiv.style.fontStyle = 'italic';
            typingDiv.id = 'reportTypingIndicator';
            typingDiv.innerText = 'Analyzing and refining scenario...';
            chatHistoryEl.appendChild(typingDiv);
            chatHistoryEl.scrollTop = chatHistoryEl.scrollHeight;

            try {
                // Get current report state
                const currentReport = {
                    title: document.getElementById('reportTitle').innerText,
                    globalConditions: document.getElementById('globalConditions').innerHTML,
                    canadianConditions: document.getElementById('canadianConditions').innerHTML,
                    rbcImpact: document.getElementById('rbcImpact').innerHTML,
                    macroProjections: document.getElementById('macroProjections').innerHTML
                };

                const driversSummary = selectedDrivers.map((d, idx) =>
                    `${idx + 1}. [${d.cat}] ${d.title}: ${d.desc}`
                ).join('\n');

                // Get current macro projections from the UI
                const currentMacroValues = {};
                const macroCards = document.querySelectorAll('.macro-card');
                if (macroCards.length >= 8) {
                    currentMacroValues.gdp = macroCards[0]?.querySelector('.macro-value')?.innerText || 'N/A';
                    currentMacroValues.unemployment = macroCards[1]?.querySelector('.macro-value')?.innerText || 'N/A';
                    currentMacroValues.inflation = macroCards[2]?.querySelector('.macro-value')?.innerText || 'N/A';
                    currentMacroValues.usdCad = macroCards[3]?.querySelector('.macro-value')?.innerText || 'N/A';
                    currentMacroValues.bocRate = macroCards[4]?.querySelector('.macro-value')?.innerText || 'N/A';
                    currentMacroValues.housePrice = macroCards[5]?.querySelector('.macro-value')?.innerText || 'N/A';
                    currentMacroValues.tsx = macroCards[6]?.querySelector('.macro-value')?.innerText || 'N/A';
                    currentMacroValues.creditSpreads = macroCards[7]?.querySelector('.macro-value')?.innerText || 'N/A';
                }

                // Format baseline values for AI (if available)
                let baselineSection = '';
                if (window.currentBaselineValues) {
                    const bl = window.currentBaselineValues;
                    const formatNum = (num) => num != null ? num.toFixed(1) : 'N/A';
                    const formatNum2 = (num) => num != null ? num.toFixed(2) : 'N/A';
                    baselineSection = `
BASELINE MACROECONOMIC DATA (Current Economic Conditions):
- Canada GDP: QoQ Growth ${bl.gdp != null ? (bl.gdp >= 0 ? '+' : '') + formatNum(bl.gdp) + '%' : 'N/A'}
- Unemployment Rate: ${bl.unemployment != null ? formatNum(bl.unemployment) + '%' : 'N/A'}
- CPI Inflation: ${bl.inflation != null ? formatNum(bl.inflation) + '%' : 'N/A'}
- USD/CAD: ${bl.cadUsd != null ? formatNum2(bl.cadUsd) + ' (CAD per 1 USD)' : 'N/A'}
- BoC Rate: ${bl.bocRate != null ? formatNum(bl.bocRate) + '%' : 'N/A'}
- House Price Index: QoQ Growth ${bl.hpi != null ? (bl.hpi >= 0 ? '+' : '') + formatNum(bl.hpi) + '%' : 'N/A'}
- TSX Composite: QoQ Growth ${bl.tsx != null ? (bl.tsx >= 0 ? '+' : '') + formatNum(bl.tsx) + '%' : 'N/A'}
- Credit Spreads: ${bl.creditSpreads != null ? formatNum(bl.creditSpreads) + '%' : 'N/A'}

CURRENT STRESS SCENARIO PROJECTIONS:
- Canada GDP: ${currentMacroValues.gdp}
- Unemployment: ${currentMacroValues.unemployment}
- Inflation: ${currentMacroValues.inflation}
- USD/CAD: ${currentMacroValues.usdCad}
- BoC Rate: ${currentMacroValues.bocRate}
- House Prices: ${currentMacroValues.housePrice}
- TSX Composite: ${currentMacroValues.tsx}
- Credit Spreads: ${currentMacroValues.creditSpreads}

When adjusting macro variables, you MUST:
1. Calculate the actual change from BASELINE to your new projection
2. Explain the reasoning based on the DELTA from baseline, not absolute values
3. Example: If baseline BoC Rate is 2.5% and you project 2.0%, explain "BoC cuts rates by 50 bps (from 2.5% to 2.0%)"
`;
                }

                const systemPrompt = `You are an expert financial risk analyst at Royal Bank of Canada (RBC). You are helping to refine a stress testing scenario report.

SELECTED RISK DRIVERS:
${driversSummary}
${baselineSection}
CURRENT SCENARIO REPORT:
Title: ${currentReport.title}

Global Conditions (HTML):
${currentReport.globalConditions}

Canadian Conditions (HTML):
${currentReport.canadianConditions}

RBC Impact (HTML):
${currentReport.rbcImpact}

The user wants to refine this scenario. Based on their request, provide:
1. A brief conversational response explaining what you're changing (2-3 sentences)
2. If the user wants changes to a specific section, include the updated HTML in a JSON block

Your response should be in this format:
[Your conversational explanation here]

If making changes to sections, include:
\`\`\`json
{
  "updateSection": "global" | "canadian" | "rbc" | "macro" | "title" | null,
  "newContent": "HTML content for that section" or "New title text",
  "macroUpdates": {
    "canadaGDP": { "value": "-X.X%" },
    "unemployment": { "value": "X.X%" },
    "inflation": { "value": "X.X%" },
    "usdCad": { "value": "1.XX" },
    "bocRate": { "value": "X.XX%" },
    "housePrice": { "value": "-XX%" },
    "tsx": { "value": "-XX%" },
    "creditSpreads": { "value": "X.XX" }
  }
}
\`\`\`

IMPORTANT: For macro projections, ONLY provide the stress values. Do NOT include delta or direction fields. The system will automatically calculate deltas from baseline.

CRITICAL: For usdCad, use format "1.XX" representing CAD per 1 USD (e.g., 1.45 means 1 USD = 1.45 CAD). Higher values = weaker CAD, lower values = stronger CAD.

CRITICAL RULES FOR MACRO PROJECTIONS:

1. **ECONOMIC CORRELATIONS - MANDATORY**: Variables are economically linked and MUST move together:
   
   **When GDP Falls (More Negative)**:
   - Unemployment MUST RISE (â†‘) - businesses cut jobs when economy contracts
   - TSX MUST FALL (more negative â†“) - corporate earnings decline with GDP
   - House Prices MUST FALL (more negative â†“) - real estate weakens in recession
   - Credit Spreads MUST RISE (â†‘) - default risk increases in recession
   - Inflation: Depends on scenario type (see below)
   
   **When GDP Improves (Less Negative)**:
   - All correlations reverse: Unemploymentâ†“, TSXâ†‘, House Pricesâ†‘, Credit Spreadsâ†“

2. **Severity Adjustments**: 
   - **Single Variable Request** (e.g., "change GDP to -4%", "make GDP more severe"):
     * Adjust the specified variable to requested level
     * **MUST adjust economically correlated variables** proportionally based on the relationships above
     * **PRESERVE inflation direction** unless scenario type is explicitly changed
     * Use economic multipliers to determine magnitude of correlated adjustments
   
   - **Overall Severity Request** (e.g., "make entire scenario more severe", "dial everything back"):
     * Adjust ALL variables proportionally including inflation
     * Maintain current scenario type relationships
   
   - **Scenario Type Changes** (e.g., "make it a stagflation scenario", "convert to demand shock"):
     * This changes the fundamental narrative and inflation behavior
     * Explain the shift in scenario dynamics
   
3. **Inflation Handling - CRITICAL**:
   - **ALWAYS CHECK CURRENT INFLATION VALUE FIRST**
   - Stagflation = falling GDP + rising inflation (supply-driven crisis, cost-push)
   - Demand shock = falling GDP + falling inflation (consumption collapse, demand-pull reversal)
   - **When user adjusts GDP severity, PRESERVE the current inflation trajectory** (if rising, keep rising; if falling, keep falling)
   - Only change inflation direction if user explicitly requests scenario type change
   - Example: If inflation is 4.5% and user says "make GDP -4% instead of -3%", keep inflation at ~4.5% or slightly higher (stagflation worsening)
   
4. **Response Format & Explanation - MANDATORY**:

When adjusting macro projections, you MUST provide detailed economic reasoning BEFORE the JSON block:

**Required Explanation Structure:**

1. **User Request Summary**: "You've requested [specific change]"

2. **Economic Reasoning for EACH Variable**:
   - **GDP**: Explain the change and mechanism
   - **Unemployment**: "GDP fell by Xpp â†’ unemployment rises by Ypp because [job losses/hiring freeze]. Historical multiplier: ~0.6-0.8pp unemployment per 1pp GDP decline"
   - **TSX**: "GDP contraction worsens â†’ corporate earnings decline â†’ TSX falls from [old%] to [new%]. This represents a [X]% to [Y]% decline from baseline, proportional to GDP severity"
   - **House Prices**: "Deeper recession + higher unemployment â†’ housing demand falls â†’ prices decline from [old%] to [new%]"
   - **BoC Rate**: "BoC responds to deeper recession with [more aggressive/less aggressive] rate cuts: [old] â†’ [new]. In severe recessions, BoC typically cuts 25-50bps per quarter"
   - **USD/CAD**: "Rate differential with US Fed widens/narrows â†’ CAD [weakens/strengthens] to [new value]"
   - **Credit Spreads**: "Default risk [increases/decreases] as recession [deepens/moderates] â†’ spreads move from [old] to [new]"
   - **Inflation**: "**PRESERVING [stagflationary/disinflationary] TRAJECTORY** - Inflation [remains elevated/continues falling] at [value] because [supply-side pressures persist / demand destruction continues]"

3. **Magnitude Justification**:
   - Reference historical precedents (e.g., "Similar to 2008-2009 crisis")
   - Use economic multipliers (e.g., "1% deeper GDP decline â†’ 15% additional TSX decline")
   - Explain policy response logic

4. **Coherence Check**: "All variables now align with a [stagflationary/demand-driven] recession scenario"

**MANDATORY MACRO EXPLANATION FORMAT**:
When adjusting macro projections, you MUST provide a detailed explanation BEFORE the JSON block:


\

If the user just wants clarification or discussion without changes, don't include the JSON block.`;

                // Build conversation for context
                const messages = [
                    { role: 'system', content: systemPrompt },
                    ...reportChatHistory
                ];

                const response = await fetch(AZURE_OPENAI_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-5-2025-08-07-eastus-dz',
                        messages: messages,
                        // temperature omitted - GPT-5 only supports default value of 1
                        max_tokens: 20000
                    })
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const data = await response.json();
                const aiResponse = data.choices[0].message.content;

                // Remove typing indicator
                const typingIndicator = document.getElementById('reportTypingIndicator');
                if (typingIndicator) typingIndicator.remove();

                // Parse the response
                let displayText = aiResponse;
                let updates = null;

                const jsonMatch = aiResponse.match(/```json\s*([\s\S]*?)\s*```/);
                if (jsonMatch) {
                    try {
                        updates = JSON.parse(jsonMatch[1]);
                        displayText = aiResponse.substring(0, aiResponse.indexOf('```json')).trim();

                        // POST-PROCESS: Calculate deltas for macro updates if baseline values available
                        console.log('ðŸ” Checking post-processing conditions:', {
                            hasMacroUpdates: !!updates.macroUpdates,
                            hasBaselineValues: !!window.currentBaselineValues,
                            baselineValues: window.currentBaselineValues
                        });

                        // If baseline values not available, fetch them now
                        if (updates.macroUpdates && !window.currentBaselineValues) {
                            console.log('âš ï¸ Baseline values missing, fetching now...');
                            try {
                                const currentPeriodInfo = {
                                    quarter: `Q${Math.ceil((new Date().getMonth() + 1) / 3)}`,
                                    year: new Date().getFullYear()
                                };
                                const baselineData = await fetchBaselineMacroData(currentPeriodInfo);

                                console.log('ðŸ“¥ Raw baseline data received:', baselineData);

                                if (baselineData && baselineData.values) {
                                    const vals = baselineData.values;
                                    console.log('ðŸ“¥ Baseline values object:', vals);

                                    window.currentBaselineValues = {
                                        gdp: vals['Canada GDP'] ? parseFloat(vals['Canada GDP'].match(/QoQ:\s*([+-]?\d+\.?\d*)/)?.[1] || '0') : 0,
                                        unemployment: parseFloat(vals['Unemployment Rate']) || 0,
                                        inflation: parseFloat(vals['CPI Inflation']) || 0,
                                        cadUsd: parseFloat(vals['CAD/USD']) || 0,
                                        bocRate: parseFloat(vals['BoC Rate']) || 0,
                                        housePrice: vals['House Price Index'] ? parseFloat(vals['House Price Index'].match(/QoQ:\s*([+-]?\d+\.?\d*)/)?.[1] || '0') : 0,
                                        tsx: vals['TSX Composite'] ? parseFloat(vals['TSX Composite'].match(/QoQ:\s*([+-]?\d+\.?\d*)/)?.[1] || '0') : 0,
                                        creditSpreads: parseFloat(vals['Credit Spreads']) || 0
                                    };
                                    console.log('âœ… Baseline values fetched:', window.currentBaselineValues);
                                } else {
                                    console.error('âŒ Baseline data structure invalid:', baselineData);
                                }
                            } catch (err) {
                                console.error('âŒ Failed to fetch baseline values:', err);
                            }
                        }

                        if (updates.macroUpdates && window.currentBaselineValues) {
                            const baselineValues = window.currentBaselineValues;

                            console.log('ðŸ“Š Post-processing macro updates with baselines:', baselineValues);
                            console.log('ðŸ“Š AI-provided macro updates:', updates.macroUpdates);

                            const extractNumber = (val) => {
                                if (typeof val === 'number') return val;
                                if (typeof val === 'string') {
                                    const cleaned = val.replace(/[^\d.-]/g, '');
                                    return parseFloat(cleaned);
                                }
                                return NaN;
                            };

                            for (const [key, data] of Object.entries(updates.macroUpdates)) {
                                if (!data.value) continue;

                                const stressValue = extractNumber(data.value);
                                if (isNaN(stressValue)) continue;

                                // Calculate delta and direction based on variable
                                switch (key) {
                                    case 'canadaGDP':
                                        // GDP stress values are negative (e.g., -3.0), baseline is QoQ growth (e.g., +0.1)
                                        // Delta should show how much it declined from baseline
                                        const gdpDelta = Math.abs(stressValue);

                                        data.delta = `â†“ ${gdpDelta.toFixed(1)}% from current`;
                                        data.direction = 'negative';
                                        break;

                                    case 'unemployment':
                                        if (baselineValues.unemployment) {
                                            const baseline = baselineValues.unemployment;
                                            const delta = stressValue - baseline;
                                            data.delta = `${delta > 0 ? 'â†‘' : 'â†“'} to ${stressValue.toFixed(1)}% from ${baseline.toFixed(1)}%`;
                                            data.direction = delta > 0 ? 'negative' : 'positive';
                                        }
                                        break;

                                    case 'inflation':
                                        if (baselineValues.inflation) {
                                            const baseline = baselineValues.inflation;
                                            const delta = stressValue - baseline;
                                            data.delta = `${delta > 0 ? 'â†‘' : 'â†“'} to ${stressValue.toFixed(1)}% from ${baseline.toFixed(1)}%`;
                                            data.direction = delta > 0 ? 'negative' : 'positive';
                                        }
                                        break;

                                    case 'usdCad':
                                    case 'cadUsd':
                                        if (baselineValues.cadUsd) {
                                            const baseline = baselineValues.cadUsd;
                                            const delta = stressValue - baseline;
                                            data.delta = `${delta > 0 ? 'â†‘' : 'â†“'} to ${stressValue.toFixed(2)} from ${baseline.toFixed(2)}`;
                                            data.direction = delta > 0 ? 'negative' : 'positive';
                                        }
                                        break;

                                    case 'bocRate':
                                        if (baselineValues.bocRate) {
                                            const baseline = baselineValues.bocRate;
                                            const deltaBps = Math.round((stressValue - baseline) * 100);
                                            data.delta = `${deltaBps < 0 ? 'â†“' : 'â†‘'} ${Math.abs(deltaBps)} bps to ${stressValue.toFixed(2)}% from ${baseline.toFixed(1)}%`;
                                            data.direction = deltaBps < 0 ? 'positive' : 'negative';
                                        }
                                        break;

                                    case 'housePrice':
                                        // House price stress values are negative percentage changes (e.g., -15.0%)
                                        const hpiDelta = Math.abs(stressValue);
                                        data.delta = `â†“ ${hpiDelta.toFixed(1)}% from current`;
                                        data.direction = 'negative';
                                        break;

                                    case 'tsx':
                                        // TSX stress values are negative percentage changes (e.g., -20.0%)
                                        const tsxDelta = Math.abs(stressValue);
                                        data.delta = `â†“ ${tsxDelta.toFixed(1)}% from current`;
                                        data.direction = 'negative';
                                        break;

                                    case 'creditSpreads':
                                        if (baselineValues.creditSpreads) {
                                            const stressBps = Math.round(stressValue * 100);
                                            const baselineBps = Math.round(baselineValues.creditSpreads * 100);
                                            const deltaBps = stressBps - baselineBps;
                                            data.value = `+${stressBps} bps`;
                                            data.delta = `â†‘ ${deltaBps} bps to +${stressBps} from ${baselineBps} bps`;
                                            data.direction = 'negative';
                                        }
                                        break;
                                }
                            }

                            console.log('ðŸ“Š Final processed macro updates:', updates.macroUpdates);
                        }
                    } catch (e) {
                        console.error('Failed to parse update JSON:', e);
                    }
                }

                // Apply updates if any
                if (updates) {
                    if (updates.updateSection === 'global' && updates.newContent) {
                        document.getElementById('globalConditions').innerHTML = updates.newContent;
                    } else if (updates.updateSection === 'canadian' && updates.newContent) {
                        document.getElementById('canadianConditions').innerHTML = updates.newContent;
                    } else if (updates.updateSection === 'rbc' && updates.newContent) {
                        document.getElementById('rbcImpact').innerHTML = updates.newContent;
                    } else if (updates.updateSection === 'title' && updates.newContent) {
                        document.getElementById('reportTitle').innerText = updates.newContent;
                    }

                    // Handle macro updates with rationale display
                    if (updates.updateSection === 'macro' && updates.macroUpdates) {
                        // Display rationale in chat if provided
                        if (updates.rationale) {
                            let rationaleText = `\n\nðŸ“Š **Macro Projection Rationale:**\n\n`;

                            if (updates.rationale.overall) {
                                rationaleText += `**Overall:** ${updates.rationale.overall}\n\n`;
                            }

                            const varNames = {
                                'canadaGDP': 'ðŸ‡¨ðŸ‡¦ GDP',
                                'unemployment': 'ðŸ‘¥ Unemployment',
                                'inflation': 'ðŸ’¹ Inflation',
                                'cadUsd': 'ðŸ’± CAD/USD',
                                'bocRate': 'ðŸ¦ BoC Rate',
                                'housePrice': 'ðŸ  House Prices',
                                'tsx': 'ðŸ“ˆ TSX',
                                'creditSpreads': 'ðŸ’³ Credit Spreads'
                            };

                            for (const [key, label] of Object.entries(varNames)) {
                                if (updates.rationale[key]) {
                                    rationaleText += `**${label}:** ${updates.rationale[key]}\n`;
                                }
                            }

                            displayText = displayText + '\n' + rationaleText;
                        }

                        // Update macro cards
                        const macroCards = document.querySelectorAll('.macro-card');
                        const macroMap = {
                            'canadaGDP': 0, 'unemployment': 1, 'inflation': 2, 'cadUsd': 3,
                            'bocRate': 4, 'housePrice': 5, 'tsx': 6, 'creditSpreads': 7
                        };

                        for (const [key, data] of Object.entries(updates.macroUpdates)) {
                            const idx = macroMap[key];
                            if (idx !== undefined && macroCards[idx]) {
                                const valueEl = macroCards[idx].querySelector('.macro-value');
                                const deltaEl = macroCards[idx].querySelector('.macro-delta');

                                if (valueEl && data.value) {
                                    valueEl.innerText = data.value;
                                    // Update direction class
                                    valueEl.className = 'macro-value';
                                    if (data.direction === 'negative') {
                                        valueEl.classList.add('negative');
                                    } else if (data.direction === 'positive') {
                                        valueEl.classList.add('positive');
                                    }
                                }

                                if (deltaEl && data.delta) {
                                    deltaEl.innerText = data.delta;
                                }
                            }
                        }

                        // Update stored scenario
                        if (window.currentGeneratedScenario && window.currentGeneratedScenario.macroProjections) {
                            Object.assign(window.currentGeneratedScenario.macroProjections, updates.macroUpdates);
                        }
                    }

                    // ALWAYS update macro cards if macroUpdates present (regardless of updateSection)
                    // This ensures deltas are refreshed even when AI doesn't set updateSection='macro'
                    if (updates.macroUpdates) {
                        console.log('ðŸ”„ Updating macro cards with:', updates.macroUpdates);
                        const macroCards = document.querySelectorAll('.macro-card');
                        const macroMap = {
                            'canadaGDP': 0, 'unemployment': 1, 'inflation': 2,
                            'cadUsd': 3, 'usdCad': 3,  // Support both key names
                            'bocRate': 4, 'housePrice': 5, 'tsx': 6, 'creditSpreads': 7
                        };
                        for (const [key, data] of Object.entries(updates.macroUpdates)) {
                            const idx = macroMap[key];
                            console.log(`ðŸ”„ Processing ${key}: idx=${idx}, value=${data.value}, delta=${data.delta}`);
                            if (idx !== undefined && macroCards[idx]) {
                                const valueEl = macroCards[idx].querySelector('.macro-value');
                                const deltaEl = macroCards[idx].querySelector('.macro-delta');

                                if (valueEl && data.value) {
                                    console.log(`  âœï¸ Updating value to: ${data.value}`);
                                    valueEl.innerText = data.value;
                                    // Update direction class
                                    valueEl.className = 'macro-value';
                                    if (data.direction === 'negative') {
                                        valueEl.classList.add('negative');
                                    } else if (data.direction === 'positive') {
                                        valueEl.classList.add('positive');
                                    }
                                }

                                if (deltaEl && data.delta) {
                                    console.log(`  âœï¸ Updating delta to: ${data.delta}`);
                                    deltaEl.innerText = data.delta;
                                }
                            }
                        }

                        // Update stored scenario
                        if (window.currentGeneratedScenario && window.currentGeneratedScenario.macroProjections) {
                            Object.assign(window.currentGeneratedScenario.macroProjections, updates.macroUpdates);
                        }
                    }
                }

                // Add AI response to chat
                reportChatHistory.push({ role: 'assistant', content: aiResponse });

                const aiDiv = document.createElement('div');
                aiDiv.className = 'chat-message ai';
                aiDiv.innerHTML = displayText.replace(/\n/g, '<br>');
                chatHistoryEl.appendChild(aiDiv);
                chatHistoryEl.scrollTop = chatHistoryEl.scrollHeight;

            } catch (error) {
                console.error('Report chat error:', error);

                // Remove typing indicator
                const typingIndicator = document.getElementById('reportTypingIndicator');
                if (typingIndicator) typingIndicator.remove();

                const aiDiv = document.createElement('div');
                aiDiv.className = 'chat-message ai';
                aiDiv.innerText = `Sorry, I encountered an error: ${error.message}. Please try again.`;
                chatHistoryEl.appendChild(aiDiv);
                chatHistoryEl.scrollTop = chatHistoryEl.scrollHeight;
            }

            input.disabled = false;
            input.focus();
        }

        function saveReport() {
            const now = new Date();
            const timestamp = now.toLocaleDateString() + ' ' + now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            // Always use the current report title from the DOM
            const currentTitle = document.getElementById('reportTitle').innerText || 'Untitled Scenario';

            const scenarioData = {
                id: currentScenarioId || 'scen_' + Date.now(),
                title: currentTitle,
                date: timestamp,
                driverCount: selectedDrivers.length,
                drivers: [...selectedDrivers],
                global: document.getElementById('globalConditions').innerHTML,
                canadian: document.getElementById('canadianConditions').innerHTML,
                rbc: document.getElementById('rbcImpact').innerHTML,
                macros: document.getElementById('macroProjections').innerHTML,
                chatHistory: [...reportChatHistory] // Save chat history with scenario
            };

            // Update existing or add new
            const existingIdx = savedScenarios.findIndex(s => s.id === scenarioData.id);
            if (existingIdx > -1) {
                savedScenarios[existingIdx] = scenarioData;
            } else {
                savedScenarios.push(scenarioData);
            }

            // Persist to localStorage
            saveScenariosToStorage();

            // Clear selected drivers after saving
            selectedDrivers = [];
            currentScenarioId = null;

            alert('Scenario saved successfully.');
            closeReport();
            renderMarketplace(); // Re-render to show unselected state
            updateInventory(); // Update basket to show empty
            showSavedScenarios(); // Switch to saved view
        }

        // ========================================
        // SEND TO ASTRA INTEGRATION
        // ========================================
        function sendToAstra() {
            const currentTitle = document.getElementById('reportTitle').innerText || 'Untitled Scenario';

            // Gather all scenario data for Astra
            const astraPayload = {
                // Metadata
                id: 'astra_' + Date.now(),
                title: currentTitle,
                timestamp: Date.now(),
                source: 'scenario.html',

                // Narrative content (HTML)
                globalConditions: document.getElementById('globalConditions').innerHTML,
                canadianConditions: document.getElementById('canadianConditions').innerHTML,
                rbcImpact: document.getElementById('rbcImpact').innerHTML,

                // Macro projections (for reference)
                macroProjectionsHtml: document.getElementById('macroProjections').innerHTML,

                // Structured risk drivers with heat map data
                riskDrivers: selectedDrivers.map(d => ({
                    id: d.id,
                    title: d.title,
                    category: d.cat,
                    description: d.desc,
                    heatMapData: heatMapData[d.id] || null
                })),

                // Plain text summary for AI context
                narrativeSummary: buildNarrativeSummary()
            };

            // Save to localStorage for Astra to pick up
            localStorage.setItem('astraScenarioImport', JSON.stringify(astraPayload));

            // Visual feedback
            const btn = document.getElementById('sendToAstraBtn');
            const originalText = btn.innerHTML;
            btn.innerHTML = 'âœ“ Sent!';
            btn.style.background = '#10B981';

            setTimeout(() => {
                // Open Astra in new tab
                window.open('Astra.html', '_blank');

                // Reset button after short delay
                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.style.background = 'linear-gradient(135deg, #8B5CF6, #6366F1)';
                }, 1000);
            }, 500);
        }

        function buildNarrativeSummary() {
            // Extract text content from HTML for AI consumption
            const globalEl = document.getElementById('globalConditions');
            const canadianEl = document.getElementById('canadianConditions');
            const rbcEl = document.getElementById('rbcImpact');
            const macroEl = document.getElementById('macroProjections');

            const globalText = globalEl ? globalEl.innerText : '';
            const canadianText = canadianEl ? canadianEl.innerText : '';
            const rbcText = rbcEl ? rbcEl.innerText : '';

            // Extract macro projections values
            let macroSummary = '';
            if (macroEl) {
                const macroCards = macroEl.querySelectorAll('.macro-card');
                const macroValues = [];
                macroCards.forEach(card => {
                    const label = card.querySelector('.macro-label')?.innerText || '';
                    const value = card.querySelector('.macro-value')?.innerText || '';
                    const delta = card.querySelector('.macro-delta')?.innerText || '';
                    if (label && value) {
                        macroValues.push(`- ${label}: ${value}${delta ? ' (' + delta + ')' : ''}`);
                    }
                });
                macroSummary = macroValues.join('\n');
            }

            // Build driver summary
            const driverSummary = selectedDrivers.map(d => {
                const hm = heatMapData[d.id];
                if (hm) {
                    return `- ${d.title} (${d.cat}): Likelihood ${hm.likelihood}/10, Materiality ${hm.materiality}/10, Velocity ${hm.velocity === 3 ? 'High' : hm.velocity === 2 ? 'Medium' : 'Low'}`;
                }
                return `- ${d.title} (${d.cat})`;
            }).join('\n');

            return `
SCENARIO: ${document.getElementById('reportTitle').innerText}

MACROECONOMIC PROJECTIONS:
${macroSummary || 'Not available'}

GLOBAL CONDITIONS:
${globalText}

CANADIAN CONDITIONS:
${canadianText}

RBC IMPACT:
${rbcText}

RISK DRIVERS:
${driverSummary}
            `.trim();
        }

        function renderSavedScenarios() {
            console.log('Rendering saved scenarios. Total count:', savedScenarios.length);
            console.log('Scenarios to render:', savedScenarios);

            const grid = document.getElementById('savedScenariosGrid');

            if (savedScenarios.length === 0) {
                grid.innerHTML = `
                    <div style="grid-column: 1/-1; text-align: center; color: var(--text-muted); margin-top: 40px;">
                        <div style="font-size: 40px; margin-bottom: 16px; opacity: 0.5;">ðŸ“</div>
                        <p style="font-size: 16px; font-weight: 500;">Folder is empty</p>
                        <p style="font-size: 13px; margin-top: 8px;">Save scenarios or heat maps to see them here.</p>
                    </div>
                `;
                return;
            }

            grid.innerHTML = savedScenarios.map(s => {
                const isHeatmap = s.type === 'heatmap';
                const typeLabel = isHeatmap ? 'Heat Map' : 'Scenario';
                const typeColor = isHeatmap ? '#FFF7ED' : '#E0E7FF'; // Orange vs Indigo
                const typeText = isHeatmap ? '#C2410C' : '#4338CA';
                const icon = isHeatmap ? 'ðŸ“Š' : 'ðŸ“„';

                console.log(`Rendering ${typeLabel}:`, s.title);

                return `
                <div class="driver-card" onclick="openSavedItem('${s.id}')">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
                        <span class="driver-tag" style="background: ${typeColor}; color: ${typeText};">${typeLabel}</span>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 11px; color: var(--text-muted);">${s.date}</span>
                            <button onclick="event.stopPropagation(); deleteScenario('${s.id}')"
                                    style="background: none; border: none; cursor: pointer; padding: 2px 6px; font-size: 14px; opacity: 0.5; transition: opacity 0.2s;"
                                    onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.5'"
                                    title="Delete">ðŸ—‘ï¸</button>
                        </div>
                    </div>
                    <div class="driver-title">${s.title}</div>
                    <div style="margin-top: 12px;">
                        <div class="driver-desc" style="margin-bottom: 6px;">${s.driverCount} Risk Drivers:</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                            ${(s.drivers || []).slice(0, 8).map(d => `
                                <span style="font-size: 10px; padding: 2px 6px; border-radius: 4px; background: ${d.tagColor || '#eee'}; color: ${d.textColor || '#333'}; white-space: nowrap; max-width: 150px; overflow: hidden; text-overflow: ellipsis;">
                                    ${d.title}
                                </span>
                            `).join('')}
                            ${(s.drivers || []).length > 8 ? `<span style="font-size: 10px; padding: 2px 6px; color: var(--text-muted);">+${s.drivers.length - 8} more</span>` : ''}
                        </div>
                    </div>
                </div>
            `}).join('');
        }

        function saveHeatMap() {
            if (selectedDrivers.length === 0) {
                alert('No drivers to save.');
                return;
            }

            const title = prompt('Enter a name for this Heat Map:', 'Heat Map ' + new Date().toLocaleDateString());
            if (!title) return;

            const heatmap = {
                id: 'heatmap_' + Date.now(),
                type: 'heatmap',
                title: title,
                date: new Date().toLocaleDateString(),
                drivers: selectedDrivers,
                heatMapData: JSON.parse(JSON.stringify(heatMapData)),
                driverCount: selectedDrivers.length
            };

            console.log('Saving heat map:', heatmap);
            console.log('Current savedScenarios before save:', savedScenarios);

            savedScenarios.unshift(heatmap);

            console.log('Current savedScenarios after unshift:', savedScenarios);

            saveScenariosToStorage();

            console.log('Heat map saved to localStorage');

            alert('Heat Map saved to Folder.');
            updateInventory();
            showSavedScenarios(); // Go to folder to show it
        }

        function openSavedItem(id) {
            const item = savedScenarios.find(s => s.id === id);
            if (!item) return;

            if (item.type === 'heatmap') {
                // Restore Heat Map
                selectedDrivers = [...item.drivers];
                heatMapData = item.heatMapData || {};

                // Update Basket/Inventory state to match
                updateInventory();

                // Show Heat Map View
                showHeatMap();
                renderHeatMap();
            } else {
                // Open Scenario Report
                openSavedReport(id);
            }
        }

        function openSavedReport(id) {
            const scenario = savedScenarios.find(s => s.id === id);
            if (!scenario) return;

            currentScenarioId = scenario.id; // Set current ID for updates
            selectedDrivers = [...scenario.drivers]; // Restore drivers for context

            // Restore chat history for this specific scenario
            reportChatHistory = scenario.chatHistory ? [...scenario.chatHistory] : [];

            // Restore state
            document.getElementById('reportTitle').innerText = scenario.title;
            document.getElementById('reportSubtitle').innerText = `Last saved on ${scenario.date} | ${scenario.driverCount} Drivers`;

            document.getElementById('reportDriversList').innerHTML = scenario.drivers.map(d => `
                <span class="driver-pill" style="background: ${d.tagColor}; color: ${d.textColor};">${d.title}</span>
            `).join('');

            document.getElementById('globalConditions').innerHTML = scenario.global;
            document.getElementById('canadianConditions').innerHTML = scenario.canadian;
            document.getElementById('rbcImpact').innerHTML = scenario.rbc;
            document.getElementById('macroProjections').innerHTML = scenario.macros;

            // Restore chat history UI
            const chatHistoryEl = document.getElementById('reportChatHistory');
            if (reportChatHistory.length > 0) {
                chatHistoryEl.innerHTML = reportChatHistory.map(msg => {
                    const className = msg.role === 'user' ? 'chat-message user' : 'chat-message ai';
                    const div = document.createElement('div');
                    div.className = className;
                    div.innerHTML = msg.content;
                    return div.outerHTML;
                }).join('');
            } else {
                // Show default message if no chat history
                chatHistoryEl.innerHTML = `
                    <div class="chat-message ai">
                        <p style="margin: 0;">ðŸ“Š Scenario <strong>"${scenario.title}"</strong> loaded.</p>
                        <p style="margin: 8px 0 0 0; font-size: 12px; color: #6b7280;">You can refine this scenario by asking questions or requesting changes.</p>
                    </div>
                `;
            }

            document.getElementById('reportOverlay').style.display = 'flex';
        }

        function showMarketplace() {
            document.getElementById('marketplacePanel').style.display = 'flex';
            document.getElementById('savedScenariosPanel').style.display = 'none';
            document.getElementById('heatMapPanel').style.display = 'none';
            document.getElementById('basketPanel').style.display = 'flex';
            document.getElementById('heatmapBasketPanel').style.display = 'none';

            // Update nav active state
            document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
            document.querySelector('.nav-item[title="Risk Drivers"]').classList.add('active');

            currentScenarioId = null; // Reset current scenario when going back to marketplace
            renderMarketplace(); // Re-render marketplace to ensure correct selected states
            updateInventory(); // Update basket in case drivers were changed in a report
        }


        function showSavedScenarios() {
            console.log('showSavedScenarios called');
            document.getElementById('marketplacePanel').style.display = 'none';
            document.getElementById('savedScenariosPanel').style.display = 'flex';
            document.getElementById('heatMapPanel').style.display = 'none';
            document.getElementById('basketPanel').style.display = 'none';
            document.getElementById('heatmapBasketPanel').style.display = 'none';

            renderSavedScenarios();

            // Update nav active state
            document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
            document.querySelector('.nav-item[title="Folder"]').classList.add('active');
        }

        // ========================================
        // HEAT MAP FUNCTIONS
        // ========================================

        // Store heat map data for each driver
        let heatMapData = {};

        // Heat map view mode: 'default', 'compact', or 'minimal'
        let heatMapViewMode = 'default';

        // Set heat map view mode
        function setHeatMapViewMode(mode) {
            heatMapViewMode = mode;

            // Update button styles
            // Update button styles
            ['default', 'compact', 'minimal'].forEach(m => {
                const btn = document.getElementById(`viewMode${m.charAt(0).toUpperCase() + m.slice(1)}`);
                if (btn) {
                    if (m === mode) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                    // Remove inline styles to allow CSS to take over
                    btn.style.background = '';
                    btn.style.color = '';
                    btn.style.borderColor = '';
                }
            });

            // Show/hide driver legend in heat map legend and driver list in controls panel
            const driverList = document.getElementById('heatmapDriverList');
            const driverLegendSection = document.getElementById('driverLegendSection');

            if (mode === 'minimal') {
                if (driverList) driverList.style.display = 'none';
                if (driverLegendSection) driverLegendSection.style.display = 'block';
                renderDriverLegendInHeatMap();
            } else {
                if (driverList) driverList.style.display = 'block';
                if (driverLegendSection) driverLegendSection.style.display = 'none';
            }

            // Re-render heat map with new mode
            renderHeatMap();
        }

        // Render driver legend inside the heat map legend panel (for minimal view)
        function renderDriverLegendInHeatMap() {
            const container = document.getElementById('driverLegendItems');
            if (!container) return;

            const driversToRender = getFilteredDrivers();
            container.innerHTML = driversToRender.map((d, idx) => {
                const hmData = heatMapData[d.id] || { velocity: 2 };
                const velocityColor = hmData.velocity === 3 ? '#EF4444' : hmData.velocity === 2 ? '#F59E0B' : '#22C55E';

                return `
                    <div class="heatmap-legend-item" style="cursor: pointer; padding: 2px 0;" 
                        onclick="openDriverDetails('${d.id}')"
                        onmouseenter="highlightHeatMapDriver('${d.id}', true)"
                        onmouseleave="highlightHeatMapDriver('${d.id}', false)">
                        <div style="
                            width: 16px;
                            height: 16px;
                            border-radius: 50%;
                            background: ${velocityColor};
                            color: white;
                            font-size: 9px;
                            font-weight: 700;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            flex-shrink: 0;
                        ">${idx + 1}</div>
                        <span style="font-size: 10px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${d.title}</span>
                    </div>
                `;
            }).join('');
        }


        function showHeatMap() {
            document.getElementById('marketplacePanel').style.display = 'none';
            document.getElementById('savedScenariosPanel').style.display = 'none';
            document.getElementById('heatMapPanel').style.display = 'flex';
            document.getElementById('basketPanel').style.display = 'none';
            document.getElementById('heatmapBasketPanel').style.display = 'flex';

            // Update nav active state
            document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
            const heatMapNav = document.querySelector('.nav-item[title="Heat Map"]');
            if (heatMapNav) heatMapNav.classList.add('active');

            // Update count
            document.getElementById('heatmapCount').innerText = selectedDrivers.length;

            // Render the heat map if we have data
            if (Object.keys(heatMapData).length > 0) {
                renderHeatMap();
            }

            // Render driver list in basket
            renderHeatMapDriverList();

            // Render Category Legend
            renderCategoryLegend();
        }

        function toggleHeatMapHelp() {
            const helpPanel = document.getElementById('heatmapHelpPanel');
            if (helpPanel.style.display === 'none') {
                helpPanel.style.display = 'block';
            } else {
                helpPanel.style.display = 'none';
            }
        }

        function highlightHeatMapDriver(driverId, highlight) {
            const driverCard = document.querySelector(`.heatmap-driver[data-driver-id="${driverId}"]`);
            if (!driverCard) return;

            if (highlight) {
                // Bring to front and add highlight effect
                driverCard.style.zIndex = '2000';
                driverCard.style.boxShadow = '0 0 0 3px var(--primary), 0 8px 24px rgba(0,0,0,0.3)';
                driverCard.style.transition = 'all 0.2s ease';
                // Expand the card to show description
                driverCard.classList.add('expanded');

                // For compact view, also show the expand section
                const compactExpand = driverCard.querySelector('.compact-expand');
                if (compactExpand) {
                    compactExpand.style.display = 'block';
                }

                // For compact pill, add shadow
                const compactPill = driverCard.querySelector('.compact-pill');
                if (compactPill) {
                    compactPill.style.boxShadow = '0 4px 16px rgba(0,0,0,0.15)';
                }

                // For minimal view, show the expand section
                const minimalExpand = driverCard.querySelector('.minimal-expand');
                if (minimalExpand) {
                    minimalExpand.style.display = 'block';
                }
            } else {
                // Reset to original state
                const yPercent = parseFloat(driverCard.style.top) || 0;
                driverCard.style.zIndex = Math.floor(10 + yPercent);
                driverCard.style.boxShadow = '';
                // Collapse the card
                driverCard.classList.remove('expanded');

                // For compact view, hide the expand section
                const compactExpand = driverCard.querySelector('.compact-expand');
                if (compactExpand) {
                    compactExpand.style.display = 'none';
                }

                // For compact pill, reset shadow
                const compactPill = driverCard.querySelector('.compact-pill');
                if (compactPill) {
                    compactPill.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
                }

                // For minimal view, hide the expand section
                const minimalExpand = driverCard.querySelector('.minimal-expand');
                if (minimalExpand) {
                    minimalExpand.style.display = 'none';
                }
            }
        }

        function renderHeatMapDriverList() {
            const list = document.getElementById('heatmapDriverList');
            if (!list) return;

            // Start with global empty check
            if (selectedDrivers.length === 0) {
                list.innerHTML = `
                    <div class="basket-empty">
                        <div class="basket-empty-icon">ðŸ“Š</div>
                        <p>No drivers in heat map.</p>
                    </div>
                `;
                return;
            }

            const filteredDrivers = getFilteredDrivers();

            if (filteredDrivers.length === 0) {
                list.innerHTML = `
                    <div class="basket-empty">
                        <div class="basket-empty-icon" style="font-size: 32px; opacity: 0.3;">ðŸ”</div>
                        <p style="font-size: 13px;">No drivers match filter.</p>
                    </div>
                 `;
                return;
            }

            list.innerHTML = filteredDrivers.map(d => {
                const hmData = heatMapData[d.id] || { likelihood: '?', materiality: '?', velocity: 2 };
                const velocityLabel = hmData.velocity === 3 ? 'ðŸ”´' : hmData.velocity === 2 ? 'ðŸŸ¡' : 'ðŸŸ¢';

                // Get L/M/H labels for likelihood and materiality
                const getLevelAbbr = (value) => {
                    if (value === '?') return '?';
                    const num = parseInt(value);
                    if (num >= 7) return 'H';
                    if (num >= 4) return 'M';
                    return 'L';
                };

                const likelihoodAbbr = getLevelAbbr(hmData.likelihood);
                const materialityAbbr = getLevelAbbr(hmData.materiality);

                return `
                    <div class="basket-item" 
                         onclick="openDriverDetails('${d.id}')" 
                         onmouseenter="highlightHeatMapDriver('${d.id}', true)" 
                         onmouseleave="highlightHeatMapDriver('${d.id}', false)"
                         style="cursor: pointer;">
                        <div class="basket-item-info">
                            <div class="basket-item-dot" style="background: ${d.textColor}"></div>
                            <span class="basket-item-title">${d.title}</span>
                        </div>
                        <span style="font-size: 11px; color: var(--text-muted); display: flex; gap: 4px; align-items: center;" title="Likelihood: ${hmData.likelihood}, Materiality: ${hmData.materiality}, Velocity">
                            <span>${likelihoodAbbr}</span>
                            <span>${materialityAbbr}</span>
                            ${velocityLabel}
                        </span>
                    </div>
                `;
            }).join('');
        }

        async function generateHeatMap() {
            if (selectedDrivers.length === 0) {
                alert('Please select at least one risk driver first.');
                return;
            }

            // Show loader
            const loader = document.getElementById('loader');
            const loaderText = document.getElementById('loaderText');
            loader.style.display = 'flex';
            loaderText.innerText = 'Analyzing risk drivers for heat map positioning...';

            try {
                // Build driver summaries for AI
                const driverSummaries = selectedDrivers.map(d => ({
                    id: d.id,
                    title: d.title,
                    category: d.cat,
                    description: d.desc
                }));

                loaderText.innerText = 'AI is assessing likelihood, materiality, and velocity...';

                // Call AI to assess each driver
                const assessments = await getAIHeatMapAssessments(driverSummaries);

                // Store assessments
                assessments.forEach(assessment => {
                    heatMapData[assessment.id] = {
                        likelihood: assessment.likelihood, // 1-10
                        materiality: assessment.materiality, // 1-10
                        velocity: assessment.velocity, // 1-3 (1=low, 2=medium, 3=high)
                        likelihoodReasoning: assessment.likelihoodReasoning || '', // Justification for likelihood score
                        materialityReasoning: assessment.materialityReasoning || '', // Justification for materiality score
                        reasoning: assessment.reasoning || '', // Velocity and overall summary
                        aiGenerated: true
                    };
                });

                loaderText.innerText = 'Rendering heat map...';
                await new Promise(r => setTimeout(r, 300));

                // Switch to heat map view
                loader.style.display = 'none';
                showHeatMap();
                renderHeatMap();
                renderCategoryLegend();

            } catch (error) {
                console.error('Heat map generation error:', error);
                loaderText.innerText = 'AI unavailable. Generating random positions...';

                // Fallback: Generate random positions
                selectedDrivers.forEach(d => {
                    heatMapData[d.id] = {
                        likelihood: Math.floor(Math.random() * 10) + 1,
                        materiality: Math.floor(Math.random() * 10) + 1,
                        velocity: Math.floor(Math.random() * 3) + 1,
                        aiGenerated: false
                    };
                });

                await new Promise(r => setTimeout(r, 1000));
                loader.style.display = 'none';
                showHeatMap();
                renderHeatMap();
                renderCategoryLegend();

                // Notify user
                setTimeout(() => {
                    alert('Note: AI was unavailable. Positions were randomly generated. You can drag drivers to adjust their positions.');
                }, 500);
            }
        }

        async function getAIHeatMapAssessments(drivers) {
            const driversList = drivers.map((d, i) => `${i + 1}. ID: "${d.id}"
   Title: "${d.title}"
   Category: ${d.category}
   Description: ${d.description}`).join('\n\n');

            const prompt = fillPrompt(PROMPT_TEMPLATES.HEATMAP_ASSESSMENT, {
                DRIVERS_LIST: driversList
            });

            const response = await fetch(AZURE_OPENAI_API_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: 'gpt-5-2025-08-07-eastus-dz',
                    messages: [{ role: 'user', content: prompt }],
                    // temperature omitted - GPT-5 only supports default value of 1
                    max_tokens: 20000
                })
            });

            if (!response.ok) {
                throw new Error(`AI API error: ${response.status} `);
            }

            const data = await response.json();
            const aiResponse = data.choices[0].message.content;

            // Parse JSON
            const jsonMatch = aiResponse.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
                return JSON.parse(jsonMatch[0]);
            }
            throw new Error('Failed to parse AI response');
        }

        // --- Heatmap Filtering Logic ---
        let activeVelocityFilters = new Set();
        let activeCategoryFilters = new Set();
        const VELOCITY_CONFIG = {
            3: { label: 'High (< 2 weeks)', color: '#EF4444', value: 3 },
            2: { label: 'Medium (2 wks - 3 mos)', color: '#F59E0B', value: 2 },
            1: { label: 'Low (> 3 months)', color: '#10B981', value: 1 }
        };

        function renderVelocityLegend() {
            const container = document.getElementById('velocityLegendItems');
            if (!container) return;
            container.innerHTML = [3, 2, 1].map(v => {
                const config = VELOCITY_CONFIG[v];
                const isActive = activeVelocityFilters.size === 0 || activeVelocityFilters.has(config.value);
                const dimClass = isActive ? '' : 'legend-dimmed';
                return `<div class="heatmap-legend-item ${dimClass}" onclick="toggleVelocityFilter(${config.value})">
                         <div class="heatmap-legend-velocity" style="background: ${config.color};"></div>
                         <span>${config.label}</span>
                    </div>`;
            }).join('');
        }

        function toggleVelocityFilter(val) {
            if (activeVelocityFilters.has(val)) activeVelocityFilters.delete(val);
            else activeVelocityFilters.add(val);
            renderVelocityLegend();
            renderHeatMap();
            renderHeatMapDriverList();
        }

        function toggleCategoryFilter(cat) {
            if (activeCategoryFilters.has(cat)) activeCategoryFilters.delete(cat);
            else activeCategoryFilters.add(cat);
            renderCategoryLegend();
            renderHeatMap();
            renderHeatMapDriverList();
        }

        function getFilteredDrivers() {
            // Remove window. prefix as let/const globals aren't always on window
            if (!selectedDrivers) {
                console.warn("getFilteredDrivers: selectedDrivers is missing");
                return [];
            }
            return selectedDrivers.filter(driver => {
                const data = heatMapData[driver.id];
                if (!data) {
                    console.warn("getFilteredDrivers: No heatMapData for driver", driver.id, driver);
                    return false;
                }
                if (activeVelocityFilters.size > 0 && !activeVelocityFilters.has(data.velocity)) return false;
                if (activeCategoryFilters.size > 0 && !activeCategoryFilters.has(driver.cat)) return false;
                return true;
            });
        }

        function renderHeatMap() {
            const grid = document.getElementById('heatmapGrid');
            const gridRect = grid.getBoundingClientRect();
            const cardWidth = 180; // Driver card width
            const cardHeight = 80; // Approximate driver card height

            grid.innerHTML = '';

            renderVelocityLegend();
            renderCategoryLegend();

            const filteredDrivers = getFilteredDrivers();

            // Update plotting count
            const countEl = document.getElementById('heatmapCount');
            if (countEl) countEl.innerText = filteredDrivers.length;

            // Detect overlapping drivers and apply smart offsets
            const positionMap = new Map(); // Key: "likelihood,materiality", Value: array of driver IDs

            filteredDrivers.forEach(driver => {
                const data = heatMapData[driver.id];
                if (!data) return;

                const posKey = `${data.likelihood},${data.materiality}`;
                if (!positionMap.has(posKey)) {
                    positionMap.set(posKey, []);
                }
                positionMap.get(posKey).push(driver.id);
            });

            filteredDrivers.forEach((driver, index) => {
                const data = heatMapData[driver.id];
                if (!data) return;

                // Calculate base position (1-10 scale to percentage)
                // X: likelihood (1=left/low, 10=right/high)
                // Y: materiality (1=bottom/low, 10=top/high) - invert Y
                let xPercent = ((data.likelihood - 1) / 9) * 100;
                let yPercent = 100 - ((data.materiality - 1) / 9) * 100;

                // Apply smart offset for overlapping drivers
                const posKey = `${data.likelihood},${data.materiality}`;
                const driversAtPosition = positionMap.get(posKey);
                if (driversAtPosition && driversAtPosition.length > 1) {
                    const index = driversAtPosition.indexOf(driver.id);
                    const totalAtPos = driversAtPosition.length;

                    // Calculate offset based on view mode
                    // Compact/minimal views need more spread since cards are smaller
                    let spreadFactor = heatMapViewMode === 'default' ? 2.5 :
                        heatMapViewMode === 'compact' ? 4 : 3;

                    // Spread in a radial pattern to minimize overlap
                    const angle = (index / totalAtPos) * 2 * Math.PI;
                    const radius = Math.min(index + 1, 3) * spreadFactor;

                    const offsetX = Math.cos(angle) * radius;
                    const offsetY = Math.sin(angle) * radius;

                    xPercent += offsetX;
                    yPercent += offsetY;
                }

                // Clamp positions so cards stay fully within grid
                // Account for card dimensions and grid padding
                const minX = 2; // 2% from left edge
                const maxX = 95; // Allow full width (legend is gone)
                const minY = 5; // 5% from top
                const maxY = 90; // 90% from top

                xPercent = Math.max(minX, Math.min(maxX, xPercent));
                yPercent = Math.max(minY, Math.min(maxY, yPercent));

                // Velocity class
                const velocityClass = data.velocity === 3 ? 'high' : data.velocity === 2 ? 'medium' : 'low';
                const velocityLabel = data.velocity === 3 ? 'High' : data.velocity === 2 ? 'Medium' : 'Low';

                // Get Low/Medium/High labels for likelihood and materiality
                const likelihoodLevel = getLevelLabel(data.likelihood);
                const materialityLevel = getLevelLabel(data.materiality);

                // Determine tooltip position class based on card position
                // Always show below for cards in top half, to prevent going outside window
                let tooltipClass = '';
                if (yPercent < 50) tooltipClass = 'tooltip-below';
                if (xPercent < 15) tooltipClass += ' tooltip-right';
                if (xPercent > 45) tooltipClass += ' tooltip-left';

                // Abbreviate levels for compact display
                const likelihoodAbbr = likelihoodLevel[0]; // L, M, or H
                const materialityAbbr = materialityLevel[0];
                const velocityAbbr = velocityLabel[0];

                // Create driver card
                const card = document.createElement('div');
                // Add view mode class to apply correct styling
                const viewModeClass = heatMapViewMode === 'compact' ? 'compact-mode' :
                    heatMapViewMode === 'minimal' ? 'minimal-mode' : '';
                card.className = `heatmap-driver ${viewModeClass}`.trim();
                card.id = `heatmap-${driver.id}`;
                card.style.left = `${xPercent}%`;
                card.style.top = `${yPercent}%`;
                // Layer cards so lower ones (higher Top %) appear on top of upper ones
                card.style.zIndex = Math.floor(10 + yPercent);
                card.setAttribute('data-driver-id', driver.id);

                // Add smart expansion classes based on position to prevent going outside window
                if (xPercent > 35) card.classList.add('expand-left');
                if (yPercent > 60) card.classList.add('expand-up');

                // Card HTML with anchor circle and expandable content
                const likelihoodReasoning = data.likelihoodReasoning || '';
                const materialityReasoning = data.materialityReasoning || '';
                const velocityReasoning = data.reasoning || '';

                // Get driver index for minimal view numbering
                const driverIndex = selectedDrivers.findIndex(d => d.id === driver.id) + 1;

                // Generate HTML based on view mode
                if (heatMapViewMode === 'minimal') {
                    // Minimal view: Velocity circle with number + fully expanded white card on hover
                    const velocityColor = data.velocity === 3 ? '#EF4444' : data.velocity === 2 ? '#F59E0B' : '#22C55E';

                    card.innerHTML = `
                <!-- Number circle - always visible -->
                <!--Z-index higher than expand card to sit on top-->
                        <!--Removed position:relative to keep anchor absolutely positioned(-10, -10) like default view-->
                        <div class="heatmap-driver-anchor ${velocityClass}" title="${driver.title}" style="width: 28px; height: 28px; cursor: pointer; z-index: 101;">
                            <span style="font-size: 12px; font-weight: 700; color: white;">${driverIndex}</span>
                        </div>
                        
                        <!--Expandable details - Full White Card mimicking Default View-->
                        <!--Anchored Top-Right(Expanded Left) to match user preference-->
                <div class="minimal-expand" style="
                            display: none;
                            position: absolute;
                            top: -10px;
                            right: -10px; /* Align Right edge with anchor */
                            left: auto;
                            width: 260px;
                            background: rgba(255, 255, 255, 0.98);
                            backdrop-filter: blur(12px);
                            border: 1px solid rgba(0, 0, 0, 0.1);
                            border-radius: 12px;
                            padding: 16px; /* Standard padding */
                            box-shadow: 0 16px 40px rgba(0,0,0,0.25);
                            z-index: 100;
                            color: #1F2937;
                        ">
                    <!-- Header -->
                    <div class="heatmap-driver-header" style="margin-bottom: 2px; padding-right: 20px;"> <!-- Padding right to avoid anchor overlap -->
                        <div class="heatmap-driver-title" style="color: #1F2937; font-size: 13px;">${driver.title}</div>
                    </div>

                    <!-- Category -->
                    <span class="heatmap-driver-category" style="background: ${driver.tagColor}; color: ${driver.textColor}; font-size: 9px; padding: 2px 8px; margin-bottom: 10px;">${driver.cat}</span>

                    <!-- Description -->
                    <div style="font-size: 11px; color: #4B5563; line-height: 1.4; margin-bottom: 12px;">${driver.desc}</div>

                    <!-- Assessment Justifications -->
                    <div style="padding-top: 10px; border-top: 1px solid rgba(0,0,0,0.08);">
                        ${likelihoodReasoning ? `
                                    <div style="margin-bottom: 10px;">
                                        <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;">
                                            <span style="font-size: 11px; font-weight: 600; color: #2563EB;">ðŸ“Š Likelihood: ${likelihoodLevel} (${data.likelihood}/10)</span>
                                        </div>
                                        <div style="font-size: 11px; color: #4B5563; line-height: 1.4; padding-left: 2px;">${likelihoodReasoning}</div>
                                    </div>
                                    ` : ''}

                        ${materialityReasoning ? `
                                    <div style="margin-bottom: 10px;">
                                        <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;">
                                            <span style="font-size: 11px; font-weight: 600; color: #DC2626;">ðŸ’¥ Materiality: ${materialityLevel} (${data.materiality}/10)</span>
                                        </div>
                                        <div style="font-size: 11px; color: #4B5563; line-height: 1.4; padding-left: 2px;">${materialityReasoning}</div>
                                    </div>
                                    ` : ''}

                        ${velocityReasoning ? `
                                    <div style="margin-bottom: 10px;">
                                        <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;">
                                            <span style="font-size: 11px; font-weight: 600; color: #F59E0B;">âš¡ Velocity: ${velocityLabel}</span>
                                        </div>
                                        <div style="font-size: 11px; color: #4B5563; line-height: 1.4; padding-left: 2px;">${velocityReasoning}</div>
                                    </div>
                                    ` : ''}
                    </div>

                    <!-- Meta -->
                    <div style="display: flex; gap: 8px; flex-wrap: wrap; font-size: 10px; color: #6B7280; padding-top: 8px; border-top: 1px solid rgba(0,0,0,0.06);">
                        <span>Likelihood: <strong style="color: #1F2937;">${likelihoodAbbr}</strong></span>
                        <span>Materiality: <strong style="color: #1F2937;">${materialityAbbr}</strong></span>
                        <span>Velocity: <strong style="color: #1F2937;">${velocityAbbr}</strong></span>
                    </div>
                </div>
            `;
                    card.style.cursor = 'pointer';
                } else if (heatMapViewMode === 'compact') {
                    // Compact view: Small pill with velocity dot and title only, expands on hover
                    const velocityColor = data.velocity === 3 ? '#EF4444' : data.velocity === 2 ? '#F59E0B' : '#22C55E';

                    card.innerHTML = `
                        <div class="compact-pill" style="
                            display: inline-flex;
                            flex-direction: column;
                            background: rgba(255, 255, 255, 0.98);
                            border: 1px solid rgba(0, 0, 0, 0.1);
                            border-radius: 12px;
                            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                            cursor: pointer;
                            overflow: visible;
                        ">
                            <!-- Header: always visible (white pill with just title) -->
                            <div style="
                                display: flex;
                                align-items: center;
                                gap: 6px;
                                padding: 6px 10px;
                            ">
                                <span style="
                                    width: 8px;
                                    height: 8px;
                                    border-radius: 50%;
                                    background: ${velocityColor};
                                    flex-shrink: 0;
                                "></span>
                                <span style="
                                    font-size: 11px;
                                    font-weight: 600;
                                    color: #1F2937;
                                ">${driver.title}</span>
                            </div>
                            
                            <!-- Expandable details: hidden by default, shown on hover -->
                            <div class="compact-expand" style="display: none;">
                                <div style="
                                    background: rgba(255, 255, 255, 0.98);
                                    border-radius: 0 0 12px 12px;
                                    padding: 12px;
                                    color: #1F2937;
                                    min-width: 260px;
                                    max-width: 320px;
                                    border-top: 1px solid rgba(0,0,0,0.06);
                                ">
                                    <span style="display: inline-block; font-size: 10px; background: ${driver.tagColor}; color: ${driver.textColor}; padding: 3px 10px; border-radius: 6px; margin-bottom: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px;">${driver.cat}</span>
                                    <div style="font-size: 11px; color: #4B5563; line-height: 1.5; margin-bottom: 12px;">
                                        ${driver.desc}
                                    </div>

                                    <!-- Summary Meta -->
                                    <div style="display: flex; gap: 8px; flex-wrap: wrap; font-size: 10px; color: #6B7280; padding-top: 8px; border-top: 1px solid rgba(0,0,0,0.06);">
                                        <span>Likelihood: <strong style="color: #1F2937;">${likelihoodAbbr}</strong></span>
                                        <span>Materiality: <strong style="color: #1F2937;">${materialityAbbr}</strong></span>
                                        <span>Velocity: <strong style="color: #1F2937;">${velocityAbbr}</strong></span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                    card.style.cursor = 'pointer';
                } else {
                    // Default view: Card with title, category, description, and compact L/M/V row visible
                    // Detailed reasoning only shows on click/expansion
                    card.innerHTML = `
                        <!--Card body - collapses during drag-->
                        <div class="heatmap-driver-body">
                            <div class="heatmap-driver-header">
                                <div class="heatmap-driver-title">${driver.title}</div>
                            </div>
                            <span class="heatmap-driver-category" style="background: ${driver.tagColor}; color: ${driver.textColor};">${driver.cat}</span>

                            <!-- Description - always visible -->
                            <div class="heatmap-driver-desc" style="font-size: 11px; color: rgba(255, 255, 255, 0.7); line-height: 1.4; margin-top: 8px; display: -webkit-box; -webkit-line-clamp: 2; line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;">${driver.desc}</div>

                            <!-- Compact L/M/V row with lightning bolt - always visible -->
                            <div class="heatmap-driver-meta" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px; padding-top: 8px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                                <div style="display: flex; gap: 8px; font-size: 10px; color: rgba(255, 255, 255, 0.6);">
                                    <span>Likelihood: <strong style="color: white;">${likelihoodAbbr}</strong></span>
                                    <span>Materiality: <strong style="color: white;">${materialityAbbr}</strong></span>
                                    <span>Velocity: <strong style="color: white;">${velocityAbbr}</strong></span>
                                </div>
                                <!-- Lightning bolt indicator -->
                                <div class="heatmap-driver-velocity-icon ${velocityClass}" style="width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background: ${data.velocity === 3 ? '#EF4444' : data.velocity === 2 ? '#F59E0B' : '#22C55E'}; box-shadow: 0 2px 8px ${data.velocity === 3 ? 'rgba(239, 68, 68, 0.4)' : data.velocity === 2 ? 'rgba(245, 158, 11, 0.4)' : 'rgba(34, 197, 94, 0.4)'};">
                                    <svg viewBox="0 0 24 24" style="width: 12px; height: 12px; fill: white;"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z" /></svg>
                                </div>
                            </div>

                            <!-- Expandable details - hidden by default, shown on click -->
                            <div class="heatmap-driver-expand">
                                <!-- Assessment Justifications Section -->
                                <div class="heatmap-driver-assessment" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                                    ${likelihoodReasoning ? `
                                        <div class="assessment-item" style="margin-bottom: 8px;">
                                            <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 3px;">
                                                <span style="font-size: 11px; font-weight: 600; color: #60A5FA;">ðŸ“Š Likelihood: ${likelihoodLevel} (${data.likelihood}/10)</span>
                                            </div>
                                            <div style="font-size: 11px; color: rgba(255, 255, 255, 0.7); line-height: 1.4; padding-left: 2px;">${likelihoodReasoning}</div>
                                        </div>
                                    ` : ''}

                                    ${materialityReasoning ? `
                                        <div class="assessment-item" style="margin-bottom: 8px;">
                                            <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 3px;">
                                                <span style="font-size: 11px; font-weight: 600; color: #F87171;">ðŸ’¥ Materiality: ${materialityLevel} (${data.materiality}/10)</span>
                                            </div>
                                            <div style="font-size: 11px; color: rgba(255, 255, 255, 0.7); line-height: 1.4; padding-left: 2px;">${materialityReasoning}</div>
                                        </div>
                                    ` : ''}

                                    ${velocityReasoning ? `
                                        <div class="assessment-item">
                                            <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 3px;">
                                                <span style="font-size: 11px; font-weight: 600; color: #FBBF24;">âš¡ Velocity: ${velocityLabel}</span>
                                            </div>
                                            <div style="font-size: 11px; color: rgba(255, 255, 255, 0.7); line-height: 1.4; padding-left: 2px;">${velocityReasoning}</div>
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                }

                // Track if drag occurred to prevent click
                let hasDragged = false;
                let dragStartX = 0;
                let dragStartY = 0;

                // Hover to bring to front with visual feedback
                card.addEventListener('mouseenter', () => {
                    // Bring to front
                    card.style.zIndex = 1000;
                    // Add subtle glow effect
                    card.style.boxShadow = '0 0 0 2px var(--primary), 0 8px 24px rgba(0,0,0,0.15)';
                });

                card.addEventListener('mouseleave', () => {
                    // Reset z-index to layer based on position
                    card.style.zIndex = Math.floor(10 + yPercent);
                    // Remove glow
                    card.style.boxShadow = '';
                });

                // Unified click handler
                card.addEventListener('click', (e) => {
                    if (hasDragged) {
                        hasDragged = false; // Reset for next interaction
                        return; // Ignore click after drag
                    }

                    // For compact/minimal views, just open details on click
                    if (heatMapViewMode === 'compact' || heatMapViewMode === 'minimal') {
                        openDriverDetails(driver.id);
                        return;
                    }

                    // For default view: check if clicked on velocity icon to cycle velocity
                    const isVelocityIcon = e.target.closest('.heatmap-driver-velocity-icon');
                    if (isVelocityIcon) {
                        e.stopPropagation();
                        cycleVelocity(driver.id);
                        return;
                    }

                    // Otherwise toggle the expanded state to show/hide reasoning details
                    card.classList.toggle('expanded');
                });

                // Add drag handlers with threshold to distinguish from clicks
                card.addEventListener('mousedown', (e) => {
                    // Prevent drag side-effects if interacting with expanded text content in minimal/compact views
                    // This allows text selection to work naturally without triggering a drag/update
                    if (heatMapViewMode === 'minimal' || heatMapViewMode === 'compact') {
                        if (e.target.closest('.minimal-expand') || e.target.closest('.compact-expand')) {
                            return;
                        }
                    }

                    hasDragged = false;
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    let dragInitiated = false;

                    const onMouseMove = (moveE) => {
                        const dx = Math.abs(moveE.clientX - dragStartX);
                        const dy = Math.abs(moveE.clientY - dragStartY);

                        // Only start drag if moved more than 5 pixels
                        if (!dragInitiated && (dx > 5 || dy > 5)) {
                            hasDragged = true;
                            dragInitiated = true;
                            document.removeEventListener('mousemove', onMouseMove);
                            startHeatmapDrag(e, card, driver.id);
                        }
                    };

                    const onMouseUp = () => {
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                    };

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                });

                grid.appendChild(card);
            });
        }



        // Helper function to get Low/Medium/High label from 1-10 score
        // Helper function to get Low/Medium/High label from 1-10 score
        function getLevelLabel(score) {
            if (score <= 3) return 'Low';
            if (score <= 7) return 'Medium';
            return 'High';
        }

        // Cycle velocity when clicking the velocity indicator
        function cycleVelocity(driverId) {
            if (!heatMapData[driverId]) return;

            // Cycle: 1 -> 2 -> 3 -> 1
            heatMapData[driverId].velocity = (heatMapData[driverId].velocity % 3) + 1;
            heatMapData[driverId].aiGenerated = false;

            // Re-render heat map and driver list
            renderHeatMap();
            renderHeatMapDriverList();
        }


        // Heat map drag functionality
        let isDraggingHeatmap = false;
        let currentDragCard = null;
        let dragStartX = 0;
        let dragStartY = 0;
        let cardStartX = 0;
        let cardStartY = 0;

        function startHeatmapDrag(e, card, driverId) {
            if (e.button !== 0) return; // Only left click

            isDraggingHeatmap = true;
            currentDragCard = card;
            card.classList.add('dragging');

            dragStartX = e.clientX;
            dragStartY = e.clientY;
            cardStartX = card.offsetLeft;
            cardStartY = card.offsetTop;

            document.addEventListener('mousemove', handleHeatmapDrag);
            document.addEventListener('mouseup', endHeatmapDrag);

            e.preventDefault();
        }

        function handleHeatmapDrag(e) {
            if (!isDraggingHeatmap || !currentDragCard) return;

            const grid = document.getElementById('heatmapGrid');
            const gridRect = grid.getBoundingClientRect();

            const deltaX = e.clientX - dragStartX;
            const deltaY = e.clientY - dragStartY;

            let newX = cardStartX + deltaX;
            let newY = cardStartY + deltaY;

            // During drag, card is collapsed to 24x24 circle
            const circleSize = 24;

            // Allow small margin from edges
            const margin = 10;
            // Full width (legend moved out)
            const rightLimit = gridRect.width - circleSize - margin;

            newX = Math.max(margin, Math.min(rightLimit, newX));
            newY = Math.max(margin, Math.min(gridRect.height - circleSize - margin, newY));

            currentDragCard.style.left = `${newX}px`;
            currentDragCard.style.top = `${newY}px`;
        }


        function endHeatmapDrag(e) {
            if (!isDraggingHeatmap || !currentDragCard) return;

            const grid = document.getElementById('heatmapGrid');
            const gridRect = grid.getBoundingClientRect();
            const driverId = currentDragCard.getAttribute('data-driver-id');

            // Calculate position based on circle center (which is at card's top-left + 12px)
            const circleSize = 24;
            const circleCenterX = currentDragCard.offsetLeft + circleSize / 2;
            const circleCenterY = currentDragCard.offsetTop + circleSize / 2;

            // Use full width for percentage calculation
            const usableWidth = gridRect.width;
            const xPercent = circleCenterX / usableWidth;
            const yPercent = circleCenterY / gridRect.height;

            // Convert to 1-10 scale
            const newLikelihood = Math.round(xPercent * 9) + 1;
            const newMateriality = Math.round((1 - yPercent) * 9) + 1; // Invert Y

            // Clamp values
            heatMapData[driverId].likelihood = Math.max(1, Math.min(10, newLikelihood));
            heatMapData[driverId].materiality = Math.max(1, Math.min(10, newMateriality));
            heatMapData[driverId].aiGenerated = false; // Mark as user-modified

            // Clean up drag state
            currentDragCard.classList.remove('dragging');
            document.removeEventListener('mousemove', handleHeatmapDrag);
            document.removeEventListener('mouseup', endHeatmapDrag);

            isDraggingHeatmap = false;
            currentDragCard = null;

            // Full Re-render to ensure all views (Compact/Minimal) reflect updated data
            renderHeatMap();
            renderHeatMapDriverList();
        }


        function renderCategoryLegend() {
            const legendContainer = document.getElementById('categoryLegendItems');
            if (!legendContainer) return;

            // Get unique categories from ALL drivers to keep legend stable
            const categories = [...new Set(selectedDrivers.map(d => d.cat))];

            legendContainer.innerHTML = categories.map(cat => {
                const driver = selectedDrivers.find(d => d.cat === cat);
                const isActive = activeCategoryFilters.size === 0 || activeCategoryFilters.has(cat);
                const dimClass = isActive ? '' : 'legend-dimmed';
                return `
                <div class="heatmap-legend-item ${dimClass}" onclick="toggleCategoryFilter('${cat}')">
                        <div class="heatmap-legend-color" style="background: ${driver.tagColor}; border: 1px solid ${driver.textColor}; width: 12px; height: 12px; border-radius: 3px;"></div>
                        <span>${cat}</span>
                    </div>
                `;
            }).join('');
        }

        async function generateScenarioFromHeatMap() {
            if (selectedDrivers.length === 0) {
                alert('No drivers in heat map.');
                return;
            }

            // Enhance drivers with heat map data for scenario generation
            const enhancedDrivers = selectedDrivers.map(d => {
                const hmData = heatMapData[d.id] || { likelihood: 5, materiality: 5, velocity: 2 };
                const velocityLabel = hmData.velocity === 3 ? 'High (< 2 weeks)' :
                    hmData.velocity === 2 ? 'Medium (2 weeks - 3 months)' :
                        'Low (> 3 months)';
                return {
                    ...d,
                    heatMapLikelihood: hmData.likelihood,
                    heatMapMateriality: hmData.materiality,
                    heatMapVelocity: velocityLabel,
                    heatMapVelocityVal: hmData.velocity,
                    heatMapContext: `This risk has a materiality of ${hmData.materiality}/10 with ${velocityLabel.toLowerCase()} velocity.`
                };
            });

            // Sort by Materiality (Likelihood ignored as event is assumed to happen)
            enhancedDrivers.sort((a, b) => {
                if (b.heatMapMateriality !== a.heatMapMateriality) return b.heatMapMateriality - a.heatMapMateriality;
                return b.heatMapVelocityVal - a.heatMapVelocityVal; // Secondary sort: Velocity
            });

            // Call existing generateScenario but with enhanced context
            await generateScenarioWithHeatMapData(enhancedDrivers);
        }

        async function generateScenarioWithHeatMapData(enhancedDrivers) {
            const loader = document.getElementById('loader');
            const loaderText = document.getElementById('loaderText');
            loader.style.display = 'flex';
            loaderText.innerText = 'Fetching baseline macro data...';

            try {
                // Determine current period info for baseline data
                const currentPeriodInfo = {
                    quarter: `Q${Math.ceil((new Date().getMonth() + 1) / 3)} `,
                    year: new Date().getFullYear()
                };

                // Fetch baseline macro data from CSV
                const baselineMacroData = await fetchBaselineMacroData(currentPeriodInfo);

                // Build baseline context for AI prompt and extract numeric values
                let baselineContext = '';
                let baselineNumericValues = {};

                if (baselineMacroData && baselineMacroData.values) {
                    const vals = baselineMacroData.values;

                    // Extract numeric values from formatted strings
                    const extractNumeric = (val) => {
                        if (!val) return null;
                        const match = val.match(/^([+-]?\d+\.?\d*)/);
                        return match ? parseFloat(match[1]) : null;
                    };

                    const extractQoQ = (val) => {
                        const match = val?.match(/QoQ:\s*([+-]?\d+\.\d+%)/);
                        return match ? match[1] : val;
                    };

                    const extractQoQNumeric = (val) => {
                        const match = val?.match(/QoQ:\s*([+-]?\d+\.\d+)/);
                        return match ? parseFloat(match[1]) : null;
                    };

                    // Store numeric baseline values for later delta calculation
                    baselineNumericValues = {
                        gdp: extractQoQNumeric(vals['Canada GDP']),
                        unemployment: extractNumeric(vals['Unemployment Rate']),
                        inflation: extractNumeric(vals['CPI Inflation']),
                        cadUsd: extractNumeric(vals['CAD/USD']),
                        bocRate: extractNumeric(vals['BoC Rate']),
                        hpi: extractQoQNumeric(vals['House Price Index']),
                        tsx: extractQoQNumeric(vals['TSX Composite']),
                        creditSpreads: extractNumeric(vals['Credit Spreads'])
                    };

                    console.log('ðŸ“Š Extracted baseline numeric values:', baselineNumericValues);

                    baselineContext = `
BASELINE MACROECONOMIC DATA(${currentPeriodInfo.quarter} ${currentPeriodInfo.year}):
            - Canada GDP Growth(QoQ): ${extractQoQ(vals['Canada GDP']) || 'N/A'}
            - Unemployment Rate: ${vals['Unemployment Rate'] || 'N/A'}
            - CPI Inflation: ${vals['CPI Inflation'] || 'N/A'}
            - USD / CAD Exchange Rate: ${vals['CAD/USD'] || 'N/A'} (CAD per 1 USD - higher = weaker CAD)
            - Bank of Canada Policy Rate: ${vals['BoC Rate'] || 'N/A'}
            - House Price Index(QoQ): ${extractQoQ(vals['House Price Index']) || 'N/A'}
            - TSX Composite(QoQ): ${extractQoQ(vals['TSX Composite']) || 'N/A'}
            - Credit Spreads(10Y BBB): ${vals['Credit Spreads'] || 'N/A'}

These are reference values for context only.Generate stress projections as absolute values; the system will calculate deltas automatically.

                CRITICAL: For USD / CAD, use the format "1.XX"(CAD per 1 USD).For example, 1.45 means 1 USD = 1.45 CAD.Higher values = weaker CAD, lower values = stronger CAD.
`;
                }

                // Store for post-processing
                window.currentBaselineValues = baselineNumericValues;

                loaderText.innerText = 'Generating scenario narrative with heat map insights...';

                // Categorize drivers by Materiality only (Likelihood ignored)
                const highRiskDrivers = enhancedDrivers.filter(d =>
                    d.heatMapMateriality >= 7
                );
                const moderateRiskDrivers = enhancedDrivers.filter(d =>
                    d.heatMapMateriality >= 5 && d.heatMapMateriality < 7
                );
                const immediateThreats = enhancedDrivers.filter(d =>
                    d.heatMapVelocity.includes('High')
                );
                const nearTermThreats = enhancedDrivers.filter(d =>
                    d.heatMapVelocity.includes('Medium')
                );

                // Build driver list (without mentioning scores in the description for AI)
                const driversSummary = enhancedDrivers.map((d, idx) =>
                    `${idx + 1}.[${d.cat}] ${d.title}: ${d.desc} `
                ).join('\n');

                // Calculate overall severity guidance (Materiality only)
                const avgMateriality = enhancedDrivers.reduce((sum, d) => sum + d.heatMapMateriality, 0) / enhancedDrivers.length;
                const severityGuidance = avgMateriality >= 7 ? 'SEVERE' :
                    avgMateriality >= 5 ? 'MODERATE' : 'MILD';

                const prompt = fillPrompt(PROMPT_TEMPLATES.SCENARIO_GENERATION, {
                    BASELINE_CONTEXT: baselineContext,
                    DRIVERS_SUMMARY: driversSummary,
                    SEVERITY: severityGuidance,
                    HIGH_RISKS: highRiskDrivers.map(d => d.title).join(', ') || 'None in high-risk category',
                    IMMEDIATE_THREATS: immediateThreats.map(d => d.title).join(', ') || 'None identified',
                    NEAR_TERM_THREATS: nearTermThreats.map(d => d.title).join(', ') || 'None identified'
                });


                loaderText.innerText = 'AI is generating scenario narrative...';

                const response = await fetch(AZURE_OPENAI_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-5-2025-08-07-eastus-dz',
                        messages: [{ role: 'user', content: prompt }],
                        // temperature omitted - GPT-5 only supports default value of 1
                        max_tokens: 20000
                    })
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                loaderText.innerText = 'Processing scenario data...';

                const data = await response.json();
                const aiResponse = data.choices[0].message.content;

                // Parse the JSON response
                let scenario;
                try {
                    const jsonMatch = aiResponse.match(/```json\s*([\s\S]*?)\s*```/) ||
                        aiResponse.match(/```\s*([\s\S]*?)\s*```/);
                    if (jsonMatch) {
                        scenario = JSON.parse(jsonMatch[1]);
                    } else {
                        const directMatch = aiResponse.match(/\{[\s\S]*\}/);
                        if (directMatch) {
                            scenario = JSON.parse(directMatch[0]);
                        } else {
                            throw new Error('No JSON found in response');
                        }
                    }
                } catch (parseError) {
                    console.error('Failed to parse scenario JSON:', parseError);
                    console.log('Raw response:', aiResponse);
                    throw new Error('Failed to parse AI response');
                }

                // POST-PROCESS: Calculate macro deltas and directions from baseline values
                console.log('ðŸ“Š Post-processing heat map scenario with baselines:', baselineNumericValues);

                if (scenario.macroProjections && baselineNumericValues && Object.keys(baselineNumericValues).length > 0) {
                    const macro = scenario.macroProjections;

                    // Helper to extract numeric value from string
                    const extractNumber = (val) => {
                        if (typeof val === 'number') return val;
                        if (typeof val === 'string') {
                            const cleaned = val.replace(/[^\d.-]/g, '');
                            return parseFloat(cleaned);
                        }
                        return NaN;
                    };

                    // Canada GDP - calculate delta from baseline
                    if (macro.canadaGDP && macro.canadaGDP.value) {
                        const gdpValue = extractNumber(macro.canadaGDP.value);
                        if (!isNaN(gdpValue)) {
                            const absDelta = Math.abs(gdpValue).toFixed(1);
                            macro.canadaGDP.delta = `â†“ ${absDelta}% from current`;
                            macro.canadaGDP.direction = 'negative';
                        }
                    }

                    // Unemployment - calculate delta from actual baseline
                    if (macro.unemployment && macro.unemployment.value && baselineNumericValues.unemployment) {
                        const stressValue = extractNumber(macro.unemployment.value);
                        const baselineValue = baselineNumericValues.unemployment;
                        if (!isNaN(stressValue)) {
                            const delta = stressValue - baselineValue;
                            const arrow = delta > 0 ? 'â†‘' : 'â†“';
                            macro.unemployment.delta = `${arrow} to ${stressValue.toFixed(1)}% from ${baselineValue.toFixed(1)}%`;
                            macro.unemployment.direction = delta > 0 ? 'negative' : 'positive';
                        }
                    }

                    // CPI Inflation - calculate delta from actual baseline
                    if (macro.inflation && macro.inflation.value && baselineNumericValues.inflation) {
                        const stressValue = extractNumber(macro.inflation.value);
                        const baselineValue = baselineNumericValues.inflation;
                        if (!isNaN(stressValue)) {
                            const delta = stressValue - baselineValue;
                            const arrow = delta > 0 ? 'â†‘' : 'â†“';
                            macro.inflation.delta = `${arrow} to ${stressValue.toFixed(1)}% from ${baselineValue.toFixed(1)}%`;
                            macro.inflation.direction = delta > 0 ? 'negative' : 'positive';
                        }
                    }

                    // USD/CAD - calculate delta from actual baseline
                    const usdCadData = macro.usdCad || macro.cadUsd;
                    if (usdCadData && usdCadData.value && baselineNumericValues.cadUsd) {
                        const stressValue = extractNumber(usdCadData.value);
                        const baselineValue = baselineNumericValues.cadUsd;
                        if (!isNaN(stressValue)) {
                            const delta = stressValue - baselineValue;
                            const arrow = delta > 0 ? 'â†‘' : 'â†“';
                            usdCadData.delta = `${arrow} to ${stressValue.toFixed(2)} from ${baselineValue.toFixed(2)}`;
                            usdCadData.direction = delta > 0 ? 'negative' : 'positive';
                        }
                        if (macro.usdCad) macro.cadUsd = macro.usdCad;
                        if (macro.cadUsd && !macro.usdCad) macro.usdCad = macro.cadUsd;
                    }

                    // BoC Rate - calculate delta from actual baseline
                    if (macro.bocRate && macro.bocRate.value && baselineNumericValues.bocRate) {
                        const stressValue = extractNumber(macro.bocRate.value);
                        const baselineValue = baselineNumericValues.bocRate;
                        if (!isNaN(stressValue)) {
                            const deltaBps = Math.round((stressValue - baselineValue) * 100);
                            const arrow = deltaBps < 0 ? 'â†“' : 'â†‘';
                            macro.bocRate.delta = `${arrow} ${Math.abs(deltaBps)} bps to ${stressValue.toFixed(2)}% from ${baselineValue.toFixed(1)}%`;
                            macro.bocRate.direction = deltaBps < 0 ? 'positive' : 'negative';
                        }
                    }

                    // House Price Index - calculate delta
                    if (macro.housePrice && macro.housePrice.value) {
                        const hpiValue = extractNumber(macro.housePrice.value);
                        if (!isNaN(hpiValue)) {
                            macro.housePrice.delta = `â†“ ${Math.abs(hpiValue).toFixed(1)}% from current`;
                            macro.housePrice.direction = 'negative';
                        }
                    }

                    // TSX Composite - calculate delta
                    if (macro.tsx && macro.tsx.value) {
                        const tsxValue = extractNumber(macro.tsx.value);
                        if (!isNaN(tsxValue)) {
                            macro.tsx.delta = `â†“ ${Math.abs(tsxValue).toFixed(1)}% from current`;
                            macro.tsx.direction = 'negative';
                        }
                    }

                    // Credit Spreads - calculate delta from actual baseline
                    if (macro.creditSpreads && macro.creditSpreads.value && baselineNumericValues.creditSpreads) {
                        const stressValue = extractNumber(macro.creditSpreads.value);
                        const baselineValue = baselineNumericValues.creditSpreads;
                        if (!isNaN(stressValue)) {
                            const stressBps = Math.round(stressValue * 100);
                            const baselineBps = Math.round(baselineValue * 100);
                            const deltaBps = stressBps - baselineBps;
                            macro.creditSpreads.value = `+${stressBps} bps`;
                            macro.creditSpreads.delta = `â†‘ ${deltaBps} bps to +${stressBps} from ${baselineBps} bps`;
                            macro.creditSpreads.direction = 'negative';
                        }
                    }

                    console.log('ðŸ“Š Final processed heat map macro projections:', macro);
                }

                loaderText.innerText = 'Rendering scenario report...';
                await new Promise(r => setTimeout(r, 500));

                // Store the generated scenario for later use
                window.currentGeneratedScenario = scenario;

                // Use the same rendering function as regular scenario generation
                // Store enhanced drivers as selectedDrivers for rendering
                selectedDrivers = enhancedDrivers;

                // Render using the standard format
                renderAIReport(scenario);

            } catch (error) {
                console.error('Heat map scenario generation error:', error);
                loader.style.display = 'none';
                alert(`Failed to generate scenario: ${error.message}. Please try again.`);
            } finally {
                loader.style.display = 'none';
            }
        }

        function exportReport() {
            alert('PDF export would be implemented here using jsPDF or server-side generation.');
        }


        // --- DRAG AND DROP HANDLERS ---
        function handleDragStart(e, id) {
            if (!id) return;
            e.dataTransfer.setData("text/plain", id);
            e.dataTransfer.effectAllowed = "copy";

            // Visual feedback on basket
            const basket = document.getElementById('basketPanel');
            basket.style.transition = 'all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)';
            // Use INSET shadow to stay within bounds
            basket.style.boxShadow = 'inset 0 0 0 3px var(--primary), var(--shadow-float)';
        }

        function handleDragEnd(e) {
            const basket = document.getElementById('basketPanel');
            basket.style.transform = '';
            basket.style.boxShadow = '';
            basket.style.background = '';
            basket.classList.remove('drag-over');
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
            return false;
        }

        function handleDragEnter(e) {
            e.preventDefault();
            const basket = document.getElementById('basketPanel');
            if (!basket.classList.contains('drag-over')) {
                basket.classList.add('drag-over');
                basket.style.background = 'rgba(239, 246, 255, 0.95)'; // Highlight blue
                basket.style.borderColor = 'var(--primary)';
            }
        }

        function handleDragLeave(e) {
            const basket = document.getElementById('basketPanel');
            // Check if leaving basket panel completely (not entering a child)
            if (!basket.contains(e.relatedTarget)) {
                basket.classList.remove('drag-over');
                basket.style.background = '';
                basket.style.borderColor = '';
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            handleDragEnd(e); // Reset styles

            const id = e.dataTransfer.getData("text/plain");
            if (id) {
                // Add if not already present
                const exists = selectedDrivers.some(d => d.id === id);
                if (!exists) {
                    toggleDriver(id);
                } else {
                    // Maybe shake animation to say "already added"?
                    const basket = document.getElementById('basketPanel');
                    basket.animate([
                        { transform: 'translateX(0)' },
                        { transform: 'translateX(-5px)' },
                        { transform: 'translateX(5px)' },
                        { transform: 'translateX(0)' }
                    ], { duration: 300 });
                }
            }
        }

        // Export current report overlay as PDF
        function exportScenarioPdf() {
            const title = (document.getElementById('reportTitle')?.innerText || 'Scenario')
                .replace(/[^a-z0-9\s\-]/gi, '')
                .trim();
            const dateStr = new Date().toISOString().slice(0, 10);

            // Clone the report container to avoid modifying the live DOM
            const reportContainer = document.querySelector('.report-container');
            if (!reportContainer) {
                alert('Report content not available to export.');
                return;
            }

            const clone = reportContainer.cloneNode(true);
            // Optional: remove interactive elements from clone
            clone.querySelectorAll('button, input, textarea, .chat-input-area, .report-actions').forEach(n => n.remove());

            const opt = {
                margin: 10,
                filename: `${title.replace(/\s+/g, '_')}_${dateStr}.pdf`,
                image: { type: 'jpeg', quality: 0.98 },
                html2canvas: { scale: 2, useCORS: true },
                jsPDF: { unit: 'pt', format: 'a4', orientation: 'portrait' }
            };

            // Create a container element to render
            const wrapper = document.createElement('div');
            wrapper.style.padding = '20px';
            wrapper.style.background = '#ffffff';
            wrapper.appendChild(clone);

            // Use html2pdf to generate PDF
            if (window.html2pdf) {
                window.html2pdf().set(opt).from(wrapper).save();
            } else {
                alert('PDF library not loaded. Please refresh the page.');
            }
        }
        // --- PDF EXPORT FUNCTION ---
        // --- PDF EXPORT FUNCTION (Smart Page Breaks) ---
        async function exportScenarioPdf() {
            const btn = document.getElementById('exportPdfBtn');
            const originalText = btn ? btn.innerHTML : '';

            try {
                if (btn) btn.innerHTML = 'â³ Generating PDF...';
                if (btn) btn.disabled = true;

                // --- 1. SETUP PDF & DATA ---
                const title = (document.getElementById('reportTitle')?.innerText || 'Scenario')
                    .replace(/[^a-z0-9\s\-]/gi, '').trim();
                const dateStr = new Date().toISOString().slice(0, 10);
                const filename = `${title.replace(/\s+/g, '_')}_${dateStr}.pdf`;

                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('p', 'mm', 'a4');
                const pageWidth = 210;
                const pageHeight = 297;
                const margin = 15; // mm
                const contentWidth = pageWidth - (margin * 2);
                let cursorY = margin;

                // --- 2. SETUP OFF-SCREEN RENDER CONTAINER ---
                // We recreate the DOM structure to ensure styles apply correctly during partial capture
                const renderContainer = document.createElement('div');
                renderContainer.style.position = 'absolute';
                renderContainer.style.left = '-9999px';
                renderContainer.style.top = '0';
                renderContainer.style.width = '800px'; // Fixed width for consistent text wrapping
                renderContainer.style.background = '#ffffff';
                // wrapper to match CSS selectors
                renderContainer.innerHTML = '<div class="report-main"><div class="report-body" id="renderBody"></div></div>';
                document.body.appendChild(renderContainer);

                const renderBody = renderContainer.querySelector('#renderBody');

                // --- HELPER: CAPTURE & ADD TO PDF ---
                async function captureAndAdd(element, addsPadding = true) {
                    renderBody.appendChild(element); // Move element to render area

                    const canvas = await html2canvas(element, {
                        scale: 2,
                        useCORS: true,
                        logging: false,
                        backgroundColor: '#ffffff'
                    });

                    const imgData = canvas.toDataURL('image/jpeg', 0.95);
                    const imgHeight = (canvas.height * contentWidth) / canvas.width;

                    // Check page break
                    if (cursorY + imgHeight > pageHeight - margin) {
                        pdf.addPage();
                        cursorY = margin;
                    }

                    pdf.addImage(imgData, 'JPEG', margin, cursorY, contentWidth, imgHeight);
                    cursorY += imgHeight + (addsPadding ? 8 : 0); // Add spacing between sections

                    renderBody.innerHTML = ''; // Clean up for next item
                }

                // --- 3. PROCESS HEADER ---
                const originalHeader = document.querySelector('.report-header');
                if (originalHeader) {
                    const headerClone = originalHeader.cloneNode(true);
                    // Stylistic adjustments for white paper export
                    headerClone.style.background = 'white';
                    headerClone.style.color = '#0F172A';
                    headerClone.style.borderBottom = '2px solid #2563EB';
                    headerClone.style.padding = '20px 0';
                    headerClone.style.marginBottom = '10px';

                    // Fix text colors manually since we stripped the dark background
                    const hTitle = headerClone.querySelector('.report-title');
                    if (hTitle) hTitle.style.color = '#0F172A';
                    const hSub = headerClone.querySelector('.report-subtitle');
                    if (hSub) hSub.style.color = '#64748b';

                    // Remove buttons
                    const buttons = headerClone.querySelectorAll('button');
                    buttons.forEach(b => b.remove());

                    await captureAndAdd(headerClone);
                }

                // --- 4. PROCESS SECTIONS LOOP ---
                // We capture each section individually to ensure we never cut a section in half
                const sections = document.querySelectorAll('.report-section');
                for (const section of sections) {
                    const sectionClone = section.cloneNode(true);
                    // Ensure text colors are correct for white paper
                    sectionClone.style.color = '#334155';
                    sectionClone.style.marginBottom = '0'; // We handle spacing via cursorY
                    sectionClone.style.padding = '10px';
                    sectionClone.style.background = 'white';
                    sectionClone.style.borderRadius = '0'; // Clean look
                    // Ensure titles are dark text
                    const sTitle = sectionClone.querySelector('.section-title');
                    if (sTitle) sTitle.style.color = '#2563EB';

                    await captureAndAdd(sectionClone);
                }

                // --- 5. FINALIZE ---
                pdf.save(filename);
                document.body.removeChild(renderContainer);

                if (btn) {
                    btn.innerHTML = 'âœ… Downloaded!';
                    setTimeout(() => {
                        btn.innerHTML = originalText;
                        btn.disabled = false;
                    }, 2000);
                }

            } catch (error) {
                console.error('PDF Export Error:', error);
                alert('Failed to export PDF: ' + error.message);
                if (btn) {
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                }
            }
        }

    </script>

    <!-- PDF Export Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <script>
        // Heat Map Export Logic
        function openHeatmapExportModal() {
            document.getElementById('heatmapExportModal').style.display = 'flex';
        }

        function closeHeatmapExportModal() {
            document.getElementById('heatmapExportModal').style.display = 'none';
        }

        async function exportHeatmap(format) {
            const heatmapView = document.getElementById('heatMapPanel');
            if (!heatmapView) {
                console.error('Heat Map panel not found!');
                alert('Error: Heat Map panel not active.');
                return;
            }

            // Show loading state (optional, or just change button text if we had a Ref to it)
            // But since this is a modal, we can just proceed.
            const exportModal = document.getElementById('heatmapExportModal');
            exportModal.style.display = 'none'; // Hide modal during capture if it overlaps, though it shouldn't if we capture specific element.  
            // Actually we interpret the user intention to close it after selection.

            // Wait a moment for modal to disappear visually if needed, though we are capturing 'heatmapView' which is in the background.
            // Using html2canvas with onclone to hide instructions

            try {
                const canvas = await html2canvas(heatmapView, {
                    scale: 3, // Increased scale for better clarity
                    useCORS: true,
                    logging: false,
                    backgroundColor: '#ffffff', // Canvas base is white
                    onclone: (clonedDoc) => {
                        const clonedHeatmap = clonedDoc.getElementById('heatMapPanel');
                        if (clonedHeatmap) {
                            // STOP ANIMATIONS: The 'floatIn' animation might be restarting in the clone, causing opacity < 1
                            clonedHeatmap.style.animation = 'none';
                            clonedHeatmap.style.transition = 'none';
                            clonedHeatmap.style.opacity = '1';

                            // 1. Strip main container styles
                            clonedHeatmap.style.background = 'transparent';
                            clonedHeatmap.style.backgroundColor = 'transparent';
                            clonedHeatmap.style.backdropFilter = 'none';
                            clonedHeatmap.style.webkitBackdropFilter = 'none';
                            clonedHeatmap.style.boxShadow = 'none';
                            clonedHeatmap.style.border = 'none';

                            // 2. Nuclear option: Remove ALL backdrop-filters, animations, and transparency issues
                            const allElements = clonedHeatmap.querySelectorAll('*');
                            allElements.forEach(el => {
                                el.style.animation = 'none';
                                el.style.transition = 'none';
                                el.style.backdropFilter = 'none';
                                el.style.webkitBackdropFilter = 'none';
                                if (window.getComputedStyle(el).opacity !== '1') {
                                    el.style.opacity = '1';
                                }
                            });

                            // 3. Ensure the Panel Header (title) is clean
                            const header = clonedHeatmap.querySelector('.panel-header');
                            if (header) {
                                header.style.background = 'transparent';
                                header.style.borderBottom = '1px solid #E2E8F0'; // Keen a subtle divider
                            }
                        }

                        // Hide instructions
                        const instructions = clonedDoc.querySelector('.heatmap-instructions');
                        if (instructions) {
                            instructions.style.display = 'none';
                        }
                    }
                });

                if (format === 'jpg') {
                    const link = document.createElement('a');
                    link.download = 'Risk_Heat_Map.jpg';
                    link.href = canvas.toDataURL('image/jpeg', 0.9);
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                } else if (format === 'pdf') {
                    const { jsPDF } = window.jspdf;
                    const pdf = new jsPDF('landscape', 'mm', 'a4');
                    const imgData = canvas.toDataURL('image/jpeg', 1.0);

                    // Calculate dimensions to fit A4 landscape
                    const imgWidth = 297; // A4 width mm
                    const pageHeight = 210; // A4 height mm
                    const imgHeight = (canvas.height * imgWidth) / canvas.width;

                    let heightLeft = imgHeight;
                    let position = 0;

                    // If image is taller than page, might need scaling, but Heatmap is usually landscape.
                    // Let's center it or fit it.
                    // For a heatmap, fitting to page is best.

                    pdf.addImage(imgData, 'JPEG', 0, 0, imgWidth, imgHeight);
                    pdf.save('Risk_Heat_Map.pdf');
                }

            } catch (error) {
                console.error('Export failed:', error);
                alert('Export failed: ' + error.message);
            }
        }

        function toggleReportSidebar() {
            const sidebar = document.getElementById('reportSidebar');
            if (sidebar) {
                sidebar.classList.toggle('collapsed');
            }
        }

    </script>
    <!-- Settings Modal -->
    <div id="aiPromptsModal" class="modal"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(31, 41, 55, 0.4); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); align-items: center; justify-content: center; z-index: 2000;">
        <div class="modal-content"
            style="width: 900px; height: 80vh; background: #ffffff; border-radius: 16px; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); display: flex; flex-direction: column; overflow: hidden; padding: 0;">
            <div class="modal-header"
                style="padding: 20px; border-bottom: 1px solid var(--border-subtle); display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h2 style="margin: 0; font-size: 18px;">System Settings</h2>
                    <p style="margin: 4px 0 0; font-size: 13px; color: var(--text-muted);">View AI instruction templates
                    </p>
                </div>
                <button class="icon-btn" onclick="closeAiPromptsModal()" style="font-size: 20px;">&times;</button>
            </div>

            <div style="display: flex; flex: 1; overflow: hidden;">
                <!-- Sidebar -->
                <div
                    style="width: 240px; background: #F9FAFB; border-right: 1px solid var(--border-subtle); padding: 16px; overflow-y: auto;">
                    <div
                        style="font-size: 11px; font-weight: 600; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px;">
                        AI Prompts</div>
                    <button id="btn-RISK_DRIVERS" class="settings-nav-btn active" onclick="showPrompt('RISK_DRIVERS')"
                        style="width: 100%; text-align: left; padding: 10px; border: none; background: transparent; border-radius: 8px; font-size: 13px; color: var(--text-main); cursor: pointer; margin-bottom: 4px;">Risk
                        Generation</button>
                    <button id="btn-RISK_DRIVERS_ADDITIONAL" class="settings-nav-btn"
                        onclick="showPrompt('RISK_DRIVERS_ADDITIONAL')"
                        style="width: 100%; text-align: left; padding: 10px; border: none; background: transparent; border-radius: 8px; font-size: 13px; color: var(--text-main); cursor: pointer; margin-bottom: 4px;">Additional
                        Drivers</button>
                    <button id="btn-HEATMAP_ASSESSMENT" class="settings-nav-btn"
                        onclick="showPrompt('HEATMAP_ASSESSMENT')"
                        style="width: 100%; text-align: left; padding: 10px; border: none; background: transparent; border-radius: 8px; font-size: 13px; color: var(--text-main); cursor: pointer; margin-bottom: 4px;">Heat
                        Map Assmnt.</button>
                    <button id="btn-SCENARIO_GENERATION" class="settings-nav-btn"
                        onclick="showPrompt('SCENARIO_GENERATION')"
                        style="width: 100%; text-align: left; padding: 10px; border: none; background: transparent; border-radius: 8px; font-size: 13px; color: var(--text-main); cursor: pointer; margin-bottom: 4px;">Scenario
                        Narrative</button>
                </div>

                <!-- Content -->
                <div id="promptContent"
                    style="flex: 1; padding: 24px; overflow-y: auto; white-space: pre-wrap; font-family: 'Menlo', 'Monaco', 'Courier New', monospace; font-size: 12px; line-height: 1.5; color: #374151; background: white;">
                    Select a prompt to view...
                </div>
            </div>
        </div>
    </div>

    <!-- Styles for Settings Nav -->
    <style>
        .settings-nav-btn:hover {
            background: #F3F4F6 !important;
        }

        .settings-nav-btn.active {
            background: #E0E7FF !important;
            color: #4F46E5 !important;
            font-weight: 500;
        }
    </style>

    <script>
        function openAiPromptsModal() {
            const modal = document.getElementById('aiPromptsModal');
            if (modal) {
                modal.style.display = 'flex';
                showPrompt('RISK_DRIVERS');
            }
        }

        function closeAiPromptsModal() {
            const modal = document.getElementById('aiPromptsModal');
            if (modal) modal.style.display = 'none';
        }

        function showPrompt(key) {
            const content = document.getElementById('promptContent');
            const template = PROMPT_TEMPLATES[key];
            if (content && template) {
                content.textContent = template;

                document.querySelectorAll('.settings-nav-btn').forEach(btn => btn.classList.remove('active'));
                const btn = document.getElementById(`btn-${key}`);
                if (btn) btn.classList.add('active');
            }
        }
    </script>
</body>

</html>